/*
 *	autogen/server/zone/managers/gcw/GCWManager.h generated by engine3 IDL compiler 0.60
 */

#ifndef GCWMANAGER_H_
#define GCWMANAGER_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
namespace server {
namespace zone {

class Zone;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace tangible {

class TangibleObject;

} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible;

namespace server {
namespace zone {
namespace objects {
namespace structure {

class StructureObject;

} // namespace structure
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::structure;

namespace server {
namespace zone {
namespace objects {
namespace building {

class BuildingObject;

} // namespace building
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::building;

namespace server {
namespace zone {
namespace objects {
namespace installation {

class InstallationObject;

} // namespace installation
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::installation;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject;

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class AiAgent;

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace deed {

class Deed;

} // namespace deed
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::deed;

#include "server/zone/objects/building/components/DestructibleBuildingDataComponent.h"

#include "server/zone/objects/installation/components/TurretDataComponent.h"

#include "server/zone/objects/tangible/terminal/components/TurretControlTerminalDataComponent.h"

#include "templates/ChildObject.h"

#include "server/chat/StringIdChatParameter.h"

#include "templates/faction/Factions.h"

#include "system/util/Vector.h"

#include "system/util/HashTable.h"

#include "system/lang/ref/Reference.h"

#include "engine/core/ManagedService.h"

#include "engine/core/Task.h"

#include "engine/log/Logger.h"

#include "system/util/SortedVector.h"

#include "system/thread/Mutex.h"

namespace server {
namespace zone {
namespace managers {
namespace gcw {

class GCWManager : public ManagedService {
public:
	static const int NOTAFACTIONBASE = 0;

	static const int PLAYERFACTIONBASE = 1;

	static const int STATICFACTIONBASE = 2;

	GCWManager(Zone* zne);

	Zone* getZone();

	void initialize();

	void start();

	void loadLuaConfig();

	void stop();

	void performGCWTasks(bool initial);

	bool canPlaceMoreBases(CreatureObject* creature);

	int getBaseCount(CreatureObject* creature);

	bool hasTooManyBasesNearby(int x, int y);

	void registerGCWBase(BuildingObject* building, bool initializeBase);

	void unregisterGCWBase(BuildingObject* building);

	void addMinefield(BuildingObject* building, SceneObject* minefield);

	void addScanner(BuildingObject* building, SceneObject* scanner);

	void addTurret(BuildingObject* building, SceneObject* turret);

	void startVulnerability(BuildingObject* building);

	void endVulnerability(BuildingObject* building);

	void initializeNewVulnerability(BuildingObject* building);

	String getVulnerableStatus(BuildingObject* building, CreatureObject* creature);

	bool isBaseVulnerable(BuildingObject* building);

	bool isBandIdentified(BuildingObject* building);

	bool isUplinkJammed(BuildingObject* building);

	bool isTerminalDamaged(TangibleObject* securityTerminal);

	bool isSecurityTermSliced(BuildingObject* building);

	bool isDNASampled(BuildingObject* building);

	bool isPowerOverloaded(BuildingObject* building);

	bool isShutdownSequenceStarted(BuildingObject* building);

	bool isFacilityRebooting(BuildingObject* building);

	bool canUseTerminals(CreatureObject* creature, BuildingObject* building, SceneObject* terminal);

	bool areOpposingFactions(int faction1, int faction2);

	void awardSlicingXP(CreatureObject* creature, const String& xpType, int value);

	void sendJamUplinkMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* uplinkTerminal);

	void verifyUplinkBand(CreatureObject* creature, BuildingObject* building, int band, TangibleObject* uplinkTerminal);

	bool canStartSlice(CreatureObject* creature, TangibleObject* terminal);

	void completeSecuritySlice(CreatureObject* creature, TangibleObject* securityTerminal);

	void failSecuritySlice(TangibleObject* securityTerminal);

	void repairTerminal(CreatureObject* creature, TangibleObject* securityTerminal);

	void sendDNASampleMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* overrideTerminal);

	void processDNASample(CreatureObject* creature, TangibleObject* overrideTerminal, int indx);

	void sendPowerRegulatorControls(CreatureObject* creature, BuildingObject* building, TangibleObject* powerRegulator);

	void handlePowerRegulatorSwitch(CreatureObject* creature, TangibleObject* powerRegulator, int indx);

	void scheduleBaseDestruction(BuildingObject* building, CreatureObject* creature);

	void doBaseDestruction(StructureObject* structure);

	void doBaseDestruction(BuildingObject* building);

	void broadcastBuilding(BuildingObject* building, StringIdChatParameter& params);

	void startAbortSequenceDelay(BuildingObject* building, CreatureObject* creature, SceneObject* hqTerminal);

	void abortShutdownSequence(BuildingObject* building, CreatureObject* creature);

	void resetVulnerability(CreatureObject* creature, BuildingObject* building);

	bool hasResetTimerPast(BuildingObject* building);

	void sendBaseDefenseStatus(CreatureObject* creature, BuildingObject* building);

	void sendRemoveDefenseConfirmation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID);

	void removeDefense(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID);

	void notifyInstallationDestruction(InstallationObject* installation);

	void notifyTurretDestruction(BuildingObject* building, InstallationObject* turret);

	void notifyMinefieldDestruction(BuildingObject* building, InstallationObject* turret);

	void sendSelectDeedToDonate(BuildingObject* building, CreatureObject* creature);

	void performDefenseDonation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID);

	void sendTurretAttackListTo(CreatureObject* creature, SceneObject* turretControlTerminal);

	bool canUseTurret(TangibleObject* turret, SceneObject* terminal, CreatureObject* creature);

	float getGCWDiscount(CreatureObject* creature);

	void runCrackdownScan(AiAgent* scanner, CreatureObject* player);

	int isStrongholdCity(String& city);

	int getMaxBasesPerPlayer();

	bool isPlanetCapped();

	int getImperialBaseCount();

	int getRebelBaseCount();

	int getRebelScore() const;

	int getImperialScore() const;

	void setRebelScore(int val);

	void setImperialScore(int val);

	unsigned int getWinningFaction() const;

	int getWinningFactionDifficultyScaling() const;

	int getGCWXPBonus() const;

	int getPointValue(const String& templateString);

	void addPointValue(const String& templateString, int val);

	void addRacialPenalty(int race, float val);

	float getRacialPenalty(int race);

	bool isRacialPenaltyEnabled() const;

	bool shouldSpawnDefenses() const;

	int getInitialVulnerabilityDelay() const;

	int getTurretAutoFireTimeout() const;

	int getDestructionTimer() const;

	int getOvertCooldown() const;

	int getResetTimer() const;

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	GCWManager(DummyConstructorParameter* param);

	virtual ~GCWManager();

	friend class GCWManagerHelper;
};

} // namespace gcw
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::gcw;

namespace server {
namespace zone {
namespace managers {
namespace gcw {

class GCWManagerImplementation : public ManagedServiceImplementation, public Logger {
public:
	static const int NOTAFACTIONBASE = 0;

	static const int PLAYERFACTIONBASE = 1;

	static const int STATICFACTIONBASE = 2;

private:
	ManagedReference<Zone* > zone;

protected:
	SortedVector<ManagedReference<BuildingObject* > > gcwBaseList;

	VectorMap<unsigned long long, Reference<Task*> > gcwStartTasks;

	VectorMap<unsigned long long, Reference<Task*> > gcwEndTasks;

	Vector<String> dnaNucleotides;

	Vector<String> dnaPairs;

	VectorMap<unsigned long long, Reference<Task*> > gcwDestroyTasks;

	Mutex baseMutex;

	VectorMap<String, int> baseValue;

	Vector<int> difficultyScalingThresholds;

	HashTable<int, float> racialPenaltyMap;

private:
	int rebelBases;

	int rebelScore;

	int imperialBases;

	int imperialScore;

	int winningFaction;

	int winnerDifficultyScaling;

public:
	unsigned long long gcwCheckTimer;

	int vulnerabilityDuration;

	int vulnerabilityFrequency;

	int resetTimer;

	int sliceCooldown;

	int totalDNASamples;

	int powerSwitchCount;

	int dnaStrandLength;

	int destructionTimer;

	int maxBases;

	int overtCooldown;

	int reactivationTimer;

	int turretAutoFireTimeout;

	int maxBasesPerPlayer;

	int bonusXP;

	int winnerBonus;

	int loserBonus;

	bool spawnDefenses;

	int initialVulnerabilityDelay;

	bool racialPenaltyEnabled;

protected:
	Vector<String> imperialStrongholds;

	Vector<String> rebelStrongholds;

public:
	GCWManagerImplementation(Zone* zne);

	GCWManagerImplementation(DummyConstructorParameter* param);

	Zone* getZone();

	void initialize();

	void start();

	void loadLuaConfig();

	void stop();

	void performGCWTasks(bool initial);

private:
	void verifyTurrets(BuildingObject* building);

public:
	bool canPlaceMoreBases(CreatureObject* creature);

	int getBaseCount(CreatureObject* creature);

	bool hasTooManyBasesNearby(int x, int y);

	void registerGCWBase(BuildingObject* building, bool initializeBase);

	void unregisterGCWBase(BuildingObject* building);

private:
	void initializeBaseTimers(BuildingObject* building);

public:
	void addMinefield(BuildingObject* building, SceneObject* minefield);

	void addScanner(BuildingObject* building, SceneObject* scanner);

	void addTurret(BuildingObject* building, SceneObject* turret);

	void startVulnerability(BuildingObject* building);

	void endVulnerability(BuildingObject* building);

	void initializeNewVulnerability(BuildingObject* building);

private:
	void initializeNewVulnerability(DestructibleBuildingDataComponent* data);

	void scheduleVulnerabilityStart(BuildingObject* building);

	void scheduleVulnerabilityEnd(BuildingObject* building);

	void refreshExpiredVulnerability(BuildingObject* building);

	void checkVulnerabilityData(BuildingObject* building);

public:
	String getVulnerableStatus(BuildingObject* building, CreatureObject* creature);

	bool isBaseVulnerable(BuildingObject* building);

	bool isBandIdentified(BuildingObject* building);

	bool isUplinkJammed(BuildingObject* building);

	bool isTerminalDamaged(TangibleObject* securityTerminal);

	bool isSecurityTermSliced(BuildingObject* building);

	bool isDNASampled(BuildingObject* building);

	bool isPowerOverloaded(BuildingObject* building);

	bool isShutdownSequenceStarted(BuildingObject* building);

	bool isFacilityRebooting(BuildingObject* building);

private:
	DestructibleBuildingDataComponent* getDestructibleBuildingData(BuildingObject* building);

public:
	bool canUseTerminals(CreatureObject* creature, BuildingObject* building, SceneObject* terminal);

	bool areOpposingFactions(int faction1, int faction2);

	void awardSlicingXP(CreatureObject* creature, const String& xpType, int value);

	void sendJamUplinkMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* uplinkTerminal);

	void verifyUplinkBand(CreatureObject* creature, BuildingObject* building, int band, TangibleObject* uplinkTerminal);

private:
	void renewUplinkBand(BuildingObject* building);

public:
	bool canStartSlice(CreatureObject* creature, TangibleObject* terminal);

	void completeSecuritySlice(CreatureObject* creature, TangibleObject* securityTerminal);

	void failSecuritySlice(TangibleObject* securityTerminal);

	void repairTerminal(CreatureObject* creature, TangibleObject* securityTerminal);

	void sendDNASampleMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* overrideTerminal);

	void processDNASample(CreatureObject* creature, TangibleObject* overrideTerminal, int indx);

private:
	void constructDNAStrand(BuildingObject* building);

public:
	void sendPowerRegulatorControls(CreatureObject* creature, BuildingObject* building, TangibleObject* powerRegulator);

	void handlePowerRegulatorSwitch(CreatureObject* creature, TangibleObject* powerRegulator, int indx);

private:
	void randomizePowerRegulatorSwitches(BuildingObject* building);

	void createPowerRegulatorRules(BuildingObject* building);

	void flipPowerSwitch(BuildingObject* building, Vector<bool>& switchStates, int flipSwitch);

public:
	void scheduleBaseDestruction(BuildingObject* building, CreatureObject* creature);

	void doBaseDestruction(StructureObject* structure);

	void doBaseDestruction(BuildingObject* building);

	void broadcastBuilding(BuildingObject* building, StringIdChatParameter& params);

	void startAbortSequenceDelay(BuildingObject* building, CreatureObject* creature, SceneObject* hqTerminal);

	void abortShutdownSequence(BuildingObject* building, CreatureObject* creature);

	void resetVulnerability(CreatureObject* creature, BuildingObject* building);

	bool hasResetTimerPast(BuildingObject* building);

	void sendBaseDefenseStatus(CreatureObject* creature, BuildingObject* building);

	void sendRemoveDefenseConfirmation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID);

	void removeDefense(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID);

	void notifyInstallationDestruction(InstallationObject* installation);

	void notifyTurretDestruction(BuildingObject* building, InstallationObject* turret);

	void notifyMinefieldDestruction(BuildingObject* building, InstallationObject* turret);

	void sendSelectDeedToDonate(BuildingObject* building, CreatureObject* creature);

	void performDefenseDonation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID);

private:
	void performDonateMinefield(BuildingObject* building, CreatureObject* creature, Deed* deed);

	void performDonateTurret(BuildingObject* building, CreatureObject* creature, Deed* deed);

	unsigned long long addChildInstallationFromDeed(BuildingObject* building, ChildObject* child, CreatureObject* creature, Deed* deed);

public:
	void sendTurretAttackListTo(CreatureObject* creature, SceneObject* turretControlTerminal);

	bool canUseTurret(TangibleObject* turret, SceneObject* terminal, CreatureObject* creature);

private:
	TurretControlTerminalDataComponent* getTurretControlDataComponent(SceneObject* terminal);

	TurretDataComponent* getTurretDataComponent(SceneObject* turret);

	void generateTurretControlBoxTo(CreatureObject* creature, TangibleObject* turret, SceneObject* terminal);

public:
	float getGCWDiscount(CreatureObject* creature);

	void runCrackdownScan(AiAgent* scanner, CreatureObject* player);

	int isStrongholdCity(String& city);

protected:
	bool hasBase(BuildingObject* building);

	bool dropBase(BuildingObject* building);

	void addBase(BuildingObject* building);

	BuildingObject* getBase(int indx);

	bool hasStartTask(unsigned long long id);

	bool addStartTask(unsigned long long id, Reference<Task*> newTask);

	Reference<Task*> getStartTask(unsigned long long id);

	bool dropStartTask(unsigned long long id);

	bool hasEndTask(unsigned long long id);

	bool addEndTask(unsigned long long id, Reference<Task*> newTask);

	Reference<Task*> getEndTask(unsigned long long id);

	bool dropEndTask(unsigned long long id);

	bool hasDestroyTask(unsigned long long id);

	bool addDestroyTask(unsigned long long id, Reference<Task*> newTask);

	Reference<Task*> getDestroyTask(unsigned long long id);

	bool dropDestroyTask(unsigned long long id);

public:
	int getMaxBasesPerPlayer();

	bool isPlanetCapped();

	int getImperialBaseCount();

	int getRebelBaseCount();

	int getRebelScore() const;

	int getImperialScore() const;

	void setRebelScore(int val);

	void setImperialScore(int val);

private:
	void setRebelBaseCount(int val);

	void setImperialBaseCount(int val);

	void updateWinningFaction();

public:
	unsigned int getWinningFaction() const;

	int getWinningFactionDifficultyScaling() const;

	int getGCWXPBonus() const;

	int getPointValue(const String& templateString);

	void addPointValue(const String& templateString, int val);

	void addRacialPenalty(int race, float val);

	float getRacialPenalty(int race);

	bool isRacialPenaltyEnabled() const;

	bool shouldSpawnDefenses() const;

	int getInitialVulnerabilityDelay() const;

	int getTurretAutoFireTimeout() const;

	int getDestructionTimer() const;

	int getOvertCooldown() const;

	int getResetTimer() const;

	WeakReference<GCWManager*> _this;

	operator const GCWManager*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
protected:
	virtual ~GCWManagerImplementation();

	void finalize();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class GCWManager;
};

class GCWManagerAdapter : public ManagedServiceAdapter {
public:
	GCWManagerAdapter(GCWManager* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	Zone* getZone();

	void initialize();

	void start();

	void loadLuaConfig();

	void stop();

	void performGCWTasks(bool initial);

	bool canPlaceMoreBases(CreatureObject* creature);

	int getBaseCount(CreatureObject* creature);

	bool hasTooManyBasesNearby(int x, int y);

	void registerGCWBase(BuildingObject* building, bool initializeBase);

	void unregisterGCWBase(BuildingObject* building);

	void addMinefield(BuildingObject* building, SceneObject* minefield);

	void addScanner(BuildingObject* building, SceneObject* scanner);

	void addTurret(BuildingObject* building, SceneObject* turret);

	void startVulnerability(BuildingObject* building);

	void endVulnerability(BuildingObject* building);

	void initializeNewVulnerability(BuildingObject* building);

	String getVulnerableStatus(BuildingObject* building, CreatureObject* creature);

	bool isBaseVulnerable(BuildingObject* building);

	bool isBandIdentified(BuildingObject* building);

	bool isUplinkJammed(BuildingObject* building);

	bool isTerminalDamaged(TangibleObject* securityTerminal);

	bool isSecurityTermSliced(BuildingObject* building);

	bool isDNASampled(BuildingObject* building);

	bool isPowerOverloaded(BuildingObject* building);

	bool isShutdownSequenceStarted(BuildingObject* building);

	bool isFacilityRebooting(BuildingObject* building);

	bool canUseTerminals(CreatureObject* creature, BuildingObject* building, SceneObject* terminal);

	bool areOpposingFactions(int faction1, int faction2);

	void awardSlicingXP(CreatureObject* creature, const String& xpType, int value);

	void sendJamUplinkMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* uplinkTerminal);

	void verifyUplinkBand(CreatureObject* creature, BuildingObject* building, int band, TangibleObject* uplinkTerminal);

	bool canStartSlice(CreatureObject* creature, TangibleObject* terminal);

	void completeSecuritySlice(CreatureObject* creature, TangibleObject* securityTerminal);

	void failSecuritySlice(TangibleObject* securityTerminal);

	void repairTerminal(CreatureObject* creature, TangibleObject* securityTerminal);

	void sendDNASampleMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* overrideTerminal);

	void processDNASample(CreatureObject* creature, TangibleObject* overrideTerminal, int indx);

	void sendPowerRegulatorControls(CreatureObject* creature, BuildingObject* building, TangibleObject* powerRegulator);

	void handlePowerRegulatorSwitch(CreatureObject* creature, TangibleObject* powerRegulator, int indx);

	void scheduleBaseDestruction(BuildingObject* building, CreatureObject* creature);

	void doBaseDestruction(StructureObject* structure);

	void doBaseDestruction(BuildingObject* building);

	void startAbortSequenceDelay(BuildingObject* building, CreatureObject* creature, SceneObject* hqTerminal);

	void abortShutdownSequence(BuildingObject* building, CreatureObject* creature);

	void resetVulnerability(CreatureObject* creature, BuildingObject* building);

	bool hasResetTimerPast(BuildingObject* building);

	void sendBaseDefenseStatus(CreatureObject* creature, BuildingObject* building);

	void sendRemoveDefenseConfirmation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID);

	void removeDefense(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID);

	void notifyInstallationDestruction(InstallationObject* installation);

	void notifyTurretDestruction(BuildingObject* building, InstallationObject* turret);

	void notifyMinefieldDestruction(BuildingObject* building, InstallationObject* turret);

	void sendSelectDeedToDonate(BuildingObject* building, CreatureObject* creature);

	void performDefenseDonation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID);

	void sendTurretAttackListTo(CreatureObject* creature, SceneObject* turretControlTerminal);

	bool canUseTurret(TangibleObject* turret, SceneObject* terminal, CreatureObject* creature);

	float getGCWDiscount(CreatureObject* creature);

	void runCrackdownScan(AiAgent* scanner, CreatureObject* player);

	int isStrongholdCity(String& city);

	int getMaxBasesPerPlayer();

	bool isPlanetCapped();

	int getImperialBaseCount();

	int getRebelBaseCount();

	int getTurretAutoFireTimeout() const;

	int getDestructionTimer() const;

	int getOvertCooldown() const;

	int getResetTimer() const;

};

class GCWManagerHelper : public DistributedObjectClassHelper, public Singleton<GCWManagerHelper> {
	static GCWManagerHelper* staticInitializer;

public:
	GCWManagerHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<GCWManagerHelper>;
};

} // namespace gcw
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::gcw;

#endif /*GCWMANAGER_H_*/
