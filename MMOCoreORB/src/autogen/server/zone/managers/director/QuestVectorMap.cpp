/*
 *	autogen/server/zone/managers/director/QuestVectorMap.cpp generated by engine3 IDL compiler 0.60
 */

#include "QuestVectorMap.h"

/*
 *	QuestVectorMapStub
 */

enum {RPC_GETKEY__ = 21606873,RPC_SETKEY__STRING_,RPC_GETMAPROW__STRING_,RPC_ADDMAPROW__STRING_STRING_,RPC_DELETEMAPROW__STRING_,RPC_HASMAPROW__STRING_,RPC_GETMAPSIZE__,RPC_GETMAPKEYATINDEX__INT_};

QuestVectorMap::QuestVectorMap() : ManagedObject(DummyConstructorParameter::instance()) {
	QuestVectorMapImplementation* _implementation = new QuestVectorMapImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("QuestVectorMap");
}

QuestVectorMap::QuestVectorMap(DummyConstructorParameter* param) : ManagedObject(param) {
	_setClassName("QuestVectorMap");
}

QuestVectorMap::~QuestVectorMap() {
}



String QuestVectorMap::getKey() {
	QuestVectorMapImplementation* _implementation = static_cast<QuestVectorMapImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETKEY__);

		String _return_getKey;
		method.executeWithAsciiReturn(_return_getKey);
		return _return_getKey;
	} else {
		return _implementation->getKey();
	}
}

void QuestVectorMap::setKey(const String& k) {
	QuestVectorMapImplementation* _implementation = static_cast<QuestVectorMapImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETKEY__STRING_);
		method.addAsciiParameter(k);

		method.executeWithVoidReturn();
	} else {
		_implementation->setKey(k);
	}
}

String QuestVectorMap::getMapRow(const String& mapKey) {
	QuestVectorMapImplementation* _implementation = static_cast<QuestVectorMapImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAPROW__STRING_);
		method.addAsciiParameter(mapKey);

		String _return_getMapRow;
		method.executeWithAsciiReturn(_return_getMapRow);
		return _return_getMapRow;
	} else {
		return _implementation->getMapRow(mapKey);
	}
}

void QuestVectorMap::addMapRow(const String& mapKey, const String& mapValue) {
	QuestVectorMapImplementation* _implementation = static_cast<QuestVectorMapImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDMAPROW__STRING_STRING_);
		method.addAsciiParameter(mapKey);
		method.addAsciiParameter(mapValue);

		method.executeWithVoidReturn();
	} else {
		_implementation->addMapRow(mapKey, mapValue);
	}
}

void QuestVectorMap::deleteMapRow(const String& mapKey) {
	QuestVectorMapImplementation* _implementation = static_cast<QuestVectorMapImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DELETEMAPROW__STRING_);
		method.addAsciiParameter(mapKey);

		method.executeWithVoidReturn();
	} else {
		_implementation->deleteMapRow(mapKey);
	}
}

bool QuestVectorMap::hasMapRow(const String& mapKey) {
	QuestVectorMapImplementation* _implementation = static_cast<QuestVectorMapImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASMAPROW__STRING_);
		method.addAsciiParameter(mapKey);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasMapRow(mapKey);
	}
}

int QuestVectorMap::getMapSize() {
	QuestVectorMapImplementation* _implementation = static_cast<QuestVectorMapImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAPSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMapSize();
	}
}

String QuestVectorMap::getMapKeyAtIndex(int idx) {
	QuestVectorMapImplementation* _implementation = static_cast<QuestVectorMapImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAPKEYATINDEX__INT_);
		method.addSignedIntParameter(idx);

		String _return_getMapKeyAtIndex;
		method.executeWithAsciiReturn(_return_getMapKeyAtIndex);
		return _return_getMapKeyAtIndex;
	} else {
		return _implementation->getMapKeyAtIndex(idx);
	}
}

DistributedObjectServant* QuestVectorMap::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* QuestVectorMap::_getImplementationForRead() const {
	return _impl;
}

void QuestVectorMap::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	QuestVectorMapImplementation
 */

QuestVectorMapImplementation::QuestVectorMapImplementation(DummyConstructorParameter* param) : ManagedObjectImplementation(param) {
	_initializeImplementation();
}


QuestVectorMapImplementation::~QuestVectorMapImplementation() {
}


void QuestVectorMapImplementation::finalize() {
}

void QuestVectorMapImplementation::_initializeImplementation() {
	_setClassHelper(QuestVectorMapHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void QuestVectorMapImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<QuestVectorMap*>(stub);
	ManagedObjectImplementation::_setStub(stub);
}

DistributedObjectStub* QuestVectorMapImplementation::_getStub() {
	return _this.get();
}

QuestVectorMapImplementation::operator const QuestVectorMap*() {
	return _this.get();
}

void QuestVectorMapImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void QuestVectorMapImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void QuestVectorMapImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void QuestVectorMapImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void QuestVectorMapImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void QuestVectorMapImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void QuestVectorMapImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void QuestVectorMapImplementation::_serializationHelperMethod() {
	ManagedObjectImplementation::_serializationHelperMethod();

	_setClassName("QuestVectorMap");

}

void QuestVectorMapImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(QuestVectorMapImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool QuestVectorMapImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ManagedObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x684e939a: //QuestVectorMap.key
		TypeInfo<String >::parseFromBinaryStream(&key, stream);
		return true;

	case 0xb4c4a358: //QuestVectorMap.questMap
		TypeInfo<VectorMap<String, String> >::parseFromBinaryStream(&questMap, stream);
		return true;

	}

	return false;
}

void QuestVectorMapImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = QuestVectorMapImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int QuestVectorMapImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ManagedObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x684e939a; //QuestVectorMap.key
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&key, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb4c4a358; //QuestVectorMap.questMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, String> >::toBinaryStream(&questMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 2;
}

QuestVectorMapImplementation::QuestVectorMapImplementation() {
	_initializeImplementation();
	// server/zone/managers/director/QuestVectorMap.idl():  		key = "";
	key = "";
}

String QuestVectorMapImplementation::getKey() {
	// server/zone/managers/director/QuestVectorMap.idl():  		return key;
	return key;
}

void QuestVectorMapImplementation::setKey(const String& k) {
	// server/zone/managers/director/QuestVectorMap.idl():  		key = k;
	key = k;
}

String QuestVectorMapImplementation::getMapRow(const String& mapKey) {
	Locker _locker(_this.get());
	// server/zone/managers/director/QuestVectorMap.idl():  		return questMap.get(mapKey);
	return (&questMap)->get(mapKey);
}

void QuestVectorMapImplementation::addMapRow(const String& mapKey, const String& mapValue) {
	Locker _locker(_this.get());
	// server/zone/managers/director/QuestVectorMap.idl():  		questMap.put(mapKey, mapValue);
	(&questMap)->put(mapKey, mapValue);
}

void QuestVectorMapImplementation::deleteMapRow(const String& mapKey) {
	Locker _locker(_this.get());
	// server/zone/managers/director/QuestVectorMap.idl():  		questMap.drop(mapKey);
	(&questMap)->drop(mapKey);
}

bool QuestVectorMapImplementation::hasMapRow(const String& mapKey) {
	Locker _locker(_this.get());
	// server/zone/managers/director/QuestVectorMap.idl():  		return questMap.contains(mapKey);
	return (&questMap)->contains(mapKey);
}

int QuestVectorMapImplementation::getMapSize() {
	Locker _locker(_this.get());
	// server/zone/managers/director/QuestVectorMap.idl():  		return questMap.size();
	return (&questMap)->size();
}

/*
 *	QuestVectorMapAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


QuestVectorMapAdapter::QuestVectorMapAdapter(QuestVectorMap* obj) : ManagedObjectAdapter(obj) {
}

void QuestVectorMapAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_GETKEY__:
		{
			
			String _m_res = getKey();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETKEY__STRING_:
		{
			 String k; inv->getAsciiParameter(k);
			
			setKey(k);
			
		}
		break;
	case RPC_GETMAPROW__STRING_:
		{
			 String mapKey; inv->getAsciiParameter(mapKey);
			
			String _m_res = getMapRow(mapKey);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ADDMAPROW__STRING_STRING_:
		{
			 String mapKey; inv->getAsciiParameter(mapKey);
			 String mapValue; inv->getAsciiParameter(mapValue);
			
			addMapRow(mapKey, mapValue);
			
		}
		break;
	case RPC_DELETEMAPROW__STRING_:
		{
			 String mapKey; inv->getAsciiParameter(mapKey);
			
			deleteMapRow(mapKey);
			
		}
		break;
	case RPC_HASMAPROW__STRING_:
		{
			 String mapKey; inv->getAsciiParameter(mapKey);
			
			bool _m_res = hasMapRow(mapKey);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETMAPSIZE__:
		{
			
			int _m_res = getMapSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMAPKEYATINDEX__INT_:
		{
			int idx = inv->getSignedIntParameter();
			
			String _m_res = getMapKeyAtIndex(idx);
			resp->insertAscii(_m_res);
		}
		break;
	default:
		ManagedObjectAdapter::invokeMethod(methid, inv);
	}
}

String QuestVectorMapAdapter::getKey() {
	return (static_cast<QuestVectorMap*>(stub))->getKey();
}

void QuestVectorMapAdapter::setKey(const String& k) {
	(static_cast<QuestVectorMap*>(stub))->setKey(k);
}

String QuestVectorMapAdapter::getMapRow(const String& mapKey) {
	return (static_cast<QuestVectorMap*>(stub))->getMapRow(mapKey);
}

void QuestVectorMapAdapter::addMapRow(const String& mapKey, const String& mapValue) {
	(static_cast<QuestVectorMap*>(stub))->addMapRow(mapKey, mapValue);
}

void QuestVectorMapAdapter::deleteMapRow(const String& mapKey) {
	(static_cast<QuestVectorMap*>(stub))->deleteMapRow(mapKey);
}

bool QuestVectorMapAdapter::hasMapRow(const String& mapKey) {
	return (static_cast<QuestVectorMap*>(stub))->hasMapRow(mapKey);
}

int QuestVectorMapAdapter::getMapSize() {
	return (static_cast<QuestVectorMap*>(stub))->getMapSize();
}

String QuestVectorMapAdapter::getMapKeyAtIndex(int idx) {
	return (static_cast<QuestVectorMap*>(stub))->getMapKeyAtIndex(idx);
}

/*
 *	QuestVectorMapHelper
 */

QuestVectorMapHelper* QuestVectorMapHelper::staticInitializer = QuestVectorMapHelper::instance();

QuestVectorMapHelper::QuestVectorMapHelper() {
	className = "QuestVectorMap";

	Core::getObjectBroker()->registerClass(className, this);
}

void QuestVectorMapHelper::finalizeHelper() {
	QuestVectorMapHelper::finalize();
}

DistributedObject* QuestVectorMapHelper::instantiateObject() {
	return new QuestVectorMap(DummyConstructorParameter::instance());
}

DistributedObjectServant* QuestVectorMapHelper::instantiateServant() {
	return new QuestVectorMapImplementation();
}

DistributedObjectAdapter* QuestVectorMapHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new QuestVectorMapAdapter(static_cast<QuestVectorMap*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

const char LuaQuestVectorMap::className[] = "LuaQuestVectorMap";

Luna<LuaQuestVectorMap>::RegType LuaQuestVectorMap::Register[] = {
	{ "_setObject", &LuaQuestVectorMap::_setObject },
	{ "_getObject", &LuaQuestVectorMap::_getObject },
	{ "getKey", &LuaQuestVectorMap::getKey },
	{ "setKey", &LuaQuestVectorMap::setKey },
	{ "getMapRow", &LuaQuestVectorMap::getMapRow },
	{ "addMapRow", &LuaQuestVectorMap::addMapRow },
	{ "deleteMapRow", &LuaQuestVectorMap::deleteMapRow },
	{ "hasMapRow", &LuaQuestVectorMap::hasMapRow },
	{ "getMapSize", &LuaQuestVectorMap::getMapSize },
	{ "getMapKeyAtIndex", &LuaQuestVectorMap::getMapKeyAtIndex },
	{ 0, 0 }
};

LuaQuestVectorMap::LuaQuestVectorMap(lua_State *L) {
	realObject = static_cast<QuestVectorMap*>(lua_touserdata(L, 1));
}

LuaQuestVectorMap::~LuaQuestVectorMap() {
}

int LuaQuestVectorMap::_setObject(lua_State* L) {
	realObject = static_cast<QuestVectorMap*>(lua_touserdata(L, -1));

	return 0;
}

int LuaQuestVectorMap::_getObject(lua_State* L) {
	lua_pushlightuserdata(L, realObject.get());

	return 1;
}

int LuaQuestVectorMap::getKey(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		String result = realObject->getKey();

		lua_pushstring(L, result.toCharArray());
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'QuestVectorMap:getKey()'");
	}
	return 0;
}

int LuaQuestVectorMap::setKey(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String k = lua_tostring(L, -1);

			realObject->setKey(k);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'QuestVectorMap:setKey(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'QuestVectorMap:setKey(string)'");
	}
	return 0;
}

int LuaQuestVectorMap::getMapRow(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String mapKey = lua_tostring(L, -1);

			String result = realObject->getMapRow(mapKey);

			lua_pushstring(L, result.toCharArray());
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'QuestVectorMap:getMapRow(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'QuestVectorMap:getMapRow(string)'");
	}
	return 0;
}

int LuaQuestVectorMap::addMapRow(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (lua_isstring(L, -2)) {
			if (parameterCount == 2) {
				const String mapKey = lua_tostring(L, -2);
				const String mapValue = lua_tostring(L, -1);

				realObject->addMapRow(mapKey, mapValue);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'QuestVectorMap:addMapRow(string, string)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'QuestVectorMap:addMapRow(string, string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'QuestVectorMap:addMapRow(string, string)'");
	}
	return 0;
}

int LuaQuestVectorMap::deleteMapRow(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String mapKey = lua_tostring(L, -1);

			realObject->deleteMapRow(mapKey);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'QuestVectorMap:deleteMapRow(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'QuestVectorMap:deleteMapRow(string)'");
	}
	return 0;
}

int LuaQuestVectorMap::hasMapRow(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String mapKey = lua_tostring(L, -1);

			bool result = realObject->hasMapRow(mapKey);

			lua_pushboolean(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'QuestVectorMap:hasMapRow(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'QuestVectorMap:hasMapRow(string)'");
	}
	return 0;
}

int LuaQuestVectorMap::getMapSize(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getMapSize();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'QuestVectorMap:getMapSize()'");
	}
	return 0;
}

int LuaQuestVectorMap::getMapKeyAtIndex(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int idx = lua_tointeger(L, -1);

			String result = realObject->getMapKeyAtIndex(idx);

			lua_pushstring(L, result.toCharArray());
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'QuestVectorMap:getMapKeyAtIndex(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'QuestVectorMap:getMapKeyAtIndex(integer)'");
	}
	return 0;
}

