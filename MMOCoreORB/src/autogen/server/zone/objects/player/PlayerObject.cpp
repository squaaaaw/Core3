/*
 *	autogen/server/zone/objects/player/PlayerObject.cpp generated by engine3 IDL compiler 0.60
 */

#include "PlayerObject.h"

#include "server/zone/objects/building/BuildingObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/creature/ai/AiAgent.h"

#include "server/zone/objects/player/events/PlayerDisconnectEvent.h"

#include "server/zone/objects/player/events/PlayerRecoveryEvent.h"

#include "server/zone/objects/player/events/ForceRegenerationEvent.h"

#include "server/zone/objects/player/events/PvpTefRemovalTask.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/structure/StructureObject.h"

#include "server/zone/objects/waypoint/WaypointObject.h"

#include "server/zone/ZoneClientSession.h"

#include "server/login/account/Account.h"

/*
 *	PlayerObjectStub
 */

unsigned const long long PlayerObject::PVP_RESET_TIME = 259200000;

enum {RPC_FINALIZE__ = 594400956,RPC_SETCLIENTPATHWAYPOINT__SCENEOBJECT_,RPC_INITIALIZEACCOUNT__,RPC_NOTIFYLOADFROMDATABASE__,RPC_UNLOAD__,RPC_CALCULATEBHREWARD__,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SENDMESSAGE__BASEPACKET_,RPC_ADDOWNEDSTRUCTURE__STRUCTUREOBJECT_,RPC_REMOVEOWNEDSTRUCTURE__STRUCTUREOBJECT_,RPC_GETTOTALOWNEDSTRUCTURECOUNT__,RPC_ISOWNEDSTRUCTURE__STRUCTUREOBJECT_,RPC_GETOWNEDSTRUCTURE__INT_,RPC_GETLOTSREMAINING__,RPC_HASLOTSREMAINING__INT_,RPC_NOTIFYSCENEREADY__,RPC_CHECKPENDINGMESSAGES__,RPC_ADDEXPERIENCE__STRING_INT_BOOL_,RPC_REMOVEEXPERIENCE__STRING_BOOL_,RPC_HASCAPPEDEXPERIENCE__STRING_,RPC_ADDWAYPOINT__WAYPOINTOBJECT_BOOL_BOOL_,RPC_SETWAYPOINT__WAYPOINTOBJECT_BOOL_,RPC_REMOVEWAYPOINT__LONG_BOOL_BOOL_,RPC_UPDATEWAYPOINT__LONG_,RPC_REMOVEWAYPOINTBYSPECIALTYPE__INT_BOOL_,RPC_GETWAYPOINTBYSPECIALTYPE__INT_,RPC_GETSURVEYWAYPOINT__,RPC_HASWAYPOINT__LONG_,RPC_GETWAYPOINTAT__FLOAT_FLOAT_STRING_,RPC_INSERTWAYPOINTLISTTOMESSAGE__BASEMESSAGE_,RPC_GETWAYPOINTLISTSIZE__,RPC_GETWAYPOINT__INT_,RPC_SETLANGUAGEID__BYTE_BOOL_,RPC_ADDFRIEND__STRING_BOOL_,RPC_REMOVEFRIEND__STRING_BOOL_,RPC_REMOVEALLREVERSEFRIENDS__STRING_,RPC_ADDIGNORE__STRING_BOOL_,RPC_REMOVEIGNORE__STRING_BOOL_,RPC_SETTITLE__STRING_BOOL_,RPC_SETFOODFILLING__INT_BOOL_,RPC_SETDRINKFILLING__INT_BOOL_,RPC_INCREASEFACTIONSTANDING__STRING_FLOAT_,RPC_DECREASEFACTIONSTANDING__STRING_FLOAT_,RPC_SETFACTIONSTANDING__STRING_FLOAT_,RPC_GETFACTIONSTANDING__STRING_,RPC_SETSCREENPLAYDATA__STRING_STRING_STRING_,RPC_DELETESCREENPLAYDATA__STRING_STRING_,RPC_GETSCREENPLAYDATA__STRING_STRING_,RPC_CLEARSCREENPLAYDATA__STRING_,RPC_ACTIVATERECOVERY__,RPC_ACTIVATEFORCEPOWERREGEN__,RPC_DORECOVERY__INT_,RPC_DISCONNECT__BOOL_BOOL_,RPC_RELOAD__ZONECLIENTSESSION_,RPC_SETOFFLINE__,RPC_SETLINKDEAD__BOOL_,RPC_SETONLINE__,RPC_SETLOGGINGOUT__,RPC_SENDBADGESRESPONSETO__CREATUREOBJECT_,RPC_LOGOUT__BOOL_,RPC_SETJEDISTATE__INT_BOOL_,RPC_SETACTIVEQUESTSBIT__INT_BYTE_BOOL_,RPC_CLEARACTIVEQUESTSBIT__INT_BOOL_,RPC_CANACTIVATEQUEST__INT_,RPC_ACTIVATEQUEST__INT_,RPC_HASACTIVEQUESTBITSET__INT_,RPC_HASCOMPLETEDQUESTSBITSET__INT_,RPC_SETCOMPLETEDQUESTSBIT__INT_BYTE_BOOL_,RPC_CLEARCOMPLETEDQUESTSBIT__INT_BOOL_,RPC_COMPLETEQUEST__INT_,RPC_HASQUESTDATA__INT_,RPC_SETLASTNPCCONVSTR__STRING_,RPC_SETLASTNPCCONVMESSSTR__STRING_,RPC_GETLASTNPCCONVSTR__,RPC_GETLASTNPCCONVMESSSTR__,RPC_GETLASTNPCCONVOPTION__INT_,RPC_ADDLASTNPCCONVOPTIONS__STRING_,RPC_COUNTLASTNPCCONVOPTIONS__,RPC_CLEARLASTNPCCONVOPTIONS__,RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_,RPC_GETCONVERSATINGCREATURE__,RPC_SETTRAINERZONENAME__STRING_,RPC_GETTRAINERZONENAME__,RPC_ADDPERSISTENTMESSAGE__LONG_,RPC_DROPPERSISTENTMESSAGE__LONG_,RPC_UNLOADSPAWNEDCHILDREN__,RPC_ADDTOCONSENTLIST__STRING_,RPC_HASINCONSENTLIST__STRING_,RPC_REMOVEFROMCONSENTLIST__STRING_,RPC_GETCONSENTNAME__INT_,RPC_GETCONSENTLISTSIZE__,RPC_GETREACTIONFINES__,RPC_SETCOMMANDMESSAGESTRING__INT_STRING_,RPC_REMOVECOMMANDMESSAGESTRING__INT_,RPC_GETDECLAREDRESIDENCE__,RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_,RPC_SETCLONINGFACILITY__BUILDINGOBJECT_,RPC_GETCLONINGFACILITY__,RPC_NOTIFYONLINE__,RPC_DODIGEST__INT_,RPC_ISDIGESTING__,RPC_GETSAVEDTERRAINNAME__,RPC_SETSAVEDPARENTID__LONG_,RPC_SETSAVEDTERRAINNAME__STRING_,RPC_SETFORCEPOWER__INT_BOOL_,RPC_SETFORCEPOWERMAX__INT_BOOL_,RPC_DOFORCEREGEN__,RPC_GETFORCEPOWERREGEN__,RPC_GETSAVEDPARENTID__,RPC_GETNEWSUIBOXID__INT_,RPC_HASSUIBOX__INT_,RPC_GETSUIBOX__INT_,RPC_REMOVESUIBOX__INT_BOOL_,RPC_REMOVESUIBOXTYPE__INT_,RPC_HASSUIBOXWINDOWTYPE__INT_,RPC_CLOSESUIWINDOWTYPE__INT_,RPC_GETSUIBOXFROMWINDOWTYPE__INT_,RPC_ADDSUIBOX__SUIBOX_,RPC_ADDPERMISSIONGROUP__STRING_BOOL_,RPC_REMOVEPERMISSIONGROUP__STRING_BOOL_,RPC_UPDATEINRANGEBUILDINGPERMISSIONS__,RPC_HASPERMISSIONGROUP__STRING_,RPC_ADDINCAPACITATIONTIME__,RPC_GETINCAPACITATIONCOUNTER__,RPC_RESETINCAPACITATIONTIMES__,RPC_ADDTODUELLIST__CREATUREOBJECT_,RPC_REMOVEFROMDUELLIST__CREATUREOBJECT_,RPC_GETDUELLISTOBJECT__INT_,RPC_REQUESTEDDUELTO__CREATUREOBJECT_,RPC_ISDUELLISTEMPTY__,RPC_GETDUELLISTSIZE__,RPC_ADDTOACTIVEPETS__AIAGENT_,RPC_REMOVEFROMACTIVEPETS__AIAGENT_,RPC_GETACTIVEPET__INT_,RPC_HASACTIVEPET__AIAGENT_,RPC_GETACTIVEPETSSIZE__,RPC_GETBIOGRAPHY__,RPC_NOTIFYOFFLINE__,RPC_SETBADGE__INT_,RPC_AWARDBADGE__INT_,RPC_SETTELEPORTING__BOOL_,RPC_SETONLOADSCREEN__BOOL_,RPC_GETNUMBADGES__,RPC_GETBADGETYPECOUNT__INT_,RPC_HASFRIEND__STRING_,RPC_GETFRIENDLISTSIZE__,RPC_ISIGNORING__STRING_,RPC_ADDREVERSEFRIEND__STRING_,RPC_REMOVEREVERSEFRIEND__STRING_,RPC_SENDFRIENDLISTS__,RPC_HASCOMMANDMESSAGESTRING__INT_,RPC_GETCHARACTERBITMASK__,RPC_GETTITLE__,RPC_GETADMINLEVEL__,RPC_SETADMINLEVEL__INT_,RPC_GETPRIVILEDGEFLAG__,RPC_SETPRIVILEDGEFLAG__INT_,RPC_SETBIOGRAPHY__UNICODESTRING_,RPC_HASGODMODE__,RPC_ISPRIVILEGED__,RPC_ISSTAFF__,RPC_ISADMIN__,RPC_SETCHARACTERBITMASK__INT_,RPC_SETCHARACTERBIT__INT_BOOL_,RPC_CLEARCHARACTERBIT__INT_BOOL_,RPC_TOGGLECHARACTERBIT__INT_,RPC_ISLFG__,RPC_ISAFK__,RPC_ISANONYMOUS__,RPC_ISROLEPLAYER__,RPC_ISNEWBIEHELPER__,RPC_GETFORCEPOWER__,RPC_GETFORCEPOWERMAX__,RPC_GETSCHEMATIC__INT_,RPC_GETFOODFILLING__,RPC_GETFOODFILLINGMAX__,RPC_GETDRINKFILLING__,RPC_GETDRINKFILLINGMAX__,RPC_GETJEDISTATE__,RPC_GETLANGUAGEID__,RPC_ISTELEPORTING__,RPC_ISONLOADSCREEN__,RPC_ADDCHATROOM__INT_,RPC_REMOVECHATROOM__INT_,RPC_ADDOWNEDCHATROOM__INT_,RPC_REMOVEOWNEDCHATROOM__INT_,RPC_GETOWNEDCHATROOMCOUNT__,RPC_SETBANKLOCATION__STRING_,RPC_GETBANKLOCATION__,RPC_GETEXPERIENCE__STRING_,RPC_MAXIMIZEEXPERIENCE__,RPC_ACTIVATEMISSIONS__,RPC_GETCOMMANDMESSAGESTRING__INT_,RPC_HASBADGE__INT_,RPC_CLEARDISCONNECTEVENT__,RPC_ISONLINE__,RPC_ISOFFLINE__,RPC_ISLOADING__,RPC_ISLINKDEAD__,RPC_ISLOGGINGIN__,RPC_ISLOGGINGOUT__,RPC_SETSKILLPOINTS__INT_,RPC_ADDSKILLPOINTS__INT_,RPC_GETSKILLPOINTS__,RPC_UPDATELASTVALIDATEDPOSITION__,RPC_GETACCOUNTID__,RPC_GETSERVERMOVEMENTTIMEDELTA__,RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_,RPC_UPDATESERVERLASTMOVEMENTSTAMP__,RPC_SETACCOUNTID__INT_,RPC_GETCLIENTLASTMOVEMENTSTAMP__,RPC_ADDHOLOGRINDPROFESSION__BYTE_,RPC_SETMAXIMUMLOTS__BYTE_,RPC_GETMAXIMUMLOTS__,RPC_GETSTARTERPROFESSION__,RPC_SETSTARTERPROFESSION__STRING_,RPC_GETPERFORMANCEBUFFTARGET__,RPC_SETPERFORMANCEBUFFTARGET__LONG_,RPC_SETDEBUG__BOOL_,RPC_GETDEBUG__,RPC_GETVISIBILITY__,RPC_SETVISIBILITY__FLOAT_,RPC_UPDATELASTPVPCOMBATACTIONTIMESTAMP__BOOL_BOOL_,RPC_UPDATELASTBHPVPCOMBATACTIONTIMESTAMP__,RPC_UPDATELASTGCWPVPCOMBATACTIONTIMESTAMP__,RPC_HASPVPTEF__,RPC_HASBHTEF__,RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_BOOL_,RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_,RPC_ADDVENDOR__SCENEOBJECT_,RPC_REMOVEVENDOR__SCENEOBJECT_,RPC_GETVENDORCOUNT__,RPC_DESTROYOBJECTFROMDATABASE__BOOL_,RPC_DELETEALLPERSISTENTMESSAGES__,RPC_ISJEDI__,RPC_ISJEDILIGHT__,RPC_ISJEDIDARK__,RPC_ISMUTED__,RPC_SETMUTEDSTATE__BOOL_,RPC_GETMUTEDREASON__,RPC_SETMUTEDREASON__STRING_,RPC_GETINSTALLEDHOLOEMOTE__,RPC_SETINSTALLEDHOLOEMOTE__STRING_,RPC_REMOVEINSTALLEDHOLOEMOTE__,RPC_GETHOLOEMOTEUSECOUNT__,RPC_DECREASEHOLOEMOTEUSECOUNT__,RPC_ISMARRIED__,RPC_GETSPOUSENAME__,RPC_SETSPOUSENAME__STRING_,RPC_REMOVESPOUSE__,RPC_GETACCOUNT__,RPC_GETCHOSENVETERANREWARD__INT_,RPC_HASCHOSENVETERANREWARD__STRING_,RPC_CLEARVETERANREWARD__INT_,RPC_ADDEVENTPERK__SCENEOBJECT_,RPC_REMOVEEVENTPERK__SCENEOBJECT_,RPC_GETEVENTPERKCOUNT__,RPC_GETCHARACTERAGEINDAYS__,RPC_ADDTOREACTIONFINES__INT_,RPC_SETREACTIONFINES__INT_,RPC_SUBTRACTFROMREACTIONFINES__INT_,RPC_UPDATEREACTIONFINETIMESTAMP__,RPC_UPDATEREACTIONFINEMAILTIMESTAMP__,RPC_GETXPCAP__STRING_,RPC_GETSPENTJEDISKILLPOINTS__,RPC_HASSCHEMATIC__DRAFTSCHEMATIC_,RPC_HASEVENTPERK__STRING_,RPC_DOFIELDFACTIONCHANGE__INT_,RPC_ADDTOKILLERLIST__INT_,RPC_HASONKILLERLIST__INT_,RPC_GETPVPRATING__,RPC_SETPVPRATING__INT_};

PlayerObject::PlayerObject() : IntangibleObject(DummyConstructorParameter::instance()) {
	PlayerObjectImplementation* _implementation = new PlayerObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("PlayerObject");
}

PlayerObject::PlayerObject(DummyConstructorParameter* param) : IntangibleObject(param) {
	_setClassName("PlayerObject");
}

PlayerObject::~PlayerObject() {
}



void PlayerObject::setClientPathWaypoint(SceneObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLIENTPATHWAYPOINT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setClientPathWaypoint(obj);
	}
}

void PlayerObject::initializeAccount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEACCOUNT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeAccount();
	}
}

void PlayerObject::notifyLoadFromDatabase() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

void PlayerObject::unload() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNLOAD__);

		method.executeWithVoidReturn();
	} else {
		_implementation->unload();
	}
}

int PlayerObject::calculateBhReward() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEBHREWARD__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->calculateBhReward();
	}
}

void PlayerObject::loadTemplateData(SharedObjectTemplate* templateData) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void PlayerObject::initializeTransientMembers() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void PlayerObject::sendBaselinesTo(SceneObject* player) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

void PlayerObject::sendMessage(BasePacket* msg) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDMESSAGE__BASEPACKET_);
		method.addObjectParameter(msg);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendMessage(msg);
	}
}

void PlayerObject::addOwnedStructure(StructureObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDOWNEDSTRUCTURE__STRUCTUREOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->addOwnedStructure(obj);
	}
}

void PlayerObject::removeOwnedStructure(StructureObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEOWNEDSTRUCTURE__STRUCTUREOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeOwnedStructure(obj);
	}
}

int PlayerObject::getTotalOwnedStructureCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTOTALOWNEDSTRUCTURECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getTotalOwnedStructureCount();
	}
}

bool PlayerObject::isOwnedStructure(StructureObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISOWNEDSTRUCTURE__STRUCTUREOBJECT_);
		method.addObjectParameter(obj);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOwnedStructure(obj);
	}
}

unsigned long long PlayerObject::getOwnedStructure(int i) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOWNEDSTRUCTURE__INT_);
		method.addSignedIntParameter(i);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getOwnedStructure(i);
	}
}

int PlayerObject::getLotsRemaining() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLOTSREMAINING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getLotsRemaining();
	}
}

bool PlayerObject::hasLotsRemaining(int lots) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASLOTSREMAINING__INT_);
		method.addSignedIntParameter(lots);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasLotsRemaining(lots);
	}
}

void PlayerObject::notifySceneReady() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYSCENEREADY__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifySceneReady();
	}
}

void PlayerObject::checkPendingMessages() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKPENDINGMESSAGES__);

		method.executeWithVoidReturn();
	} else {
		_implementation->checkPendingMessages();
	}
}

int PlayerObject::addExperience(const String& xpType, int xp, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDEXPERIENCE__STRING_INT_BOOL_);
		method.addAsciiParameter(xpType);
		method.addSignedIntParameter(xp);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->addExperience(xpType, xp, notifyClient);
	}
}

void PlayerObject::removeExperience(const String& xpType, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEEXPERIENCE__STRING_BOOL_);
		method.addAsciiParameter(xpType);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeExperience(xpType, notifyClient);
	}
}

bool PlayerObject::hasCappedExperience(const String& xpType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCAPPEDEXPERIENCE__STRING_);
		method.addAsciiParameter(xpType);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasCappedExperience(xpType);
	}
}

void PlayerObject::addWaypoint(WaypointObject* waypoint, bool checkName, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWAYPOINT__WAYPOINTOBJECT_BOOL_BOOL_);
		method.addObjectParameter(waypoint);
		method.addBooleanParameter(checkName);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addWaypoint(waypoint, checkName, notifyClient);
	}
}

void PlayerObject::setWaypoint(WaypointObject* waypoint, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWAYPOINT__WAYPOINTOBJECT_BOOL_);
		method.addObjectParameter(waypoint);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setWaypoint(waypoint, notifyClient);
	}
}

WaypointObject* PlayerObject::addWaypoint(const String& planet, float positionX, float positionY, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->addWaypoint(planet, positionX, positionY, notifyClient);
	}
}

void PlayerObject::removeWaypoint(unsigned long long waypointID, bool notifyClient, bool destroy) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEWAYPOINT__LONG_BOOL_BOOL_);
		method.addUnsignedLongParameter(waypointID);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(destroy);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeWaypoint(waypointID, notifyClient, destroy);
	}
}

void PlayerObject::updateWaypoint(unsigned long long waypointID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEWAYPOINT__LONG_);
		method.addUnsignedLongParameter(waypointID);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateWaypoint(waypointID);
	}
}

void PlayerObject::removeWaypointBySpecialType(int specialTypeID, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEWAYPOINTBYSPECIALTYPE__INT_BOOL_);
		method.addSignedIntParameter(specialTypeID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeWaypointBySpecialType(specialTypeID, notifyClient);
	}
}

WaypointObject* PlayerObject::getWaypointBySpecialType(int specialTypeID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWAYPOINTBYSPECIALTYPE__INT_);
		method.addSignedIntParameter(specialTypeID);

		return static_cast<WaypointObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getWaypointBySpecialType(specialTypeID);
	}
}

WaypointObject* PlayerObject::getSurveyWaypoint() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSURVEYWAYPOINT__);

		return static_cast<WaypointObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSurveyWaypoint();
	}
}

bool PlayerObject::hasWaypoint(unsigned long long objectID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASWAYPOINT__LONG_);
		method.addUnsignedLongParameter(objectID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasWaypoint(objectID);
	}
}

WaypointObject* PlayerObject::getWaypointAt(float x, float y, String& planet) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWAYPOINTAT__FLOAT_FLOAT_STRING_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addAsciiParameter(planet);

		return static_cast<WaypointObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getWaypointAt(x, y, planet);
	}
}

void PlayerObject::insertWaypointListToMessage(BaseMessage* msg) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INSERTWAYPOINTLISTTOMESSAGE__BASEMESSAGE_);
		method.addObjectParameter(msg);

		method.executeWithVoidReturn();
	} else {
		_implementation->insertWaypointListToMessage(msg);
	}
}

int PlayerObject::getWaypointListSize() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWAYPOINTLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getWaypointListSize();
	}
}

WaypointObject* PlayerObject::getWaypoint(int index) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWAYPOINT__INT_);
		method.addSignedIntParameter(index);

		return static_cast<WaypointObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getWaypoint(index);
	}
}

void PlayerObject::addAbilities(Vector<Ability*>& abilities, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addAbilities(abilities, notifyClient);
	}
}

void PlayerObject::addAbility(Ability* ability, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addAbility(ability, notifyClient);
	}
}

void PlayerObject::removeAbilities(Vector<Ability*>& abilities, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeAbilities(abilities, notifyClient);
	}
}

void PlayerObject::removeAbility(Ability* ability, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeAbility(ability, notifyClient);
	}
}

bool PlayerObject::addSchematics(Vector<ManagedReference<DraftSchematic* > >& schematics, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->addSchematics(schematics, notifyClient);
	}
}

void PlayerObject::removeSchematics(Vector<ManagedReference<DraftSchematic* > >& schematics, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeSchematics(schematics, notifyClient);
	}
}

bool PlayerObject::addRewardedSchematic(DraftSchematic* schematic, short type, int quantity, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->addRewardedSchematic(schematic, type, quantity, notifyClient);
	}
}

void PlayerObject::removeRewardedSchematic(DraftSchematic* schematic, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeRewardedSchematic(schematic, notifyClient);
	}
}

void PlayerObject::decreaseSchematicUseCount(DraftSchematic* schematic) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->decreaseSchematicUseCount(schematic);
	}
}

void PlayerObject::setLanguageID(byte language, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLANGUAGEID__BYTE_BOOL_);
		method.addByteParameter(language);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLanguageID(language, notifyClient);
	}
}

void PlayerObject::addFriend(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDFRIEND__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addFriend(name, notifyClient);
	}
}

void PlayerObject::removeFriend(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFRIEND__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeFriend(name, notifyClient);
	}
}

void PlayerObject::removeAllReverseFriends(const String& oldName) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEALLREVERSEFRIENDS__STRING_);
		method.addAsciiParameter(oldName);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeAllReverseFriends(oldName);
	}
}

void PlayerObject::addIgnore(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDIGNORE__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addIgnore(name, notifyClient);
	}
}

void PlayerObject::removeIgnore(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEIGNORE__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeIgnore(name, notifyClient);
	}
}

void PlayerObject::setTitle(const String& characterTitle, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTITLE__STRING_BOOL_);
		method.addAsciiParameter(characterTitle);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setTitle(characterTitle, notifyClient);
	}
}

void PlayerObject::setFoodFilling(int newValue, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFOODFILLING__INT_BOOL_);
		method.addSignedIntParameter(newValue);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFoodFilling(newValue, notifyClient);
	}
}

void PlayerObject::setDrinkFilling(int newValue, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDRINKFILLING__INT_BOOL_);
		method.addSignedIntParameter(newValue);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDrinkFilling(newValue, notifyClient);
	}
}

void PlayerObject::increaseFactionStanding(const String& factionName, float amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREASEFACTIONSTANDING__STRING_FLOAT_);
		method.addAsciiParameter(factionName);
		method.addFloatParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->increaseFactionStanding(factionName, amount);
	}
}

void PlayerObject::decreaseFactionStanding(const String& factionName, float amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASEFACTIONSTANDING__STRING_FLOAT_);
		method.addAsciiParameter(factionName);
		method.addFloatParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->decreaseFactionStanding(factionName, amount);
	}
}

void PlayerObject::setFactionStanding(const String& factionName, float amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFACTIONSTANDING__STRING_FLOAT_);
		method.addAsciiParameter(factionName);
		method.addFloatParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFactionStanding(factionName, amount);
	}
}

float PlayerObject::getFactionStanding(const String& factionName) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONSTANDING__STRING_);
		method.addAsciiParameter(factionName);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getFactionStanding(factionName);
	}
}

void PlayerObject::setScreenPlayData(const String& screenPlay, const String& variable, const String& data) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSCREENPLAYDATA__STRING_STRING_STRING_);
		method.addAsciiParameter(screenPlay);
		method.addAsciiParameter(variable);
		method.addAsciiParameter(data);

		method.executeWithVoidReturn();
	} else {
		_implementation->setScreenPlayData(screenPlay, variable, data);
	}
}

void PlayerObject::deleteScreenPlayData(const String& screenPlay, const String& variable) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DELETESCREENPLAYDATA__STRING_STRING_);
		method.addAsciiParameter(screenPlay);
		method.addAsciiParameter(variable);

		method.executeWithVoidReturn();
	} else {
		_implementation->deleteScreenPlayData(screenPlay, variable);
	}
}

String PlayerObject::getScreenPlayData(const String& screenPlay, const String& variable) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSCREENPLAYDATA__STRING_STRING_);
		method.addAsciiParameter(screenPlay);
		method.addAsciiParameter(variable);

		String _return_getScreenPlayData;
		method.executeWithAsciiReturn(_return_getScreenPlayData);
		return _return_getScreenPlayData;
	} else {
		return _implementation->getScreenPlayData(screenPlay, variable);
	}
}

void PlayerObject::clearScreenPlayData(const String& screenPlay) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSCREENPLAYDATA__STRING_);
		method.addAsciiParameter(screenPlay);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearScreenPlayData(screenPlay);
	}
}

void PlayerObject::activateRecovery() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATERECOVERY__);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateRecovery();
	}
}

void PlayerObject::activateForcePowerRegen() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEFORCEPOWERREGEN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateForcePowerRegen();
	}
}

void PlayerObject::doRecovery(int latency) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DORECOVERY__INT_);
		method.addSignedIntParameter(latency);

		method.executeWithVoidReturn();
	} else {
		_implementation->doRecovery(latency);
	}
}

void PlayerObject::disconnect(bool closeClient, bool doLock) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DISCONNECT__BOOL_BOOL_);
		method.addBooleanParameter(closeClient);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else {
		_implementation->disconnect(closeClient, doLock);
	}
}

void PlayerObject::reload(ZoneClientSession* client) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RELOAD__ZONECLIENTSESSION_);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else {
		_implementation->reload(client);
	}
}

void PlayerObject::setOffline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOFFLINE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOffline();
	}
}

void PlayerObject::setLinkDead(bool isSafeLogout) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLINKDEAD__BOOL_);
		method.addBooleanParameter(isSafeLogout);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLinkDead(isSafeLogout);
	}
}

void PlayerObject::setOnline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETONLINE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOnline();
	}
}

void PlayerObject::setLoggingOut() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLOGGINGOUT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLoggingOut();
	}
}

void PlayerObject::sendBadgesResponseTo(CreatureObject* player) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBADGESRESPONSETO__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBadgesResponseTo(player);
	}
}

void PlayerObject::logout(bool doLock) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOGOUT__BOOL_);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else {
		_implementation->logout(doLock);
	}
}

void PlayerObject::setJediState(int state, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETJEDISTATE__INT_BOOL_);
		method.addSignedIntParameter(state);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setJediState(state, notifyClient);
	}
}

void PlayerObject::setActiveQuestsBit(int bitIndex, byte value, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACTIVEQUESTSBIT__INT_BYTE_BOOL_);
		method.addSignedIntParameter(bitIndex);
		method.addByteParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setActiveQuestsBit(bitIndex, value, notifyClient);
	}
}

void PlayerObject::clearActiveQuestsBit(int bitIndex, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARACTIVEQUESTSBIT__INT_BOOL_);
		method.addSignedIntParameter(bitIndex);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearActiveQuestsBit(bitIndex, notifyClient);
	}
}

bool PlayerObject::canActivateQuest(int questID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANACTIVATEQUEST__INT_);
		method.addSignedIntParameter(questID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canActivateQuest(questID);
	}
}

void PlayerObject::activateQuest(int questID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEQUEST__INT_);
		method.addSignedIntParameter(questID);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateQuest(questID);
	}
}

bool PlayerObject::hasActiveQuestBitSet(int bitIndex) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASACTIVEQUESTBITSET__INT_);
		method.addSignedIntParameter(bitIndex);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasActiveQuestBitSet(bitIndex);
	}
}

bool PlayerObject::hasCompletedQuestsBitSet(int bitIndex) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCOMPLETEDQUESTSBITSET__INT_);
		method.addSignedIntParameter(bitIndex);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasCompletedQuestsBitSet(bitIndex);
	}
}

void PlayerObject::setCompletedQuestsBit(int bitIndex, byte value, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMPLETEDQUESTSBIT__INT_BYTE_BOOL_);
		method.addSignedIntParameter(bitIndex);
		method.addByteParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCompletedQuestsBit(bitIndex, value, notifyClient);
	}
}

void PlayerObject::clearCompletedQuestsBit(int bitIndex, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCOMPLETEDQUESTSBIT__INT_BOOL_);
		method.addSignedIntParameter(bitIndex);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearCompletedQuestsBit(bitIndex, notifyClient);
	}
}

void PlayerObject::completeQuest(int questID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPLETEQUEST__INT_);
		method.addSignedIntParameter(questID);

		method.executeWithVoidReturn();
	} else {
		_implementation->completeQuest(questID);
	}
}

PlayerQuestData PlayerObject::getQuestData(unsigned int questHashCode) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getQuestData(questHashCode);
	}
}

bool PlayerObject::hasQuestData(unsigned int questHashCode) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASQUESTDATA__INT_);
		method.addUnsignedIntParameter(questHashCode);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasQuestData(questHashCode);
	}
}

void PlayerObject::setPlayerQuestData(unsigned int questHashCode, PlayerQuestData& data, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setPlayerQuestData(questHashCode, data, notifyClient);
	}
}

FactionStandingList* PlayerObject::getFactionStandingList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getFactionStandingList();
	}
}

void PlayerObject::setLastNpcConvStr(const String& conv) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTNPCCONVSTR__STRING_);
		method.addAsciiParameter(conv);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLastNpcConvStr(conv);
	}
}

void PlayerObject::setLastNpcConvMessStr(const String& mess) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTNPCCONVMESSSTR__STRING_);
		method.addAsciiParameter(mess);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLastNpcConvMessStr(mess);
	}
}

String PlayerObject::getLastNpcConvStr() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNPCCONVSTR__);

		String _return_getLastNpcConvStr;
		method.executeWithAsciiReturn(_return_getLastNpcConvStr);
		return _return_getLastNpcConvStr;
	} else {
		return _implementation->getLastNpcConvStr();
	}
}

String PlayerObject::getLastNpcConvMessStr() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNPCCONVMESSSTR__);

		String _return_getLastNpcConvMessStr;
		method.executeWithAsciiReturn(_return_getLastNpcConvMessStr);
		return _return_getLastNpcConvMessStr;
	} else {
		return _implementation->getLastNpcConvMessStr();
	}
}

String PlayerObject::getLastNpcConvOption(int idx) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNPCCONVOPTION__INT_);
		method.addSignedIntParameter(idx);

		String _return_getLastNpcConvOption;
		method.executeWithAsciiReturn(_return_getLastNpcConvOption);
		return _return_getLastNpcConvOption;
	} else {
		return _implementation->getLastNpcConvOption(idx);
	}
}

void PlayerObject::addLastNpcConvOptions(const String& option) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDLASTNPCCONVOPTIONS__STRING_);
		method.addAsciiParameter(option);

		method.executeWithVoidReturn();
	} else {
		_implementation->addLastNpcConvOptions(option);
	}
}

int PlayerObject::countLastNpcConvOptions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COUNTLASTNPCCONVOPTIONS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->countLastNpcConvOptions();
	}
}

void PlayerObject::clearLastNpcConvOptions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARLASTNPCCONVOPTIONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearLastNpcConvOptions();
	}
}

void PlayerObject::setConversatingCreature(CreatureObject* creature) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->setConversatingCreature(creature);
	}
}

unsigned long long PlayerObject::getConversatingCreature() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONVERSATINGCREATURE__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getConversatingCreature();
	}
}

void PlayerObject::setTrainerCoordinates(const Vector3& trainer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setTrainerCoordinates(trainer);
	}
}

Vector3 PlayerObject::getTrainerCoordinates() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getTrainerCoordinates();
	}
}

void PlayerObject::setTrainerZoneName(String& zoneName) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTRAINERZONENAME__STRING_);
		method.addAsciiParameter(zoneName);

		method.executeWithVoidReturn();
	} else {
		_implementation->setTrainerZoneName(zoneName);
	}
}

String PlayerObject::getTrainerZoneName() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTRAINERZONENAME__);

		String _return_getTrainerZoneName;
		method.executeWithAsciiReturn(_return_getTrainerZoneName);
		return _return_getTrainerZoneName;
	} else {
		return _implementation->getTrainerZoneName();
	}
}

SortedVector<unsigned long long>* PlayerObject::getPersistentMessages() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPersistentMessages();
	}
}

void PlayerObject::addPersistentMessage(unsigned long long id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPERSISTENTMESSAGE__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else {
		_implementation->addPersistentMessage(id);
	}
}

void PlayerObject::dropPersistentMessage(unsigned long long id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DROPPERSISTENTMESSAGE__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else {
		_implementation->dropPersistentMessage(id);
	}
}

void PlayerObject::unloadSpawnedChildren() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNLOADSPAWNEDCHILDREN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->unloadSpawnedChildren();
	}
}

void PlayerObject::addToConsentList(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOCONSENTLIST__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToConsentList(name);
	}
}

bool PlayerObject::hasInConsentList(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASINCONSENTLIST__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasInConsentList(name);
	}
}

void PlayerObject::removeFromConsentList(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMCONSENTLIST__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeFromConsentList(name);
	}
}

String PlayerObject::getConsentName(int i) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONSENTNAME__INT_);
		method.addSignedIntParameter(i);

		String _return_getConsentName;
		method.executeWithAsciiReturn(_return_getConsentName);
		return _return_getConsentName;
	} else {
		return _implementation->getConsentName(i);
	}
}

int PlayerObject::getConsentListSize() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONSENTLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getConsentListSize();
	}
}

int PlayerObject::getReactionFines() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREACTIONFINES__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getReactionFines();
	}
}

String PlayerObject::getFactionRank() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getFactionRank();
	}
}

void PlayerObject::setFactionRank(const String& rank) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setFactionRank(rank);
	}
}

void PlayerObject::setCommandMessageString(unsigned int actionCRC, String& message) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMMANDMESSAGESTRING__INT_STRING_);
		method.addUnsignedIntParameter(actionCRC);
		method.addAsciiParameter(message);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCommandMessageString(actionCRC, message);
	}
}

void PlayerObject::removeCommandMessageString(unsigned int actionCRC) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVECOMMANDMESSAGESTRING__INT_);
		method.addUnsignedIntParameter(actionCRC);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeCommandMessageString(actionCRC);
	}
}

unsigned long long PlayerObject::getDeclaredResidence() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDECLAREDRESIDENCE__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getDeclaredResidence();
	}
}

void PlayerObject::setDeclaredResidence(BuildingObject* residence) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_);
		method.addObjectParameter(residence);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDeclaredResidence(residence);
	}
}

void PlayerObject::setCloningFacility(BuildingObject* cloningfac) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLONINGFACILITY__BUILDINGOBJECT_);
		method.addObjectParameter(cloningfac);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCloningFacility(cloningfac);
	}
}

unsigned long long PlayerObject::getCloningFacility() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLONINGFACILITY__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getCloningFacility();
	}
}

void PlayerObject::notifyOnline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYONLINE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyOnline();
	}
}

void PlayerObject::doDigest(int fillingReduction) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DODIGEST__INT_);
		method.addSignedIntParameter(fillingReduction);

		method.executeWithVoidReturn();
	} else {
		_implementation->doDigest(fillingReduction);
	}
}

bool PlayerObject::isDigesting() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDIGESTING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDigesting();
	}
}

String PlayerObject::getSavedTerrainName() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSAVEDTERRAINNAME__);

		String _return_getSavedTerrainName;
		method.executeWithAsciiReturn(_return_getSavedTerrainName);
		return _return_getSavedTerrainName;
	} else {
		return _implementation->getSavedTerrainName();
	}
}

void PlayerObject::setSavedParentID(unsigned long long id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSAVEDPARENTID__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSavedParentID(id);
	}
}

void PlayerObject::setSavedTerrainName(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSAVEDTERRAINNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSavedTerrainName(name);
	}
}

void PlayerObject::setForcePower(int fp, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFORCEPOWER__INT_BOOL_);
		method.addSignedIntParameter(fp);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setForcePower(fp, notifyClient);
	}
}

void PlayerObject::setForcePowerMax(int newValue, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFORCEPOWERMAX__INT_BOOL_);
		method.addSignedIntParameter(newValue);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setForcePowerMax(newValue, notifyClient);
	}
}

void PlayerObject::doForceRegen() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOFORCEREGEN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->doForceRegen();
	}
}

int PlayerObject::getForcePowerRegen() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCEPOWERREGEN__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getForcePowerRegen();
	}
}

unsigned long long PlayerObject::getSavedParentID() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSAVEDPARENTID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getSavedParentID();
	}
}

unsigned int PlayerObject::getNewSuiBoxID(unsigned int type) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNEWSUIBOXID__INT_);
		method.addUnsignedIntParameter(type);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getNewSuiBoxID(type);
	}
}

bool PlayerObject::hasSuiBox(unsigned int boxID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSUIBOX__INT_);
		method.addUnsignedIntParameter(boxID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSuiBox(boxID);
	}
}

Reference<SuiBox* > PlayerObject::getSuiBox(unsigned int boxID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSUIBOX__INT_);
		method.addUnsignedIntParameter(boxID);

		return static_cast<SuiBox*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSuiBox(boxID);
	}
}

void PlayerObject::removeSuiBox(unsigned int boxID, bool closeWindowToClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESUIBOX__INT_BOOL_);
		method.addUnsignedIntParameter(boxID);
		method.addBooleanParameter(closeWindowToClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSuiBox(boxID, closeWindowToClient);
	}
}

void PlayerObject::removeSuiBoxType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESUIBOXTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSuiBoxType(windowType);
	}
}

bool PlayerObject::hasSuiBoxWindowType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSUIBOXWINDOWTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSuiBoxWindowType(windowType);
	}
}

void PlayerObject::closeSuiWindowType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLOSESUIWINDOWTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		method.executeWithVoidReturn();
	} else {
		_implementation->closeSuiWindowType(windowType);
	}
}

Reference<SuiBox* > PlayerObject::getSuiBoxFromWindowType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSUIBOXFROMWINDOWTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		return static_cast<SuiBox*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSuiBoxFromWindowType(windowType);
	}
}

void PlayerObject::addSuiBox(SuiBox* sui) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSUIBOX__SUIBOX_);
		method.addObjectParameter(sui);

		method.executeWithVoidReturn();
	} else {
		_implementation->addSuiBox(sui);
	}
}

void PlayerObject::addPermissionGroup(const String& group, bool updatePermissions) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPERMISSIONGROUP__STRING_BOOL_);
		method.addAsciiParameter(group);
		method.addBooleanParameter(updatePermissions);

		method.executeWithVoidReturn();
	} else {
		_implementation->addPermissionGroup(group, updatePermissions);
	}
}

void PlayerObject::removePermissionGroup(const String& group, bool updatePermissions) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEPERMISSIONGROUP__STRING_BOOL_);
		method.addAsciiParameter(group);
		method.addBooleanParameter(updatePermissions);

		method.executeWithVoidReturn();
	} else {
		_implementation->removePermissionGroup(group, updatePermissions);
	}
}

void PlayerObject::updateInRangeBuildingPermissions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEINRANGEBUILDINGPERMISSIONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateInRangeBuildingPermissions();
	}
}

bool PlayerObject::hasPermissionGroup(const String& group) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASPERMISSIONGROUP__STRING_);
		method.addAsciiParameter(group);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasPermissionGroup(group);
	}
}

SortedVector<String>* PlayerObject::getPermissionGroups() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPermissionGroups();
	}
}

void PlayerObject::addIncapacitationTime() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDINCAPACITATIONTIME__);

		method.executeWithVoidReturn();
	} else {
		_implementation->addIncapacitationTime();
	}
}

byte PlayerObject::getIncapacitationCounter() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINCAPACITATIONCOUNTER__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getIncapacitationCounter();
	}
}

void PlayerObject::resetIncapacitationTimes() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETINCAPACITATIONTIMES__);

		method.executeWithVoidReturn();
	} else {
		_implementation->resetIncapacitationTimes();
	}
}

void PlayerObject::addToDuelList(CreatureObject* targetPlayer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTODUELLIST__CREATUREOBJECT_);
		method.addObjectParameter(targetPlayer);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToDuelList(targetPlayer);
	}
}

void PlayerObject::removeFromDuelList(CreatureObject* targetPlayer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMDUELLIST__CREATUREOBJECT_);
		method.addObjectParameter(targetPlayer);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeFromDuelList(targetPlayer);
	}
}

Reference<CreatureObject* > PlayerObject::getDuelListObject(int index) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDUELLISTOBJECT__INT_);
		method.addSignedIntParameter(index);

		return static_cast<CreatureObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getDuelListObject(index);
	}
}

bool PlayerObject::requestedDuelTo(CreatureObject* targetPlayer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REQUESTEDDUELTO__CREATUREOBJECT_);
		method.addObjectParameter(targetPlayer);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->requestedDuelTo(targetPlayer);
	}
}

bool PlayerObject::isDuelListEmpty() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDUELLISTEMPTY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDuelListEmpty();
	}
}

int PlayerObject::getDuelListSize() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDUELLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDuelListSize();
	}
}

void PlayerObject::addToActivePets(AiAgent* pet) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOACTIVEPETS__AIAGENT_);
		method.addObjectParameter(pet);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToActivePets(pet);
	}
}

void PlayerObject::removeFromActivePets(AiAgent* pet) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMACTIVEPETS__AIAGENT_);
		method.addObjectParameter(pet);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeFromActivePets(pet);
	}
}

AiAgent* PlayerObject::getActivePet(int index) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIVEPET__INT_);
		method.addSignedIntParameter(index);

		return static_cast<AiAgent*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getActivePet(index);
	}
}

bool PlayerObject::hasActivePet(AiAgent* pet) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASACTIVEPET__AIAGENT_);
		method.addObjectParameter(pet);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasActivePet(pet);
	}
}

int PlayerObject::getActivePetsSize() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIVEPETSSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getActivePetsSize();
	}
}

UnicodeString PlayerObject::getBiography() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBIOGRAPHY__);

		UnicodeString _return_getBiography;
		method.executeWithUnicodeReturn(_return_getBiography);
		return _return_getBiography;
	} else {
		return _implementation->getBiography();
	}
}

void PlayerObject::notifyOffline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOFFLINE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyOffline();
	}
}

void PlayerObject::setBadge(unsigned int badge) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBadge(badge);
	}
}

void PlayerObject::awardBadge(unsigned int badge) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_AWARDBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else {
		_implementation->awardBadge(badge);
	}
}

void PlayerObject::setTeleporting(bool val) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTELEPORTING__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setTeleporting(val);
	}
}

void PlayerObject::setOnLoadScreen(bool val) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETONLOADSCREEN__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOnLoadScreen(val);
	}
}

int PlayerObject::getNumBadges() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNUMBADGES__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getNumBadges();
	}
}

int PlayerObject::getBadgeTypeCount(unsigned int type) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBADGETYPECOUNT__INT_);
		method.addUnsignedIntParameter(type);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBadgeTypeCount(type);
	}
}

bool PlayerObject::hasFriend(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASFRIEND__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasFriend(name);
	}
}

int PlayerObject::getFriendListSize() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFRIENDLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFriendListSize();
	}
}

bool PlayerObject::isIgnoring(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISIGNORING__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isIgnoring(name);
	}
}

void PlayerObject::addReverseFriend(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDREVERSEFRIEND__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->addReverseFriend(name);
	}
}

void PlayerObject::removeReverseFriend(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEREVERSEFRIEND__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeReverseFriend(name);
	}
}

void PlayerObject::sendFriendLists() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDFRIENDLISTS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendFriendLists();
	}
}

bool PlayerObject::hasAbility(const String& ability) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->hasAbility(ability);
	}
}

bool PlayerObject::hasCommandMessageString(unsigned int actionCRC) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCOMMANDMESSAGESTRING__INT_);
		method.addUnsignedIntParameter(actionCRC);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasCommandMessageString(actionCRC);
	}
}

unsigned int PlayerObject::getCharacterBitmask() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHARACTERBITMASK__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getCharacterBitmask();
	}
}

String PlayerObject::getTitle() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTITLE__);

		String _return_getTitle;
		method.executeWithAsciiReturn(_return_getTitle);
		return _return_getTitle;
	} else {
		return _implementation->getTitle();
	}
}

unsigned int PlayerObject::getAdminLevel() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETADMINLEVEL__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getAdminLevel();
	}
}

void PlayerObject::setAdminLevel(unsigned int adminlvl) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETADMINLEVEL__INT_);
		method.addUnsignedIntParameter(adminlvl);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAdminLevel(adminlvl);
	}
}

int PlayerObject::getPriviledgeFlag() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPRIVILEDGEFLAG__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPriviledgeFlag();
	}
}

void PlayerObject::setPriviledgeFlag(int flag) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPRIVILEDGEFLAG__INT_);
		method.addSignedIntParameter(flag);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPriviledgeFlag(flag);
	}
}

void PlayerObject::setBiography(const UnicodeString& bio) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBIOGRAPHY__UNICODESTRING_);
		method.addUnicodeParameter(bio);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBiography(bio);
	}
}

bool PlayerObject::hasGodMode() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASGODMODE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasGodMode();
	}
}

bool PlayerObject::isPrivileged() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPRIVILEGED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPrivileged();
	}
}

bool PlayerObject::isStaff() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTAFF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isStaff();
	}
}

bool PlayerObject::isAdmin() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISADMIN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAdmin();
	}
}

void PlayerObject::setCharacterBitmask(unsigned int bitmask) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCHARACTERBITMASK__INT_);
		method.addUnsignedIntParameter(bitmask);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCharacterBitmask(bitmask);
	}
}

bool PlayerObject::setCharacterBit(unsigned int bit, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCHARACTERBIT__INT_BOOL_);
		method.addUnsignedIntParameter(bit);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->setCharacterBit(bit, notifyClient);
	}
}

bool PlayerObject::clearCharacterBit(unsigned int bit, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCHARACTERBIT__INT_BOOL_);
		method.addUnsignedIntParameter(bit);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->clearCharacterBit(bit, notifyClient);
	}
}

void PlayerObject::toggleCharacterBit(unsigned int bit) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_TOGGLECHARACTERBIT__INT_);
		method.addUnsignedIntParameter(bit);

		method.executeWithVoidReturn();
	} else {
		_implementation->toggleCharacterBit(bit);
	}
}

bool PlayerObject::isLFG() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLFG__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLFG();
	}
}

bool PlayerObject::isAFK() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAFK__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAFK();
	}
}

bool PlayerObject::isAnonymous() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISANONYMOUS__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAnonymous();
	}
}

bool PlayerObject::isRoleplayer() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISROLEPLAYER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRoleplayer();
	}
}

bool PlayerObject::isNewbieHelper() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNEWBIEHELPER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNewbieHelper();
	}
}

VectorMap<String, int>* PlayerObject::getXpTypeCapList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getXpTypeCapList();
	}
}

DeltaVectorMap<String, int>* PlayerObject::getExperienceList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getExperienceList();
	}
}

DeltaVectorMap<uint32, PlayerQuestData >* PlayerObject::getPlayerQuestsData() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPlayerQuestsData();
	}
}

DeltaBitArray* PlayerObject::getActiveQuests() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getActiveQuests();
	}
}

DeltaBitArray* PlayerObject::getCompletedQuests() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCompletedQuests();
	}
}

int PlayerObject::getForcePower() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCEPOWER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getForcePower();
	}
}

int PlayerObject::getForcePowerMax() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCEPOWERMAX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getForcePowerMax();
	}
}

AbilityList* PlayerObject::getAbilityList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAbilityList();
	}
}

FrsData* PlayerObject::getFrsData() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getFrsData();
	}
}

SchematicList* PlayerObject::getSchematics() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSchematics();
	}
}

DraftSchematic* PlayerObject::getSchematic(int i) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSCHEMATIC__INT_);
		method.addSignedIntParameter(i);

		return static_cast<DraftSchematic*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSchematic(i);
	}
}

Vector<ManagedReference<DraftSchematic* > > PlayerObject::filterSchematicList(CreatureObject* player, Vector<unsigned int>* enabledTabs, int complexityLevel) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->filterSchematicList(player, enabledTabs, complexityLevel);
	}
}

int PlayerObject::getFoodFilling() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFOODFILLING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFoodFilling();
	}
}

int PlayerObject::getFoodFillingMax() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFOODFILLINGMAX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFoodFillingMax();
	}
}

int PlayerObject::getDrinkFilling() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDRINKFILLING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDrinkFilling();
	}
}

int PlayerObject::getDrinkFillingMax() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDRINKFILLINGMAX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDrinkFillingMax();
	}
}

int PlayerObject::getJediState() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETJEDISTATE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getJediState();
	}
}

byte PlayerObject::getLanguageID() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLANGUAGEID__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getLanguageID();
	}
}

DeltaVector<String>* PlayerObject::getFriendList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getFriendList();
	}
}

bool PlayerObject::isTeleporting() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTELEPORTING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTeleporting();
	}
}

bool PlayerObject::isOnLoadScreen() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONLOADSCREEN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOnLoadScreen();
	}
}

void PlayerObject::addChatRoom(unsigned int roomID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCHATROOM__INT_);
		method.addUnsignedIntParameter(roomID);

		method.executeWithVoidReturn();
	} else {
		_implementation->addChatRoom(roomID);
	}
}

void PlayerObject::removeChatRoom(unsigned int roomID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVECHATROOM__INT_);
		method.addUnsignedIntParameter(roomID);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeChatRoom(roomID);
	}
}

void PlayerObject::addOwnedChatRoom(unsigned int roomID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDOWNEDCHATROOM__INT_);
		method.addUnsignedIntParameter(roomID);

		method.executeWithVoidReturn();
	} else {
		_implementation->addOwnedChatRoom(roomID);
	}
}

void PlayerObject::removeOwnedChatRoom(unsigned int roomID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEOWNEDCHATROOM__INT_);
		method.addUnsignedIntParameter(roomID);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeOwnedChatRoom(roomID);
	}
}

int PlayerObject::getOwnedChatRoomCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOWNEDCHATROOMCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getOwnedChatRoomCount();
	}
}

void PlayerObject::setBankLocation(const String& location) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBANKLOCATION__STRING_);
		method.addAsciiParameter(location);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBankLocation(location);
	}
}

String PlayerObject::getBankLocation() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBANKLOCATION__);

		String _return_getBankLocation;
		method.executeWithAsciiReturn(_return_getBankLocation);
		return _return_getBankLocation;
	} else {
		return _implementation->getBankLocation();
	}
}

DeltaVector<String>* PlayerObject::getIgnoreList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getIgnoreList();
	}
}

int PlayerObject::getExperience(const String& xp) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETEXPERIENCE__STRING_);
		method.addAsciiParameter(xp);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getExperience(xp);
	}
}

void PlayerObject::maximizeExperience() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_MAXIMIZEEXPERIENCE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->maximizeExperience();
	}
}

void PlayerObject::activateMissions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEMISSIONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateMissions();
	}
}

String PlayerObject::getCommandMessageString(unsigned int actionCRC) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOMMANDMESSAGESTRING__INT_);
		method.addUnsignedIntParameter(actionCRC);

		String _return_getCommandMessageString;
		method.executeWithAsciiReturn(_return_getCommandMessageString);
		return _return_getCommandMessageString;
	} else {
		return _implementation->getCommandMessageString(actionCRC);
	}
}

bool PlayerObject::hasBadge(unsigned int badge) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasBadge(badge);
	}
}

void PlayerObject::clearDisconnectEvent() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARDISCONNECTEVENT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearDisconnectEvent();
	}
}

bool PlayerObject::isOnline() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONLINE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOnline();
	}
}

bool PlayerObject::isOffline() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISOFFLINE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOffline();
	}
}

bool PlayerObject::isLoading() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOADING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLoading();
	}
}

bool PlayerObject::isLinkDead() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLINKDEAD__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLinkDead();
	}
}

bool PlayerObject::isLoggingIn() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOGGINGIN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLoggingIn();
	}
}

bool PlayerObject::isLoggingOut() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOGGINGOUT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLoggingOut();
	}
}

Time* PlayerObject::getLastLogout() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastLogout();
	}
}

int PlayerObject::getDaysSinceLastLogout() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getDaysSinceLastLogout();
	}
}

void PlayerObject::setSkillPoints(int points) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSKILLPOINTS__INT_);
		method.addSignedIntParameter(points);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSkillPoints(points);
	}
}

void PlayerObject::addSkillPoints(int points) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLPOINTS__INT_);
		method.addSignedIntParameter(points);

		method.executeWithVoidReturn();
	} else {
		_implementation->addSkillPoints(points);
	}
}

int PlayerObject::getSkillPoints() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLPOINTS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSkillPoints();
	}
}

ValidatedPosition* PlayerObject::getLastValidatedPosition() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastValidatedPosition();
	}
}

void PlayerObject::updateLastValidatedPosition() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTVALIDATEDPOSITION__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastValidatedPosition();
	}
}

unsigned int PlayerObject::getAccountID() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCOUNTID__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getAccountID();
	}
}

GalaxyAccountInfo* PlayerObject::getGalaxyAccountInfo() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getGalaxyAccountInfo();
	}
}

unsigned long long PlayerObject::getServerMovementTimeDelta() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSERVERMOVEMENTTIMEDELTA__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getServerMovementTimeDelta();
	}
}

Time* PlayerObject::getServerMovementTimeStamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getServerMovementTimeStamp();
	}
}

void PlayerObject::setClientLastMovementStamp(unsigned int stamp) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_);
		method.addUnsignedIntParameter(stamp);

		method.executeWithVoidReturn();
	} else {
		_implementation->setClientLastMovementStamp(stamp);
	}
}

void PlayerObject::updateServerLastMovementStamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATESERVERLASTMOVEMENTSTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateServerLastMovementStamp();
	}
}

void PlayerObject::setAccountID(unsigned int id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCOUNTID__INT_);
		method.addUnsignedIntParameter(id);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAccountID(id);
	}
}

unsigned int PlayerObject::getClientLastMovementStamp() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLIENTLASTMOVEMENTSTAMP__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getClientLastMovementStamp();
	}
}

void PlayerObject::addHologrindProfession(byte prof) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDHOLOGRINDPROFESSION__BYTE_);
		method.addByteParameter(prof);

		method.executeWithVoidReturn();
	} else {
		_implementation->addHologrindProfession(prof);
	}
}

Vector<byte>* PlayerObject::getHologrindProfessions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getHologrindProfessions();
	}
}

void PlayerObject::setMaximumLots(byte lots) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXIMUMLOTS__BYTE_);
		method.addByteParameter(lots);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMaximumLots(lots);
	}
}

byte PlayerObject::getMaximumLots() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXIMUMLOTS__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getMaximumLots();
	}
}

String PlayerObject::getStarterProfession() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTARTERPROFESSION__);

		String _return_getStarterProfession;
		method.executeWithAsciiReturn(_return_getStarterProfession);
		return _return_getStarterProfession;
	} else {
		return _implementation->getStarterProfession();
	}
}

void PlayerObject::setStarterProfession(String& profession) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTARTERPROFESSION__STRING_);
		method.addAsciiParameter(profession);

		method.executeWithVoidReturn();
	} else {
		_implementation->setStarterProfession(profession);
	}
}

unsigned long long PlayerObject::getPerformanceBuffTarget() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCEBUFFTARGET__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getPerformanceBuffTarget();
	}
}

void PlayerObject::setPerformanceBuffTarget(unsigned long long target) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMANCEBUFFTARGET__LONG_);
		method.addUnsignedLongParameter(target);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPerformanceBuffTarget(target);
	}
}

void PlayerObject::setDebug(bool value) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDEBUG__BOOL_);
		method.addBooleanParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDebug(value);
	}
}

bool PlayerObject::getDebug() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDEBUG__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getDebug();
	}
}

float PlayerObject::getVisibility() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVISIBILITY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getVisibility();
	}
}

void PlayerObject::setVisibility(float value) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETVISIBILITY__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setVisibility(value);
	}
}

Time PlayerObject::getLastVisibilityUpdateTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastVisibilityUpdateTimestamp();
	}
}

Time PlayerObject::getLastBhPvpCombatActionTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastBhPvpCombatActionTimestamp();
	}
}

Time PlayerObject::getLastGcwPvpCombatActionTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastGcwPvpCombatActionTimestamp();
	}
}

void PlayerObject::updateLastPvpCombatActionTimestamp(bool updateGcwAction, bool updateBhAction) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTPVPCOMBATACTIONTIMESTAMP__BOOL_BOOL_);
		method.addBooleanParameter(updateGcwAction);
		method.addBooleanParameter(updateBhAction);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastPvpCombatActionTimestamp(updateGcwAction, updateBhAction);
	}
}

void PlayerObject::updateLastBhPvpCombatActionTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTBHPVPCOMBATACTIONTIMESTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastBhPvpCombatActionTimestamp();
	}
}

void PlayerObject::updateLastGcwPvpCombatActionTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTGCWPVPCOMBATACTIONTIMESTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastGcwPvpCombatActionTimestamp();
	}
}

bool PlayerObject::hasPvpTef() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASPVPTEF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasPvpTef();
	}
}

bool PlayerObject::hasBhTef() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASBHTEF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasBhTef();
	}
}

void PlayerObject::schedulePvpTefRemovalTask(bool removeGcwTefNow, bool removeBhTefNow) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_BOOL_);
		method.addBooleanParameter(removeGcwTefNow);
		method.addBooleanParameter(removeBhTefNow);

		method.executeWithVoidReturn();
	} else {
		_implementation->schedulePvpTefRemovalTask(removeGcwTefNow, removeBhTefNow);
	}
}

void PlayerObject::schedulePvpTefRemovalTask(bool removeNow) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_);
		method.addBooleanParameter(removeNow);

		method.executeWithVoidReturn();
	} else {
		_implementation->schedulePvpTefRemovalTask(removeNow);
	}
}

void PlayerObject::addVendor(SceneObject* vendor) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDVENDOR__SCENEOBJECT_);
		method.addObjectParameter(vendor);

		method.executeWithVoidReturn();
	} else {
		_implementation->addVendor(vendor);
	}
}

void PlayerObject::removeVendor(SceneObject* vendor) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEVENDOR__SCENEOBJECT_);
		method.addObjectParameter(vendor);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeVendor(vendor);
	}
}

int PlayerObject::getVendorCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVENDORCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getVendorCount();
	}
}

SortedVector<unsigned long long>* PlayerObject::getOwnedVendors() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getOwnedVendors();
	}
}

void PlayerObject::destroyObjectFromDatabase(bool destroyContainedObjects) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMDATABASE__BOOL_);
		method.addBooleanParameter(destroyContainedObjects);

		method.executeWithVoidReturn();
	} else {
		_implementation->destroyObjectFromDatabase(destroyContainedObjects);
	}
}

void PlayerObject::deleteAllPersistentMessages() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DELETEALLPERSISTENTMESSAGES__);

		method.executeWithVoidReturn();
	} else {
		_implementation->deleteAllPersistentMessages();
	}
}

bool PlayerObject::isJedi() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDI__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJedi();
	}
}

bool PlayerObject::isJediLight() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDILIGHT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJediLight();
	}
}

bool PlayerObject::isJediDark() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDIDARK__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJediDark();
	}
}

bool PlayerObject::isMuted() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMUTED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMuted();
	}
}

void PlayerObject::setMutedState(bool mute) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMUTEDSTATE__BOOL_);
		method.addBooleanParameter(mute);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMutedState(mute);
	}
}

String PlayerObject::getMutedReason() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMUTEDREASON__);

		String _return_getMutedReason;
		method.executeWithAsciiReturn(_return_getMutedReason);
		return _return_getMutedReason;
	} else {
		return _implementation->getMutedReason();
	}
}

void PlayerObject::setMutedReason(String& reason) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMUTEDREASON__STRING_);
		method.addAsciiParameter(reason);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMutedReason(reason);
	}
}

String PlayerObject::getInstalledHoloEmote() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINSTALLEDHOLOEMOTE__);

		String _return_getInstalledHoloEmote;
		method.executeWithAsciiReturn(_return_getInstalledHoloEmote);
		return _return_getInstalledHoloEmote;
	} else {
		return _implementation->getInstalledHoloEmote();
	}
}

void PlayerObject::setInstalledHoloEmote(String& holoEmote) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINSTALLEDHOLOEMOTE__STRING_);
		method.addAsciiParameter(holoEmote);

		method.executeWithVoidReturn();
	} else {
		_implementation->setInstalledHoloEmote(holoEmote);
	}
}

void PlayerObject::removeInstalledHoloEmote() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEINSTALLEDHOLOEMOTE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeInstalledHoloEmote();
	}
}

int PlayerObject::getHoloEmoteUseCount() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHOLOEMOTEUSECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHoloEmoteUseCount();
	}
}

void PlayerObject::decreaseHoloEmoteUseCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASEHOLOEMOTEUSECOUNT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->decreaseHoloEmoteUseCount();
	}
}

bool PlayerObject::isMarried() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMARRIED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMarried();
	}
}

String PlayerObject::getSpouseName() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPOUSENAME__);

		String _return_getSpouseName;
		method.executeWithAsciiReturn(_return_getSpouseName);
		return _return_getSpouseName;
	} else {
		return _implementation->getSpouseName();
	}
}

void PlayerObject::setSpouseName(String& firstName) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPOUSENAME__STRING_);
		method.addAsciiParameter(firstName);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSpouseName(firstName);
	}
}

void PlayerObject::removeSpouse() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESPOUSE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSpouse();
	}
}

Account* PlayerObject::getAccount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCOUNT__);

		return static_cast<Account*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getAccount();
	}
}

String PlayerObject::getChosenVeteranReward(unsigned int milestone) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHOSENVETERANREWARD__INT_);
		method.addUnsignedIntParameter(milestone);

		String _return_getChosenVeteranReward;
		method.executeWithAsciiReturn(_return_getChosenVeteranReward);
		return _return_getChosenVeteranReward;
	} else {
		return _implementation->getChosenVeteranReward(milestone);
	}
}

bool PlayerObject::hasChosenVeteranReward(const String& rewardTemplate) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCHOSENVETERANREWARD__STRING_);
		method.addAsciiParameter(rewardTemplate);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasChosenVeteranReward(rewardTemplate);
	}
}

void PlayerObject::clearVeteranReward(unsigned int milestone) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARVETERANREWARD__INT_);
		method.addUnsignedIntParameter(milestone);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearVeteranReward(milestone);
	}
}

void PlayerObject::addEventPerk(SceneObject* deed) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDEVENTPERK__SCENEOBJECT_);
		method.addObjectParameter(deed);

		method.executeWithVoidReturn();
	} else {
		_implementation->addEventPerk(deed);
	}
}

void PlayerObject::removeEventPerk(SceneObject* deed) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEEVENTPERK__SCENEOBJECT_);
		method.addObjectParameter(deed);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeEventPerk(deed);
	}
}

int PlayerObject::getEventPerkCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETEVENTPERKCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getEventPerkCount();
	}
}

int PlayerObject::getCharacterAgeInDays() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHARACTERAGEINDAYS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCharacterAgeInDays();
	}
}

void PlayerObject::addToReactionFines(int fine) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOREACTIONFINES__INT_);
		method.addSignedIntParameter(fine);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToReactionFines(fine);
	}
}

void PlayerObject::setReactionFines(int amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETREACTIONFINES__INT_);
		method.addSignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->setReactionFines(amount);
	}
}

void PlayerObject::subtractFromReactionFines(int amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SUBTRACTFROMREACTIONFINES__INT_);
		method.addSignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->subtractFromReactionFines(amount);
	}
}

void PlayerObject::updateReactionFineTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEREACTIONFINETIMESTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateReactionFineTimestamp();
	}
}

void PlayerObject::updateReactionFineMailTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEREACTIONFINEMAILTIMESTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateReactionFineMailTimestamp();
	}
}

Time* PlayerObject::getReactionFineTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getReactionFineTimestamp();
	}
}

Time* PlayerObject::getReactionFineMailTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getReactionFineMailTimestamp();
	}
}

int PlayerObject::getXpCap(const String& type) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETXPCAP__STRING_);
		method.addAsciiParameter(type);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getXpCap(type);
	}
}

int PlayerObject::getSpentJediSkillPoints() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPENTJEDISKILLPOINTS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSpentJediSkillPoints();
	}
}

bool PlayerObject::hasSchematic(DraftSchematic* schematic) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSCHEMATIC__DRAFTSCHEMATIC_);
		method.addObjectParameter(schematic);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSchematic(schematic);
	}
}

bool PlayerObject::hasEventPerk(const String& templatePath) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASEVENTPERK__STRING_);
		method.addAsciiParameter(templatePath);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasEventPerk(templatePath);
	}
}

void PlayerObject::doFieldFactionChange(int newStatus) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOFIELDFACTIONCHANGE__INT_);
		method.addSignedIntParameter(newStatus);

		method.executeWithVoidReturn();
	} else {
		_implementation->doFieldFactionChange(newStatus);
	}
}

void PlayerObject::addToKillerList(unsigned int playerID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOKILLERLIST__INT_);
		method.addUnsignedIntParameter(playerID);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToKillerList(playerID);
	}
}

bool PlayerObject::hasOnKillerList(unsigned int playerID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASONKILLERLIST__INT_);
		method.addUnsignedIntParameter(playerID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasOnKillerList(playerID);
	}
}

int PlayerObject::getPvpRating() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPVPRATING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPvpRating();
	}
}

void PlayerObject::setPvpRating(int rating) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPVPRATING__INT_);
		method.addSignedIntParameter(rating);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPvpRating(rating);
	}
}

DistributedObjectServant* PlayerObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* PlayerObject::_getImplementationForRead() const {
	return _impl;
}

void PlayerObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	PlayerObjectImplementation
 */

unsigned const long long PlayerObjectImplementation::PVP_RESET_TIME = 259200000;

PlayerObjectImplementation::PlayerObjectImplementation(DummyConstructorParameter* param) : IntangibleObjectImplementation(param) {
	_initializeImplementation();
}


PlayerObjectImplementation::~PlayerObjectImplementation() {
	PlayerObjectImplementation::finalize();
}


void PlayerObjectImplementation::_initializeImplementation() {
	_setClassHelper(PlayerObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void PlayerObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<PlayerObject*>(stub);
	IntangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* PlayerObjectImplementation::_getStub() {
	return _this.get();
}

PlayerObjectImplementation::operator const PlayerObject*() {
	return _this.get();
}

void PlayerObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void PlayerObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void PlayerObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void PlayerObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void PlayerObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void PlayerObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void PlayerObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void PlayerObjectImplementation::_serializationHelperMethod() {
	IntangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("PlayerObject");

}

void PlayerObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PlayerObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool PlayerObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (IntangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x38125d4f: //PlayerObject.characterBitmask
		TypeInfo<unsigned int >::parseFromBinaryStream(&characterBitmask, stream);
		return true;

	case 0x3f59dd69: //PlayerObject.title
		TypeInfo<String >::parseFromBinaryStream(&title, stream);
		return true;

	case 0x80839c38: //PlayerObject.savedTerrainName
		TypeInfo<String >::parseFromBinaryStream(&savedTerrainName, stream);
		return true;

	case 0x185d8184: //PlayerObject.savedParentID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&savedParentID, stream);
		return true;

	case 0xbf409c6b: //PlayerObject.badges
		TypeInfo<Badges >::parseFromBinaryStream(&badges, stream);
		return true;

	case 0x6f0f168c: //PlayerObject.forcePower
		TypeInfo<int >::parseFromBinaryStream(&forcePower, stream);
		return true;

	case 0x626f8b12: //PlayerObject.forcePowerMax
		TypeInfo<int >::parseFromBinaryStream(&forcePowerMax, stream);
		return true;

	case 0xd9b9f82b: //PlayerObject.foodFilling
		TypeInfo<int >::parseFromBinaryStream(&foodFilling, stream);
		return true;

	case 0xa5fa3768: //PlayerObject.foodFillingMax
		TypeInfo<int >::parseFromBinaryStream(&foodFillingMax, stream);
		return true;

	case 0xe620a523: //PlayerObject.drinkFilling
		TypeInfo<int >::parseFromBinaryStream(&drinkFilling, stream);
		return true;

	case 0x37da084: //PlayerObject.drinkFillingMax
		TypeInfo<int >::parseFromBinaryStream(&drinkFillingMax, stream);
		return true;

	case 0xe59e7515: //PlayerObject.reactionFines
		TypeInfo<int >::parseFromBinaryStream(&reactionFines, stream);
		return true;

	case 0x911499de: //PlayerObject.reactionFineTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&reactionFineTimestamp, stream);
		return true;

	case 0x89dba2ac: //PlayerObject.reactionFineMailTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&reactionFineMailTimestamp, stream);
		return true;

	case 0x68888ebc: //PlayerObject.starterProfession
		TypeInfo<String >::parseFromBinaryStream(&starterProfession, stream);
		return true;

	case 0xf7e4755e: //PlayerObject.bankLocation
		TypeInfo<String >::parseFromBinaryStream(&bankLocation, stream);
		return true;

	case 0x7a19894f: //PlayerObject.teleporting
		TypeInfo<bool >::parseFromBinaryStream(&teleporting, stream);
		return true;

	case 0xcf0cd987: //PlayerObject.onLoadScreen
		TypeInfo<bool >::parseFromBinaryStream(&onLoadScreen, stream);
		return true;

	case 0x9af4d57b: //PlayerObject.muted
		TypeInfo<bool >::parseFromBinaryStream(&muted, stream);
		return true;

	case 0x2ba211bc: //PlayerObject.mutedReason
		TypeInfo<String >::parseFromBinaryStream(&mutedReason, stream);
		return true;

	case 0x9151f1d3: //PlayerObject.ownedStructures
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&ownedStructures, stream);
		return true;

	case 0x3f521607: //PlayerObject.ownedVendors
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&ownedVendors, stream);
		return true;

	case 0x9c2c0c3f: //PlayerObject.maximumLots
		TypeInfo<byte >::parseFromBinaryStream(&maximumLots, stream);
		return true;

	case 0x39b2b254: //PlayerObject.jediState
		TypeInfo<int >::parseFromBinaryStream(&jediState, stream);
		return true;

	case 0x4d1afa57: //PlayerObject.adminLevel
		TypeInfo<unsigned int >::parseFromBinaryStream(&adminLevel, stream);
		return true;

	case 0xdfba5208: //PlayerObject.priviledgeFlag
		TypeInfo<int >::parseFromBinaryStream(&priviledgeFlag, stream);
		return true;

	case 0x45728d15: //PlayerObject.languageID
		TypeInfo<byte >::parseFromBinaryStream(&languageID, stream);
		return true;

	case 0x3737ff5f: //PlayerObject.xpTypeCapList
		TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&xpTypeCapList, stream);
		return true;

	case 0x890785df: //PlayerObject.commandMessageStrings
		TypeInfo<VectorMap<unsigned int, String> >::parseFromBinaryStream(&commandMessageStrings, stream);
		return true;

	case 0x33656264: //PlayerObject.experienceList
		TypeInfo<DeltaVectorMap<String, int> >::parseFromBinaryStream(&experienceList, stream);
		return true;

	case 0xbcd9bd05: //PlayerObject.frsData
		TypeInfo<FrsData >::parseFromBinaryStream(&frsData, stream);
		return true;

	case 0xbd209913: //PlayerObject.waypointList
		TypeInfo<WaypointList >::parseFromBinaryStream(&waypointList, stream);
		return true;

	case 0x56e55cb2: //PlayerObject.abilityList
		TypeInfo<AbilityList >::parseFromBinaryStream(&abilityList, stream);
		return true;

	case 0xdab57393: //PlayerObject.friendList
		TypeInfo<FriendList >::parseFromBinaryStream(&friendList, stream);
		return true;

	case 0x4d1f2cfe: //PlayerObject.ignoreList
		TypeInfo<IgnoreList >::parseFromBinaryStream(&ignoreList, stream);
		return true;

	case 0x2ebfed5f: //PlayerObject.factionStandingList
		TypeInfo<FactionStandingList >::parseFromBinaryStream(&factionStandingList, stream);
		return true;

	case 0x42645912: //PlayerObject.schematicList
		TypeInfo<SchematicList >::parseFromBinaryStream(&schematicList, stream);
		return true;

	case 0xb0e1799d: //PlayerObject.incapacitationTimes
		TypeInfo<Vector<unsigned int> >::parseFromBinaryStream(&incapacitationTimes, stream);
		return true;

	case 0xbdbf961a: //PlayerObject.suiBoxNextID
		TypeInfo<unsigned int >::parseFromBinaryStream(&suiBoxNextID, stream);
		return true;

	case 0xe7ec84f4: //PlayerObject.suiBoxes
		TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBox* > > >::parseFromBinaryStream(&suiBoxes, stream);
		return true;

	case 0xfddc58de: //PlayerObject.chatRooms
		TypeInfo<SortedVector<unsigned int> >::parseFromBinaryStream(&chatRooms, stream);
		return true;

	case 0x71d62de1: //PlayerObject.ownedChatRooms
		TypeInfo<SortedVector<unsigned int> >::parseFromBinaryStream(&ownedChatRooms, stream);
		return true;

	case 0xe111052b: //PlayerObject.newKillerList
		TypeInfo<Vector<unsigned long long> >::parseFromBinaryStream(&newKillerList, stream);
		return true;

	case 0xa70ae1f1: //PlayerObject.declaredResidence
		TypeInfo<unsigned long long >::parseFromBinaryStream(&declaredResidence, stream);
		return true;

	case 0xb31847ad: //PlayerObject.cloningFacility
		TypeInfo<unsigned long long >::parseFromBinaryStream(&cloningFacility, stream);
		return true;

	case 0x1c4c135a: //PlayerObject.persistentMessages
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&persistentMessages, stream);
		return true;

	case 0x8fdcc5fd: //PlayerObject.biography
		TypeInfo<UnicodeString >::parseFromBinaryStream(&biography, stream);
		return true;

	case 0x2e39a2da: //PlayerObject.consentList
		TypeInfo<SortedVector<String> >::parseFromBinaryStream(&consentList, stream);
		return true;

	case 0x20094ebc: //PlayerObject.lastNpcConvoMessage
		TypeInfo<String >::parseFromBinaryStream(&lastNpcConvoMessage, stream);
		return true;

	case 0x56616dc4: //PlayerObject.lastNpcConvo
		TypeInfo<String >::parseFromBinaryStream(&lastNpcConvo, stream);
		return true;

	case 0x32b94133: //PlayerObject.lastNpcConvoOptions
		TypeInfo<Vector<String> >::parseFromBinaryStream(&lastNpcConvoOptions, stream);
		return true;

	case 0x5cd36e0f: //PlayerObject.conversatingCreature
		TypeInfo<unsigned long long >::parseFromBinaryStream(&conversatingCreature, stream);
		return true;

	case 0x755815b3: //PlayerObject.trainerCoordinates
		TypeInfo<Vector3 >::parseFromBinaryStream(&trainerCoordinates, stream);
		return true;

	case 0x891a3d47: //PlayerObject.trainerZoneName
		TypeInfo<String >::parseFromBinaryStream(&trainerZoneName, stream);
		return true;

	case 0x7645c7d6: //PlayerObject.logoutTimeStamp
		TypeInfo<Time >::parseFromBinaryStream(&logoutTimeStamp, stream);
		return true;

	case 0x377a6e51: //PlayerObject.onlineStatus
		TypeInfo<int >::parseFromBinaryStream(&onlineStatus, stream);
		return true;

	case 0xb10c8ae0: //PlayerObject.skillPoints
		TypeInfo<int >::parseFromBinaryStream(&skillPoints, stream);
		return true;

	case 0xd49b8d6a: //PlayerObject.pvpRating
		TypeInfo<int >::parseFromBinaryStream(&pvpRating, stream);
		return true;

	case 0xd26b2054: //PlayerObject.lastPvpRatingUpdate
		TypeInfo<Time >::parseFromBinaryStream(&lastPvpRatingUpdate, stream);
		return true;

	case 0x908bba87: //PlayerObject.hologrindProfessions
		TypeInfo<Vector<byte> >::parseFromBinaryStream(&hologrindProfessions, stream);
		return true;

	case 0x3166ef65: //PlayerObject.clientLastMovementStamp
		TypeInfo<unsigned int >::parseFromBinaryStream(&clientLastMovementStamp, stream);
		return true;

	case 0x62284a10: //PlayerObject.serverLastMovementStamp
		TypeInfo<Time >::parseFromBinaryStream(&serverLastMovementStamp, stream);
		return true;

	case 0x3b3fbd40: //PlayerObject.lastValidatedPosition
		TypeInfo<ValidatedPosition >::parseFromBinaryStream(&lastValidatedPosition, stream);
		return true;

	case 0x639a0c4f: //PlayerObject.accountID
		TypeInfo<unsigned int >::parseFromBinaryStream(&accountID, stream);
		return true;

	case 0x70fbb795: //PlayerObject.screenPlayData
		TypeInfo<VectorMap<String, String> >::parseFromBinaryStream(&screenPlayData, stream);
		return true;

	case 0x42257652: //PlayerObject.permissionGroups
		TypeInfo<SortedVector<String> >::parseFromBinaryStream(&permissionGroups, stream);
		return true;

	case 0xc7d518a7: //PlayerObject.performanceBuffTarget
		TypeInfo<unsigned long long >::parseFromBinaryStream(&performanceBuffTarget, stream);
		return true;

	case 0xf80402e3: //PlayerObject.debugOutput
		TypeInfo<bool >::parseFromBinaryStream(&debugOutput, stream);
		return true;

	case 0x84d965aa: //PlayerObject.visibility
		TypeInfo<float >::parseFromBinaryStream(&visibility, stream);
		return true;

	case 0xf2ff7f01: //PlayerObject.lastVisibilityUpdateTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&lastVisibilityUpdateTimestamp, stream);
		return true;

	case 0xdd80d638: //PlayerObject.lastBhPvpCombatActionTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&lastBhPvpCombatActionTimestamp, stream);
		return true;

	case 0x12de4676: //PlayerObject.lastGcwPvpCombatActionTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&lastGcwPvpCombatActionTimestamp, stream);
		return true;

	case 0x6f653f52: //PlayerObject.pvpTefTask
		TypeInfo<Reference<PvpTefRemovalTask*> >::parseFromBinaryStream(&pvpTefTask, stream);
		return true;

	case 0x23960f0c: //PlayerObject.lastDigestion
		TypeInfo<Time >::parseFromBinaryStream(&lastDigestion, stream);
		return true;

	case 0xc87e4cfc: //PlayerObject.activePets
		TypeInfo<SortedVector<ManagedReference<AiAgent* > > >::parseFromBinaryStream(&activePets, stream);
		return true;

	case 0x4ce8be67: //PlayerObject.activeQuests
		TypeInfo<DeltaBitArray >::parseFromBinaryStream(&activeQuests, stream);
		return true;

	case 0xa1791985: //PlayerObject.completedQuests
		TypeInfo<DeltaBitArray >::parseFromBinaryStream(&completedQuests, stream);
		return true;

	case 0x842b7659: //PlayerObject.installedHoloEmote
		TypeInfo<String >::parseFromBinaryStream(&installedHoloEmote, stream);
		return true;

	case 0x9b5705cd: //PlayerObject.holoEmoteUseCount
		TypeInfo<int >::parseFromBinaryStream(&holoEmoteUseCount, stream);
		return true;

	case 0x7114f851: //PlayerObject.spouseName
		TypeInfo<String >::parseFromBinaryStream(&spouseName, stream);
		return true;

	case 0x7e9115c8: //PlayerObject.chosenVeteranRewards
		TypeInfo<VectorMap<unsigned int, String> >::parseFromBinaryStream(&chosenVeteranRewards, stream);
		return true;

	case 0xd35e75cf: //PlayerObject.currentEventPerks
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&currentEventPerks, stream);
		return true;

	case 0x52db715b: //PlayerObject.playerQuestsData
		TypeInfo<DeltaVectorMap<uint32, PlayerQuestData > >::parseFromBinaryStream(&playerQuestsData, stream);
		return true;

	}

	return false;
}

void PlayerObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PlayerObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PlayerObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = IntangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x38125d4f; //PlayerObject.characterBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&characterBitmask, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3f59dd69; //PlayerObject.title
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&title, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x80839c38; //PlayerObject.savedTerrainName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&savedTerrainName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x185d8184; //PlayerObject.savedParentID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&savedParentID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xbf409c6b; //PlayerObject.badges
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Badges >::toBinaryStream(&badges, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x6f0f168c; //PlayerObject.forcePower
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&forcePower, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x626f8b12; //PlayerObject.forcePowerMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&forcePowerMax, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd9b9f82b; //PlayerObject.foodFilling
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&foodFilling, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xa5fa3768; //PlayerObject.foodFillingMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&foodFillingMax, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe620a523; //PlayerObject.drinkFilling
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&drinkFilling, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x37da084; //PlayerObject.drinkFillingMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&drinkFillingMax, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe59e7515; //PlayerObject.reactionFines
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&reactionFines, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x911499de; //PlayerObject.reactionFineTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&reactionFineTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x89dba2ac; //PlayerObject.reactionFineMailTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&reactionFineMailTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x68888ebc; //PlayerObject.starterProfession
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&starterProfession, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xf7e4755e; //PlayerObject.bankLocation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&bankLocation, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7a19894f; //PlayerObject.teleporting
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&teleporting, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xcf0cd987; //PlayerObject.onLoadScreen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&onLoadScreen, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x9af4d57b; //PlayerObject.muted
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&muted, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2ba211bc; //PlayerObject.mutedReason
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&mutedReason, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x9151f1d3; //PlayerObject.ownedStructures
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&ownedStructures, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3f521607; //PlayerObject.ownedVendors
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&ownedVendors, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x9c2c0c3f; //PlayerObject.maximumLots
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&maximumLots, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x39b2b254; //PlayerObject.jediState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&jediState, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x4d1afa57; //PlayerObject.adminLevel
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&adminLevel, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xdfba5208; //PlayerObject.priviledgeFlag
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&priviledgeFlag, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x45728d15; //PlayerObject.languageID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&languageID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3737ff5f; //PlayerObject.xpTypeCapList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&xpTypeCapList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x890785df; //PlayerObject.commandMessageStrings
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&commandMessageStrings, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x33656264; //PlayerObject.experienceList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVectorMap<String, int> >::toBinaryStream(&experienceList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xbcd9bd05; //PlayerObject.frsData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FrsData >::toBinaryStream(&frsData, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xbd209913; //PlayerObject.waypointList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<WaypointList >::toBinaryStream(&waypointList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x56e55cb2; //PlayerObject.abilityList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AbilityList >::toBinaryStream(&abilityList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xdab57393; //PlayerObject.friendList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FriendList >::toBinaryStream(&friendList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x4d1f2cfe; //PlayerObject.ignoreList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<IgnoreList >::toBinaryStream(&ignoreList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2ebfed5f; //PlayerObject.factionStandingList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FactionStandingList >::toBinaryStream(&factionStandingList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x42645912; //PlayerObject.schematicList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SchematicList >::toBinaryStream(&schematicList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb0e1799d; //PlayerObject.incapacitationTimes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned int> >::toBinaryStream(&incapacitationTimes, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xbdbf961a; //PlayerObject.suiBoxNextID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&suiBoxNextID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe7ec84f4; //PlayerObject.suiBoxes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBox* > > >::toBinaryStream(&suiBoxes, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xfddc58de; //PlayerObject.chatRooms
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned int> >::toBinaryStream(&chatRooms, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x71d62de1; //PlayerObject.ownedChatRooms
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned int> >::toBinaryStream(&ownedChatRooms, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe111052b; //PlayerObject.newKillerList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&newKillerList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xa70ae1f1; //PlayerObject.declaredResidence
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&declaredResidence, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb31847ad; //PlayerObject.cloningFacility
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&cloningFacility, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1c4c135a; //PlayerObject.persistentMessages
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&persistentMessages, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x8fdcc5fd; //PlayerObject.biography
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<UnicodeString >::toBinaryStream(&biography, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2e39a2da; //PlayerObject.consentList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<String> >::toBinaryStream(&consentList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x20094ebc; //PlayerObject.lastNpcConvoMessage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvoMessage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x56616dc4; //PlayerObject.lastNpcConvo
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvo, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x32b94133; //PlayerObject.lastNpcConvoOptions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&lastNpcConvoOptions, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x5cd36e0f; //PlayerObject.conversatingCreature
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&conversatingCreature, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x755815b3; //PlayerObject.trainerCoordinates
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector3 >::toBinaryStream(&trainerCoordinates, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x891a3d47; //PlayerObject.trainerZoneName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&trainerZoneName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7645c7d6; //PlayerObject.logoutTimeStamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&logoutTimeStamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x377a6e51; //PlayerObject.onlineStatus
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&onlineStatus, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb10c8ae0; //PlayerObject.skillPoints
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&skillPoints, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd49b8d6a; //PlayerObject.pvpRating
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&pvpRating, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd26b2054; //PlayerObject.lastPvpRatingUpdate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastPvpRatingUpdate, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x908bba87; //PlayerObject.hologrindProfessions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<byte> >::toBinaryStream(&hologrindProfessions, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3166ef65; //PlayerObject.clientLastMovementStamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&clientLastMovementStamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x62284a10; //PlayerObject.serverLastMovementStamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&serverLastMovementStamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3b3fbd40; //PlayerObject.lastValidatedPosition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ValidatedPosition >::toBinaryStream(&lastValidatedPosition, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x639a0c4f; //PlayerObject.accountID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&accountID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x70fbb795; //PlayerObject.screenPlayData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, String> >::toBinaryStream(&screenPlayData, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x42257652; //PlayerObject.permissionGroups
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<String> >::toBinaryStream(&permissionGroups, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc7d518a7; //PlayerObject.performanceBuffTarget
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&performanceBuffTarget, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xf80402e3; //PlayerObject.debugOutput
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&debugOutput, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x84d965aa; //PlayerObject.visibility
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&visibility, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xf2ff7f01; //PlayerObject.lastVisibilityUpdateTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastVisibilityUpdateTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xdd80d638; //PlayerObject.lastBhPvpCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastBhPvpCombatActionTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x12de4676; //PlayerObject.lastGcwPvpCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastGcwPvpCombatActionTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x6f653f52; //PlayerObject.pvpTefTask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Reference<PvpTefRemovalTask*> >::toBinaryStream(&pvpTefTask, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x23960f0c; //PlayerObject.lastDigestion
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastDigestion, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc87e4cfc; //PlayerObject.activePets
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<AiAgent* > > >::toBinaryStream(&activePets, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x4ce8be67; //PlayerObject.activeQuests
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaBitArray >::toBinaryStream(&activeQuests, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xa1791985; //PlayerObject.completedQuests
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaBitArray >::toBinaryStream(&completedQuests, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x842b7659; //PlayerObject.installedHoloEmote
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&installedHoloEmote, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x9b5705cd; //PlayerObject.holoEmoteUseCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&holoEmoteUseCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7114f851; //PlayerObject.spouseName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&spouseName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7e9115c8; //PlayerObject.chosenVeteranRewards
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&chosenVeteranRewards, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd35e75cf; //PlayerObject.currentEventPerks
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&currentEventPerks, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x52db715b; //PlayerObject.playerQuestsData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVectorMap<uint32, PlayerQuestData > >::toBinaryStream(&playerQuestsData, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 83;
}

PlayerObjectImplementation::PlayerObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/player/PlayerObject.idl():  		characterBitmask = 0;
	characterBitmask = 0;
	// server/zone/objects/player/PlayerObject.idl():  		commandMessageStrings.setNoDuplicateInsertPlan();
	(&commandMessageStrings)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		bankLocation = "";
	bankLocation = "";
	// server/zone/objects/player/PlayerObject.idl():  		teleporting = false;
	teleporting = false;
	// server/zone/objects/player/PlayerObject.idl():  		onLoadScreen = false;
	onLoadScreen = false;
	// server/zone/objects/player/PlayerObject.idl():  		muted = false;
	muted = false;
	// server/zone/objects/player/PlayerObject.idl():  		mutedReason = "";
	mutedReason = "";
	// server/zone/objects/player/PlayerObject.idl():  		debugOutput = false;
	debugOutput = false;
	// server/zone/objects/player/PlayerObject.idl():  		suiBoxNextID = 0;
	suiBoxNextID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		savedParentID = 0;
	savedParentID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		declaredResidence = 0;
	declaredResidence = 0;
	// server/zone/objects/player/PlayerObject.idl():  		cloningFacility = 0;
	cloningFacility = 0;
	// server/zone/objects/player/PlayerObject.idl():  		skillPoints = 0;
	skillPoints = 0;
	// server/zone/objects/player/PlayerObject.idl():  		conversatingCreature = 0;
	conversatingCreature = 0;
	// server/zone/objects/player/PlayerObject.idl():  		forcePower = 0;
	forcePower = 0;
	// server/zone/objects/player/PlayerObject.idl():  		forcePowerMax = 0;
	forcePowerMax = 0;
	// server/zone/objects/player/PlayerObject.idl():  		jediState = 0;
	jediState = 0;
	// server/zone/objects/player/PlayerObject.idl():  		pvpRating = 1200;
	pvpRating = 1200;
	// server/zone/objects/player/PlayerObject.idl():  		trainerZoneName = "";
	trainerZoneName = "";
	// server/zone/objects/player/PlayerObject.idl():  		duelList.setNoDuplicateInsertPlan();
	(&duelList)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		persistentMessages.setNoDuplicateInsertPlan();
	(&persistentMessages)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		consentList.setNoDuplicateInsertPlan();
	(&consentList)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		activePets.setNoDuplicateInsertPlan();
	(&activePets)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		chosenVeteranRewards.setNoDuplicateInsertPlan();
	(&chosenVeteranRewards)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		accountID = 0;
	accountID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		clientLastMovementStamp = 0;
	clientLastMovementStamp = 0;
	// server/zone/objects/player/PlayerObject.idl():  		maximumLots = 10;
	maximumLots = 10;
	// server/zone/objects/player/PlayerObject.idl():  		adminLevel = 0;
	adminLevel = 0;
	// server/zone/objects/player/PlayerObject.idl():  		priviledgeFlag = 0;
	priviledgeFlag = 0;
	// server/zone/objects/player/PlayerObject.idl():  		languageID = 0;
	languageID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		setOffline();
	setOffline();
	// server/zone/objects/player/PlayerObject.idl():  		performanceBuffTarget = 0;
	performanceBuffTarget = 0;
	// server/zone/objects/player/PlayerObject.idl():  		visibility = 0;
	visibility = 0;
	// server/zone/objects/player/PlayerObject.idl():  		lastVisibilityUpdateTimestamp.updateToCurrentTime();
	(&lastVisibilityUpdateTimestamp)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		lastBhPvpCombatActionTimestamp.updateToCurrentTime();
	(&lastBhPvpCombatActionTimestamp)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		lastGcwPvpCombatActionTimestamp.updateToCurrentTime();
	(&lastGcwPvpCombatActionTimestamp)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		lastDigestion.updateToCurrentTime();
	(&lastDigestion)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		installedHoloEmote = "";
	installedHoloEmote = "";
	// server/zone/objects/player/PlayerObject.idl():  		holoEmoteUseCount = 0;
	holoEmoteUseCount = 0;
	// server/zone/objects/player/PlayerObject.idl():  		spouseName = "";
	spouseName = "";
	// server/zone/objects/player/PlayerObject.idl():  		foodFilling = 0;
	foodFilling = 0;
	// server/zone/objects/player/PlayerObject.idl():  		foodFillingMax = 0;
	foodFillingMax = 0;
	// server/zone/objects/player/PlayerObject.idl():  		drinkFilling = 0;
	drinkFilling = 0;
	// server/zone/objects/player/PlayerObject.idl():  		drinkFillingMax = 0;
	drinkFillingMax = 0;
	// server/zone/objects/player/PlayerObject.idl():  		reactionFines = 0;
	reactionFines = 0;
	// server/zone/objects/player/PlayerObject.idl():  		lastPvpRatingUpdate.updateToCurrentTime();
	(&lastPvpRatingUpdate)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		Logger.setLoggingName("PlayerObject");
	Logger::setLoggingName("PlayerObject");
}

void PlayerObjectImplementation::finalize() {
}

void PlayerObjectImplementation::setClientPathWaypoint(SceneObject* obj) {
	// server/zone/objects/player/PlayerObject.idl():  		currentClientPathWaypoint = obj;
	currentClientPathWaypoint = obj;
}

void PlayerObjectImplementation::addOwnedStructure(StructureObject* obj) {
	Locker _locker(_this.get());
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.
	if (obj == NULL)	// server/zone/objects/player/PlayerObject.idl():  			return;
	return;
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.put(obj.getObjectID());
	(&ownedStructures)->put(obj->getObjectID());
}

void PlayerObjectImplementation::removeOwnedStructure(StructureObject* obj) {
	Locker _locker(_this.get());
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.
	if (obj == NULL)	// server/zone/objects/player/PlayerObject.idl():  			return;
	return;
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.drop(obj.getObjectID());
	(&ownedStructures)->drop(obj->getObjectID());
	// server/zone/objects/player/PlayerObject.idl():  	}
	if (obj->getObjectID() == getDeclaredResidence())	// server/zone/objects/player/PlayerObject.idl():  			setDeclaredResidence(null);
	setDeclaredResidence(NULL);
}

int PlayerObjectImplementation::getTotalOwnedStructureCount() {
	Locker _locker(_this.get());
	// server/zone/objects/player/PlayerObject.idl():  		return ownedStructures.size();
	return (&ownedStructures)->size();
}

bool PlayerObjectImplementation::isOwnedStructure(StructureObject* obj) {
	Locker _locker(_this.get());
	// server/zone/objects/player/PlayerObject.idl():  		return 
	if (obj == NULL)	// server/zone/objects/player/PlayerObject.idl():  			return false;
	return false;
	// server/zone/objects/player/PlayerObject.idl():  		return ownedStructures.contains(obj.getObjectID());
	return (&ownedStructures)->contains(obj->getObjectID());
}

unsigned long long PlayerObjectImplementation::getOwnedStructure(int i) {
	Locker _locker(_this.get());
	// server/zone/objects/player/PlayerObject.idl():  		return ownedStructures.get(i);
	return (&ownedStructures)->get(i);
}

bool PlayerObjectImplementation::hasLotsRemaining(int lots) {
	Locker _locker(_this.get());
	// server/zone/objects/player/PlayerObject.idl():  		return lots <= getLotsRemaining();
	return lots <= getLotsRemaining();
}

bool PlayerObjectImplementation::hasWaypoint(unsigned long long objectID) {
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList.contains(objectID);
	return (&waypointList)->contains(objectID);
}

WaypointObject* PlayerObjectImplementation::getWaypointAt(float x, float y, String& planet) {
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList.getWaypointAt(x, y, planet);
	return (&waypointList)->getWaypointAt(x, y, planet);
}

void PlayerObjectImplementation::insertWaypointListToMessage(BaseMessage* msg) {
	// server/zone/objects/player/PlayerObject.idl():  		waypointList.insertToMessage(msg);
	(&waypointList)->insertToMessage(msg);
}

int PlayerObjectImplementation::getWaypointListSize() {
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList.size();
	return (&waypointList)->size();
}

WaypointObject* PlayerObjectImplementation::getWaypoint(int index) {
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList.getValueAt(index);
	return (&waypointList)->getValueAt(index);
}

void PlayerObjectImplementation::setScreenPlayData(const String& screenPlay, const String& variable, const String& data) {
	// server/zone/objects/player/PlayerObject.idl():  		screenPlayData.put(screenPlay + "_" + variable, data);
	(&screenPlayData)->put(screenPlay + "_" + variable, data);
}

void PlayerObjectImplementation::deleteScreenPlayData(const String& screenPlay, const String& variable) {
	// server/zone/objects/player/PlayerObject.idl():  		screenPlayData.drop(screenPlay + "_" + variable);
	(&screenPlayData)->drop(screenPlay + "_" + variable);
}

String PlayerObjectImplementation::getScreenPlayData(const String& screenPlay, const String& variable) {
	// server/zone/objects/player/PlayerObject.idl():  		return screenPlayData.get(screenPlay + "_" + variable);
	return (&screenPlayData)->get(screenPlay + "_" + variable);
}

void PlayerObjectImplementation::setOffline() {
	// server/zone/objects/player/PlayerObject.idl():  		onlineStatus 
	if (isLinkDead()){
}
	// server/zone/objects/player/PlayerObject.idl():  		onlineStatus = OFFLINE;
	onlineStatus = OFFLINE;
}

void PlayerObjectImplementation::setLoggingOut() {
	// server/zone/objects/player/PlayerObject.idl():  		onlineStatus = LOGGINGOUT;
	onlineStatus = LOGGINGOUT;
}

void PlayerObjectImplementation::clearActiveQuestsBit(int bitIndex, bool notifyClient) {
	// server/zone/objects/player/PlayerObject.idl():  		setActiveQuestsBit(bitIndex, (byte)0, notifyClient);
	setActiveQuestsBit(bitIndex, (byte) 0, notifyClient);
}

bool PlayerObjectImplementation::hasActiveQuestBitSet(int bitIndex) {
	// server/zone/objects/player/PlayerObject.idl():  		return activeQuests.getBitValue(bitIndex);
	return (&activeQuests)->getBitValue(bitIndex);
}

bool PlayerObjectImplementation::hasCompletedQuestsBitSet(int bitIndex) {
	// server/zone/objects/player/PlayerObject.idl():  		return completedQuests.getBitValue(bitIndex);
	return (&completedQuests)->getBitValue(bitIndex);
}

void PlayerObjectImplementation::clearCompletedQuestsBit(int bitIndex, bool notifyClient) {
	// server/zone/objects/player/PlayerObject.idl():  		setCompletedQuestsBit(bitIndex, (byte)0, notifyClient);
	setCompletedQuestsBit(bitIndex, (byte) 0, notifyClient);
}

bool PlayerObjectImplementation::hasQuestData(unsigned int questHashCode) {
	// server/zone/objects/player/PlayerObject.idl():  		return playerQuestsData.contains(questHashCode);
	return (&playerQuestsData)->contains(questHashCode);
}

FactionStandingList* PlayerObjectImplementation::getFactionStandingList() {
	// server/zone/objects/player/PlayerObject.idl():  		return factionStandingList;
	return (&factionStandingList);
}

void PlayerObjectImplementation::setLastNpcConvStr(const String& conv) {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvo = conv;
	lastNpcConvo = conv;
}

void PlayerObjectImplementation::setLastNpcConvMessStr(const String& mess) {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvoMessage = mess;
	lastNpcConvoMessage = mess;
}

String PlayerObjectImplementation::getLastNpcConvStr() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvo;
	return lastNpcConvo;
}

String PlayerObjectImplementation::getLastNpcConvMessStr() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvoMessage;
	return lastNpcConvoMessage;
}

String PlayerObjectImplementation::getLastNpcConvOption(int idx) {
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvoOptions.get(idx);
	return (&lastNpcConvoOptions)->get(idx);
}

void PlayerObjectImplementation::addLastNpcConvOptions(const String& option) {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvoOptions.add(option);
	(&lastNpcConvoOptions)->add(option);
}

int PlayerObjectImplementation::countLastNpcConvOptions() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvoOptions.size();
	return (&lastNpcConvoOptions)->size();
}

void PlayerObjectImplementation::clearLastNpcConvOptions() {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvoOptions.removeAll();
	(&lastNpcConvoOptions)->removeAll();
}

void PlayerObjectImplementation::setConversatingCreature(CreatureObject* creature) {
	// server/zone/objects/player/PlayerObject.idl():  			conversatingCreature = creature.getObjectID();
	if (creature == NULL)	// server/zone/objects/player/PlayerObject.idl():  			conversatingCreature = 0;
	conversatingCreature = 0;

	else 	// server/zone/objects/player/PlayerObject.idl():  			conversatingCreature = creature.getObjectID();
	conversatingCreature = creature->getObjectID();
}

unsigned long long PlayerObjectImplementation::getConversatingCreature() {
	// server/zone/objects/player/PlayerObject.idl():  		return conversatingCreature;
	return conversatingCreature;
}

void PlayerObjectImplementation::setTrainerZoneName(String& zoneName) {
	// server/zone/objects/player/PlayerObject.idl():  		trainerZoneName = zoneName;
	trainerZoneName = zoneName;
}

String PlayerObjectImplementation::getTrainerZoneName() {
	// server/zone/objects/player/PlayerObject.idl():  		return trainerZoneName;
	return trainerZoneName;
}

SortedVector<unsigned long long>* PlayerObjectImplementation::getPersistentMessages() {
	// server/zone/objects/player/PlayerObject.idl():  		return persistentMessages;
	return (&persistentMessages);
}

void PlayerObjectImplementation::addPersistentMessage(unsigned long long id) {
	// server/zone/objects/player/PlayerObject.idl():  		persistentMessages.put(id);
	(&persistentMessages)->put(id);
}

void PlayerObjectImplementation::dropPersistentMessage(unsigned long long id) {
	// server/zone/objects/player/PlayerObject.idl():  		persistentMessages.drop(id);
	(&persistentMessages)->drop(id);
}

void PlayerObjectImplementation::addToConsentList(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		consentList.put(name);
	(&consentList)->put(name);
}

bool PlayerObjectImplementation::hasInConsentList(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		return consentList.contains(name);
	return (&consentList)->contains(name);
}

void PlayerObjectImplementation::removeFromConsentList(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		consentList.drop(name);
	(&consentList)->drop(name);
}

String PlayerObjectImplementation::getConsentName(int i) {
	// server/zone/objects/player/PlayerObject.idl():  		return consentList.get(i);
	return (&consentList)->get(i);
}

int PlayerObjectImplementation::getConsentListSize() {
	// server/zone/objects/player/PlayerObject.idl():  		return consentList.size();
	return (&consentList)->size();
}

int PlayerObjectImplementation::getReactionFines() {
	// server/zone/objects/player/PlayerObject.idl():  		return reactionFines;
	return reactionFines;
}

String PlayerObjectImplementation::getFactionRank() {
	// server/zone/objects/player/PlayerObject.idl():  		return factionStandingList.getFactionRank();
	return (&factionStandingList)->getFactionRank();
}

void PlayerObjectImplementation::setFactionRank(const String& rank) {
	// server/zone/objects/player/PlayerObject.idl():  		factionStandingList.setFactionRank(rank);
	(&factionStandingList)->setFactionRank(rank);
}

void PlayerObjectImplementation::setCommandMessageString(unsigned int actionCRC, String& message) {
	// server/zone/objects/player/PlayerObject.idl():  		commandMessageStrings.put(actionCRC, message);
	(&commandMessageStrings)->put(actionCRC, message);
}

void PlayerObjectImplementation::removeCommandMessageString(unsigned int actionCRC) {
	// server/zone/objects/player/PlayerObject.idl():  		commandMessageStrings.drop(actionCRC);
	(&commandMessageStrings)->drop(actionCRC);
}

unsigned long long PlayerObjectImplementation::getDeclaredResidence() const{
	// server/zone/objects/player/PlayerObject.idl():  		return declaredResidence;
	return declaredResidence;
}

void PlayerObjectImplementation::setDeclaredResidence(BuildingObject* residence) {
	// server/zone/objects/player/PlayerObject.idl():  			declaredResidence = residence.getObjectID();
	if (residence == NULL)	// server/zone/objects/player/PlayerObject.idl():  			declaredResidence = 0;
	declaredResidence = 0;

	else 	// server/zone/objects/player/PlayerObject.idl():  			declaredResidence = residence.getObjectID();
	declaredResidence = residence->getObjectID();
}

void PlayerObjectImplementation::setCloningFacility(BuildingObject* cloningfac) {
	// server/zone/objects/player/PlayerObject.idl():  			cloningFacility = cloningfac.getObjectID();
	if (cloningfac == NULL)	// server/zone/objects/player/PlayerObject.idl():  			cloningFacility = 0;
	cloningFacility = 0;

	else 	// server/zone/objects/player/PlayerObject.idl():  			cloningFacility = cloningfac.getObjectID();
	cloningFacility = cloningfac->getObjectID();
}

unsigned long long PlayerObjectImplementation::getCloningFacility() const{
	// server/zone/objects/player/PlayerObject.idl():  		return cloningFacility;
	return cloningFacility;
}

bool PlayerObjectImplementation::isDigesting() {
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (getDrinkFilling() > 0 || getFoodFilling() > 0){
	// server/zone/objects/player/PlayerObject.idl():  			return true;
	return true;
}

	else {
	// server/zone/objects/player/PlayerObject.idl():  			return false;
	return false;
}
}

String PlayerObjectImplementation::getSavedTerrainName() const{
	// server/zone/objects/player/PlayerObject.idl():  		return savedTerrainName;
	return savedTerrainName;
}

void PlayerObjectImplementation::setSavedParentID(unsigned long long id) {
	// server/zone/objects/player/PlayerObject.idl():  		savedParentID = id;
	savedParentID = id;
}

void PlayerObjectImplementation::setSavedTerrainName(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		savedTerrainName = name;
	savedTerrainName = name;
}

unsigned long long PlayerObjectImplementation::getSavedParentID() const{
	// server/zone/objects/player/PlayerObject.idl():  		return savedParentID;
	return savedParentID;
}

bool PlayerObjectImplementation::hasSuiBox(unsigned int boxID) {
	// server/zone/objects/player/PlayerObject.idl():  		return suiBoxes.contains(boxID);
	return (&suiBoxes)->contains(boxID);
}

Reference<SuiBox* > PlayerObjectImplementation::getSuiBox(unsigned int boxID) {
	// server/zone/objects/player/PlayerObject.idl():  		return suiBoxes.get(boxID);
	return (&suiBoxes)->get(boxID);
}

bool PlayerObjectImplementation::hasSuiBoxWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerObject.idl():  		unsigned int type = 0;
	unsigned int type = 0;
	// server/zone/objects/player/PlayerObject.idl():  		}
	for (	// server/zone/objects/player/PlayerObject.idl():  		for (int i = 0;
	int i = 0;
	i < (&suiBoxes)->size();
 ++i) {
	// server/zone/objects/player/PlayerObject.idl():  			SuiBox sui = suiBoxes.get(i);
	ManagedReference<SuiBox* > sui = (&suiBoxes)->get(i);
	// server/zone/objects/player/PlayerObject.idl():  			type = sui.getWindowType();
	type = sui->getWindowType();
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (windowType == type)	// server/zone/objects/player/PlayerObject.idl():  				return true;
	return true;
}
	// server/zone/objects/player/PlayerObject.idl():  		return false;
	return false;
}

void PlayerObjectImplementation::closeSuiWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerObject.idl():  	}
	if (hasSuiBoxWindowType(windowType)){
	// server/zone/objects/player/PlayerObject.idl():  			SuiBox sui = getSuiBoxFromWindowType(windowType);
	ManagedReference<SuiBox* > sui = getSuiBoxFromWindowType(windowType);
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (sui != NULL){
	// server/zone/objects/player/PlayerObject.idl():  				sendMessage(sui.generateCloseMessage());
	sendMessage(sui->generateCloseMessage());
	// server/zone/objects/player/PlayerObject.idl():  				removeSuiBox(sui.getBoxID());
	removeSuiBox(sui->getBoxID());
}
}
}

Reference<SuiBox* > PlayerObjectImplementation::getSuiBoxFromWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerObject.idl():  		unsigned int type = 0;
	unsigned int type = 0;
	// server/zone/objects/player/PlayerObject.idl():  		}
	for (	// server/zone/objects/player/PlayerObject.idl():  		for (int i = 0;
	int i = 0;
	i < (&suiBoxes)->size();
 ++i) {
	// server/zone/objects/player/PlayerObject.idl():  			SuiBox sui = suiBoxes.get(i);
	ManagedReference<SuiBox* > sui = (&suiBoxes)->get(i);
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (windowType == sui->getWindowType())	// server/zone/objects/player/PlayerObject.idl():  				return sui;
	return sui;
}
	// server/zone/objects/player/PlayerObject.idl():  		return null;
	return NULL;
}

void PlayerObjectImplementation::addSuiBox(SuiBox* sui) {
	// server/zone/objects/player/PlayerObject.idl():  		unsigned int key = sui.getBoxID();
	unsigned int key = sui->getBoxID();
	// server/zone/objects/player/PlayerObject.idl():  		suiBoxes.put(key, sui);
	(&suiBoxes)->put(key, sui);
}

SortedVector<String>* PlayerObjectImplementation::getPermissionGroups() {
	// server/zone/objects/player/PlayerObject.idl():  		return permissionGroups;
	return (&permissionGroups);
}

byte PlayerObjectImplementation::getIncapacitationCounter() const{
	// server/zone/objects/player/PlayerObject.idl():  		return incapacitationTimes.size();
	return (&incapacitationTimes)->size();
}

void PlayerObjectImplementation::resetIncapacitationTimes() {
	// server/zone/objects/player/PlayerObject.idl():  		incapacitationTimes.removeAll();
	(&incapacitationTimes)->removeAll();
}

void PlayerObjectImplementation::addToDuelList(CreatureObject* targetPlayer) {
	// server/zone/objects/player/PlayerObject.idl():  		duelList.put(targetPlayer);
	(&duelList)->put(targetPlayer);
}

void PlayerObjectImplementation::removeFromDuelList(CreatureObject* targetPlayer) {
	// server/zone/objects/player/PlayerObject.idl():  		duelList.drop(targetPlayer);
	(&duelList)->drop(targetPlayer);
}

Reference<CreatureObject* > PlayerObjectImplementation::getDuelListObject(int index) {
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.get(index);
	return (&duelList)->get(index);
}

bool PlayerObjectImplementation::requestedDuelTo(CreatureObject* targetPlayer) {
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.contains(targetPlayer);
	return (&duelList)->contains(targetPlayer);
}

bool PlayerObjectImplementation::isDuelListEmpty() {
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.isEmpty();
	return (&duelList)->isEmpty();
}

int PlayerObjectImplementation::getDuelListSize() {
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.size();
	return (&duelList)->size();
}

void PlayerObjectImplementation::addToActivePets(AiAgent* pet) {
	// server/zone/objects/player/PlayerObject.idl():  		activePets.put(pet);
	(&activePets)->put(pet);
}

void PlayerObjectImplementation::removeFromActivePets(AiAgent* pet) {
	// server/zone/objects/player/PlayerObject.idl():  		activePets.drop(pet);
	(&activePets)->drop(pet);
}

AiAgent* PlayerObjectImplementation::getActivePet(int index) {
	// server/zone/objects/player/PlayerObject.idl():  		return activePets.get(index);
	return (&activePets)->get(index);
}

bool PlayerObjectImplementation::hasActivePet(AiAgent* pet) {
	// server/zone/objects/player/PlayerObject.idl():  		return activePets.contains(pet);
	return (&activePets)->contains(pet);
}

int PlayerObjectImplementation::getActivePetsSize() {
	// server/zone/objects/player/PlayerObject.idl():  		return activePets.size();
	return (&activePets)->size();
}

UnicodeString PlayerObjectImplementation::getBiography() const{
	// server/zone/objects/player/PlayerObject.idl():  		return biography;
	return biography;
}

void PlayerObjectImplementation::setBadge(unsigned int badge) {
	// server/zone/objects/player/PlayerObject.idl():  		badges.setBadge(badge);
	(&badges)->setBadge(badge);
}

void PlayerObjectImplementation::setTeleporting(bool val) {
	// server/zone/objects/player/PlayerObject.idl():  		teleporting = val;
	teleporting = val;
}

void PlayerObjectImplementation::setOnLoadScreen(bool val) {
	// server/zone/objects/player/PlayerObject.idl():  		onLoadScreen = val;
	onLoadScreen = val;
}

int PlayerObjectImplementation::getNumBadges() {
	// server/zone/objects/player/PlayerObject.idl():  		return badges.getNumBadges();
	return (&badges)->getNumBadges();
}

int PlayerObjectImplementation::getBadgeTypeCount(unsigned int type) {
	// server/zone/objects/player/PlayerObject.idl():  		return badges.getTypeCount(type);
	return (&badges)->getTypeCount(type);
}

bool PlayerObjectImplementation::hasFriend(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		return friendList.contains(name);
	return (&friendList)->contains(name);
}

int PlayerObjectImplementation::getFriendListSize() {
	// server/zone/objects/player/PlayerObject.idl():  		return friendList.size();
	return (&friendList)->size();
}

void PlayerObjectImplementation::addReverseFriend(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		friendList.addReversePlayer(name);
	(&friendList)->addReversePlayer(name);
}

void PlayerObjectImplementation::removeReverseFriend(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		friendList.removeReversePlayer(name);
	(&friendList)->removeReversePlayer(name);
}

bool PlayerObjectImplementation::hasAbility(const String& ability) {
	// server/zone/objects/player/PlayerObject.idl():  		return abilityList.contains(ability);
	return (&abilityList)->contains(ability);
}

bool PlayerObjectImplementation::hasCommandMessageString(unsigned int actionCRC) {
	// server/zone/objects/player/PlayerObject.idl():  		return commandMessageStrings.contains(actionCRC);
	return (&commandMessageStrings)->contains(actionCRC);
}

unsigned int PlayerObjectImplementation::getCharacterBitmask() const{
	// server/zone/objects/player/PlayerObject.idl():  		return characterBitmask;
	return characterBitmask;
}

String PlayerObjectImplementation::getTitle() const{
	// server/zone/objects/player/PlayerObject.idl():  		return title;
	return title;
}

unsigned int PlayerObjectImplementation::getAdminLevel() const{
	// server/zone/objects/player/PlayerObject.idl():  		return adminLevel;
	return adminLevel;
}

void PlayerObjectImplementation::setAdminLevel(unsigned int adminlvl) {
	// server/zone/objects/player/PlayerObject.idl():  		adminLevel = adminlvl;
	adminLevel = adminlvl;
}

int PlayerObjectImplementation::getPriviledgeFlag() const{
	// server/zone/objects/player/PlayerObject.idl():  		return priviledgeFlag;
	return priviledgeFlag;
}

void PlayerObjectImplementation::setPriviledgeFlag(int flag) {
	// server/zone/objects/player/PlayerObject.idl():  		priviledgeFlag = flag;
	priviledgeFlag = flag;
}

void PlayerObjectImplementation::setBiography(const UnicodeString& bio) {
	// server/zone/objects/player/PlayerObject.idl():  		biography = bio;
	biography = bio;
}

bool PlayerObjectImplementation::hasGodMode() {
	// server/zone/objects/player/PlayerObject.idl():  		return (adminLevel > 0 && hasAbility("admin"));
	return (adminLevel > 0 && hasAbility("admin"));
}

bool PlayerObjectImplementation::isPrivileged() {
	// server/zone/objects/player/PlayerObject.idl():  		return (adminLevel > 6 && hasAbility("admin"));
	return (adminLevel > 6 && hasAbility("admin"));
}

bool PlayerObjectImplementation::isStaff() {
	// server/zone/objects/player/PlayerObject.idl():  		return (adminLevel > 10 && hasAbility("admin"));
	return (adminLevel > 10 && hasAbility("admin"));
}

bool PlayerObjectImplementation::isAdmin() {
	// server/zone/objects/player/PlayerObject.idl():  		return (adminLevel == 15 && hasAbility("admin"));
	return (adminLevel == 15 && hasAbility("admin"));
}

void PlayerObjectImplementation::setCharacterBitmask(unsigned int bitmask) {
	// server/zone/objects/player/PlayerObject.idl():  		characterBitmask = bitmask;
	characterBitmask = bitmask;
}

VectorMap<String, int>* PlayerObjectImplementation::getXpTypeCapList() {
	// server/zone/objects/player/PlayerObject.idl():  	 return xpTypeCapList;
	return (&xpTypeCapList);
}

DeltaVectorMap<String, int>* PlayerObjectImplementation::getExperienceList() {
	// server/zone/objects/player/PlayerObject.idl():  		return experienceList;
	return (&experienceList);
}

DeltaVectorMap<uint32, PlayerQuestData >* PlayerObjectImplementation::getPlayerQuestsData() {
	// server/zone/objects/player/PlayerObject.idl():  		return playerQuestsData;
	return (&playerQuestsData);
}

DeltaBitArray* PlayerObjectImplementation::getActiveQuests() {
	// server/zone/objects/player/PlayerObject.idl():  		return activeQuests;
	return (&activeQuests);
}

DeltaBitArray* PlayerObjectImplementation::getCompletedQuests() {
	// server/zone/objects/player/PlayerObject.idl():  		return completedQuests;
	return (&completedQuests);
}

int PlayerObjectImplementation::getForcePower() const{
	// server/zone/objects/player/PlayerObject.idl():  		return forcePower;
	return forcePower;
}

int PlayerObjectImplementation::getForcePowerMax() const{
	// server/zone/objects/player/PlayerObject.idl():  		return forcePowerMax;
	return forcePowerMax;
}

AbilityList* PlayerObjectImplementation::getAbilityList() {
	// server/zone/objects/player/PlayerObject.idl():  		return abilityList;
	return (&abilityList);
}

FrsData* PlayerObjectImplementation::getFrsData() {
	// server/zone/objects/player/PlayerObject.idl():  		return frsData;
	return (&frsData);
}

SchematicList* PlayerObjectImplementation::getSchematics() {
	// server/zone/objects/player/PlayerObject.idl():  		return schematicList;
	return (&schematicList);
}

DraftSchematic* PlayerObjectImplementation::getSchematic(int i) {
	// server/zone/objects/player/PlayerObject.idl():  		return schematicList.get(i);
	return (&schematicList)->get(i);
}

int PlayerObjectImplementation::getFoodFilling() const{
	// server/zone/objects/player/PlayerObject.idl():  		return foodFilling;
	return foodFilling;
}

int PlayerObjectImplementation::getFoodFillingMax() const{
	// server/zone/objects/player/PlayerObject.idl():  		return foodFillingMax;
	return foodFillingMax;
}

int PlayerObjectImplementation::getDrinkFilling() const{
	// server/zone/objects/player/PlayerObject.idl():  		return drinkFilling;
	return drinkFilling;
}

int PlayerObjectImplementation::getDrinkFillingMax() const{
	// server/zone/objects/player/PlayerObject.idl():  		return drinkFillingMax;
	return drinkFillingMax;
}

int PlayerObjectImplementation::getJediState() const{
	// server/zone/objects/player/PlayerObject.idl():  		return jediState;
	return jediState;
}

byte PlayerObjectImplementation::getLanguageID() const{
	// server/zone/objects/player/PlayerObject.idl():  		return languageID;
	return languageID;
}

DeltaVector<String>* PlayerObjectImplementation::getFriendList() {
	// server/zone/objects/player/PlayerObject.idl():  		return friendList;
	return (&friendList);
}

bool PlayerObjectImplementation::isTeleporting() const{
	// server/zone/objects/player/PlayerObject.idl():  		return teleporting;
	return teleporting;
}

bool PlayerObjectImplementation::isOnLoadScreen() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onLoadScreen;
	return onLoadScreen;
}

void PlayerObjectImplementation::addChatRoom(unsigned int roomID) {
	// server/zone/objects/player/PlayerObject.idl():  		chatRooms.put(roomID);
	(&chatRooms)->put(roomID);
}

void PlayerObjectImplementation::removeChatRoom(unsigned int roomID) {
	// server/zone/objects/player/PlayerObject.idl():  		chatRooms.drop(roomID);
	(&chatRooms)->drop(roomID);
}

void PlayerObjectImplementation::addOwnedChatRoom(unsigned int roomID) {
	// server/zone/objects/player/PlayerObject.idl():  		ownedChatRooms.put(roomID);
	(&ownedChatRooms)->put(roomID);
}

void PlayerObjectImplementation::removeOwnedChatRoom(unsigned int roomID) {
	// server/zone/objects/player/PlayerObject.idl():  		ownedChatRooms.drop(roomID);
	(&ownedChatRooms)->drop(roomID);
}

void PlayerObjectImplementation::setBankLocation(const String& location) {
	// server/zone/objects/player/PlayerObject.idl():  		bankLocation = location;
	bankLocation = location;
}

String PlayerObjectImplementation::getBankLocation() const{
	// server/zone/objects/player/PlayerObject.idl():  		return bankLocation;
	return bankLocation;
}

DeltaVector<String>* PlayerObjectImplementation::getIgnoreList() {
	// server/zone/objects/player/PlayerObject.idl():  		return ignoreList;
	return (&ignoreList);
}

int PlayerObjectImplementation::getExperience(const String& xp) {
	// server/zone/objects/player/PlayerObject.idl():  		}
	if ((&experienceList)->contains(xp)){
	// server/zone/objects/player/PlayerObject.idl():  			return experienceList.get(xp);
	return (&experienceList)->get(xp);
}

	else {
	// server/zone/objects/player/PlayerObject.idl():  			return 0;
	return 0;
}
}

String PlayerObjectImplementation::getCommandMessageString(unsigned int actionCRC) {
	// server/zone/objects/player/PlayerObject.idl():  		return commandMessageStrings.get(actionCRC);
	return (&commandMessageStrings)->get(actionCRC);
}

bool PlayerObjectImplementation::hasBadge(unsigned int badge) {
	// server/zone/objects/player/PlayerObject.idl():  		return badges.hasBadge(badge);
	return (&badges)->hasBadge(badge);
}

bool PlayerObjectImplementation::isOnline() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus != OFFLINE && onlineStatus != LINKDEAD;
	return onlineStatus != OFFLINE && onlineStatus != LINKDEAD;
}

bool PlayerObjectImplementation::isOffline() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == OFFLINE;
	return onlineStatus == OFFLINE;
}

bool PlayerObjectImplementation::isLoading() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LOADING || onlineStatus == LOGGINGOUT;
	return onlineStatus == LOADING || onlineStatus == LOGGINGOUT;
}

bool PlayerObjectImplementation::isLinkDead() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LINKDEAD;
	return onlineStatus == LINKDEAD;
}

bool PlayerObjectImplementation::isLoggingIn() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LOGGINGIN;
	return onlineStatus == LOGGINGIN;
}

bool PlayerObjectImplementation::isLoggingOut() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LOGGINGOUT;
	return onlineStatus == LOGGINGOUT;
}

Time* PlayerObjectImplementation::getLastLogout() {
	// server/zone/objects/player/PlayerObject.idl():  		return logoutTimeStamp;
	return (&logoutTimeStamp);
}

int PlayerObjectImplementation::getDaysSinceLastLogout() {
	// server/zone/objects/player/PlayerObject.idl():  		return (int)(logoutTimeStamp.miliDifference() / 1000 / 60 / 60 / 24);
	return (int) ((&logoutTimeStamp)->miliDifference() / 1000 / 60 / 60 / 24);
}

void PlayerObjectImplementation::setSkillPoints(int points) {
	// server/zone/objects/player/PlayerObject.idl():  		skillPoints = points;
	skillPoints = points;
}

void PlayerObjectImplementation::addSkillPoints(int points) {
	// server/zone/objects/player/PlayerObject.idl():  		skillPoints += points;
	skillPoints += points;
}

int PlayerObjectImplementation::getSkillPoints() const{
	// server/zone/objects/player/PlayerObject.idl():  		return skillPoints;
	return skillPoints;
}

ValidatedPosition* PlayerObjectImplementation::getLastValidatedPosition() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastValidatedPosition;
	return (&lastValidatedPosition);
}

void PlayerObjectImplementation::updateLastValidatedPosition() {
	// server/zone/objects/player/PlayerObject.idl():  		SceneObject par = super.getParent();
	ManagedReference<SceneObject* > par = IntangibleObjectImplementation::getParent();
	// server/zone/objects/player/PlayerObject.idl():  		lastValidatedPosition.update(par);
	(&lastValidatedPosition)->update(par);
	// server/zone/objects/player/PlayerObject.idl():  		serverLastMovementStamp.updateToCurrentTime();
	(&serverLastMovementStamp)->updateToCurrentTime();
}

unsigned int PlayerObjectImplementation::getAccountID() const{
	// server/zone/objects/player/PlayerObject.idl():  		return accountID;
	return accountID;
}

GalaxyAccountInfo* PlayerObjectImplementation::getGalaxyAccountInfo() const{
	// server/zone/objects/player/PlayerObject.idl():  		return galaxyAccountInfo;
	return galaxyAccountInfo;
}

unsigned long long PlayerObjectImplementation::getServerMovementTimeDelta() {
	// server/zone/objects/player/PlayerObject.idl():  		return serverLastMovementStamp.miliDifference();
	return (&serverLastMovementStamp)->miliDifference();
}

Time* PlayerObjectImplementation::getServerMovementTimeStamp() {
	// server/zone/objects/player/PlayerObject.idl():  		return serverLastMovementStamp;
	return (&serverLastMovementStamp);
}

void PlayerObjectImplementation::setClientLastMovementStamp(unsigned int stamp) {
	// server/zone/objects/player/PlayerObject.idl():  		clientLastMovementStamp = stamp;
	clientLastMovementStamp = stamp;
}

void PlayerObjectImplementation::updateServerLastMovementStamp() {
	// server/zone/objects/player/PlayerObject.idl():  		serverLastMovementStamp.updateToCurrentTime();
	(&serverLastMovementStamp)->updateToCurrentTime();
}

void PlayerObjectImplementation::setAccountID(unsigned int id) {
	// server/zone/objects/player/PlayerObject.idl():  		accountID = id;
	accountID = id;
}

unsigned int PlayerObjectImplementation::getClientLastMovementStamp() const{
	// server/zone/objects/player/PlayerObject.idl():  		return clientLastMovementStamp;
	return clientLastMovementStamp;
}

void PlayerObjectImplementation::addHologrindProfession(byte prof) {
	// server/zone/objects/player/PlayerObject.idl():  		hologrindProfessions.add(prof);
	(&hologrindProfessions)->add(prof);
}

Vector<byte>* PlayerObjectImplementation::getHologrindProfessions() {
	// server/zone/objects/player/PlayerObject.idl():  		return hologrindProfessions;
	return (&hologrindProfessions);
}

void PlayerObjectImplementation::setMaximumLots(byte lots) {
	// server/zone/objects/player/PlayerObject.idl():  		maximumLots = lots;
	maximumLots = lots;
}

byte PlayerObjectImplementation::getMaximumLots() const{
	// server/zone/objects/player/PlayerObject.idl():  		return maximumLots;
	return maximumLots;
}

String PlayerObjectImplementation::getStarterProfession() const{
	// server/zone/objects/player/PlayerObject.idl():  		return starterProfession;
	return starterProfession;
}

void PlayerObjectImplementation::setStarterProfession(String& profession) {
	// server/zone/objects/player/PlayerObject.idl():  		starterProfession = profession;
	starterProfession = profession;
}

unsigned long long PlayerObjectImplementation::getPerformanceBuffTarget() const{
	// server/zone/objects/player/PlayerObject.idl():  		return performanceBuffTarget;
	return performanceBuffTarget;
}

void PlayerObjectImplementation::setPerformanceBuffTarget(unsigned long long target) {
	// server/zone/objects/player/PlayerObject.idl():  		performanceBuffTarget = target;
	performanceBuffTarget = target;
}

void PlayerObjectImplementation::setDebug(bool value) {
	// server/zone/objects/player/PlayerObject.idl():  		debugOutput = value;
	debugOutput = value;
}

bool PlayerObjectImplementation::getDebug() const{
	// server/zone/objects/player/PlayerObject.idl():  		return debugOutput;
	return debugOutput;
}

float PlayerObjectImplementation::getVisibility() const{
	// server/zone/objects/player/PlayerObject.idl():  		return visibility;
	return visibility;
}

void PlayerObjectImplementation::setVisibility(float value) {
	// server/zone/objects/player/PlayerObject.idl():  		visibility = value;
	visibility = value;
	// server/zone/objects/player/PlayerObject.idl():  		lastVisibilityUpdateTimestamp.updateToCurrentTime();
	(&lastVisibilityUpdateTimestamp)->updateToCurrentTime();
}

void PlayerObjectImplementation::addVendor(SceneObject* vendor) {
	// server/zone/objects/player/PlayerObject.idl():  		ownedVendors.add(vendor.getObjectID());
	(&ownedVendors)->add(vendor->getObjectID());
}

void PlayerObjectImplementation::removeVendor(SceneObject* vendor) {
	// server/zone/objects/player/PlayerObject.idl():  		ownedVendors.removeElement(vendor.getObjectID());
	(&ownedVendors)->removeElement(vendor->getObjectID());
}

SortedVector<unsigned long long>* PlayerObjectImplementation::getOwnedVendors() {
	// server/zone/objects/player/PlayerObject.idl():  		return ownedVendors;
	return (&ownedVendors);
}

bool PlayerObjectImplementation::isJedi() const{
	// server/zone/objects/player/PlayerObject.idl():  		return jediState >= 2;
	return jediState >= 2;
}

bool PlayerObjectImplementation::isJediLight() {
	// server/zone/objects/player/PlayerObject.idl():  		return jediState == 4;
	return jediState == 4;
}

bool PlayerObjectImplementation::isJediDark() {
	// server/zone/objects/player/PlayerObject.idl():  		return jediState == 8;
	return jediState == 8;
}

bool PlayerObjectImplementation::isMuted() const{
	// server/zone/objects/player/PlayerObject.idl():  		return muted;
	return muted;
}

void PlayerObjectImplementation::setMutedState(bool mute) {
	// server/zone/objects/player/PlayerObject.idl():  		muted = mute;
	muted = mute;
}

String PlayerObjectImplementation::getMutedReason() const{
	// server/zone/objects/player/PlayerObject.idl():  		return mutedReason;
	return mutedReason;
}

void PlayerObjectImplementation::setMutedReason(String& reason) {
	// server/zone/objects/player/PlayerObject.idl():  		mutedReason = reason;
	mutedReason = reason;
}

String PlayerObjectImplementation::getInstalledHoloEmote() const{
	// server/zone/objects/player/PlayerObject.idl():  		return installedHoloEmote;
	return installedHoloEmote;
}

void PlayerObjectImplementation::setInstalledHoloEmote(String& holoEmote) {
	// server/zone/objects/player/PlayerObject.idl():  		installedHoloEmote = holoEmote;
	installedHoloEmote = holoEmote;
	// server/zone/objects/player/PlayerObject.idl():  		holoEmoteUseCount = 20;
	holoEmoteUseCount = 20;
}

void PlayerObjectImplementation::removeInstalledHoloEmote() {
	// server/zone/objects/player/PlayerObject.idl():  		installedHoloEmote = "";
	installedHoloEmote = "";
	// server/zone/objects/player/PlayerObject.idl():  		holoEmoteUseCount = 0;
	holoEmoteUseCount = 0;
}

int PlayerObjectImplementation::getHoloEmoteUseCount() const{
	// server/zone/objects/player/PlayerObject.idl():  		return holoEmoteUseCount;
	return holoEmoteUseCount;
}

void PlayerObjectImplementation::decreaseHoloEmoteUseCount() {
	// server/zone/objects/player/PlayerObject.idl():  		holoEmoteUseCount = holoEmoteUseCount - 1;
	holoEmoteUseCount = holoEmoteUseCount - 1;
	// server/zone/objects/player/PlayerObject.idl():  	}
	if (holoEmoteUseCount < 0)	// server/zone/objects/player/PlayerObject.idl():  			holoEmoteUseCount = 0;
	holoEmoteUseCount = 0;
}

bool PlayerObjectImplementation::isMarried() const{
	// server/zone/objects/player/PlayerObject.idl():  		return spouseName != "";
	return spouseName != "";
}

String PlayerObjectImplementation::getSpouseName() const{
	// server/zone/objects/player/PlayerObject.idl():  		return spouseName;
	return spouseName;
}

void PlayerObjectImplementation::setSpouseName(String& firstName) {
	// server/zone/objects/player/PlayerObject.idl():  		 spouseName = firstName;
	spouseName = firstName;
}

void PlayerObjectImplementation::removeSpouse() {
	// server/zone/objects/player/PlayerObject.idl():  		spouseName = "";
	spouseName = "";
}

Account* PlayerObjectImplementation::getAccount() {
	// server/zone/objects/player/PlayerObject.idl():  		return account;
	return account;
}

String PlayerObjectImplementation::getChosenVeteranReward(unsigned int milestone) {
	// server/zone/objects/player/PlayerObject.idl():  		return galaxyAccountInfo.getChosenVeteranReward(milestone);
	return galaxyAccountInfo->getChosenVeteranReward(milestone);
}

bool PlayerObjectImplementation::hasChosenVeteranReward(const String& rewardTemplate) {
	// server/zone/objects/player/PlayerObject.idl():  		return galaxyAccountInfo.hasChosenVeteranReward(rewardTemplate);
	return galaxyAccountInfo->hasChosenVeteranReward(rewardTemplate);
}

void PlayerObjectImplementation::clearVeteranReward(unsigned int milestone) {
	// server/zone/objects/player/PlayerObject.idl():  		galaxyAccountInfo.clearVeteranReward(milestone);
	galaxyAccountInfo->clearVeteranReward(milestone);
}

void PlayerObjectImplementation::addEventPerk(SceneObject* deed) {
	// server/zone/objects/player/PlayerObject.idl():  		currentEventPerks.put(deed.getObjectID());
	(&currentEventPerks)->put(deed->getObjectID());
}

void PlayerObjectImplementation::removeEventPerk(SceneObject* deed) {
	// server/zone/objects/player/PlayerObject.idl():  		currentEventPerks.drop(deed.getObjectID());
	(&currentEventPerks)->drop(deed->getObjectID());
}

int PlayerObjectImplementation::getEventPerkCount() {
	// server/zone/objects/player/PlayerObject.idl():  		return currentEventPerks.size();
	return (&currentEventPerks)->size();
}

void PlayerObjectImplementation::addToReactionFines(int fine) {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFines = reactionFines + fine;
	reactionFines = reactionFines + fine;
}

void PlayerObjectImplementation::setReactionFines(int amount) {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFines = amount;
	reactionFines = amount;
}

void PlayerObjectImplementation::subtractFromReactionFines(int amount) {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFines = reactionFines - amount;
	reactionFines = reactionFines - amount;
}

void PlayerObjectImplementation::updateReactionFineTimestamp() {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFineTimestamp.updateToCurrentTime();
	(&reactionFineTimestamp)->updateToCurrentTime();
}

void PlayerObjectImplementation::updateReactionFineMailTimestamp() {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFineMailTimestamp.updateToCurrentTime();
	(&reactionFineMailTimestamp)->updateToCurrentTime();
}

Time* PlayerObjectImplementation::getReactionFineTimestamp() {
	// server/zone/objects/player/PlayerObject.idl():  		return reactionFineTimestamp;
	return (&reactionFineTimestamp);
}

Time* PlayerObjectImplementation::getReactionFineMailTimestamp() {
	// server/zone/objects/player/PlayerObject.idl():  		return reactionFineMailTimestamp;
	return (&reactionFineMailTimestamp);
}

int PlayerObjectImplementation::getXpCap(const String& type) {
	// server/zone/objects/player/PlayerObject.idl():  		return xpTypeCapList.get(type);
	return (&xpTypeCapList)->get(type);
}

bool PlayerObjectImplementation::hasSchematic(DraftSchematic* schematic) {
	// server/zone/objects/player/PlayerObject.idl():  		return schematicList.contains(schematic);
	return (&schematicList)->contains(schematic);
}

void PlayerObjectImplementation::addToKillerList(unsigned int playerID) {
	// server/zone/objects/player/PlayerObject.idl():  		newKillerList.
	if ((&lastPvpRatingUpdate)->miliDifference() >= PVP_RESET_TIME && (&newKillerList)->size() > 0)	// server/zone/objects/player/PlayerObject.idl():  			newKillerList.removeAll();
	(&newKillerList)->removeAll();
	// server/zone/objects/player/PlayerObject.idl():  		newKillerList.add(0, playerID);
	(&newKillerList)->add(0, playerID);
	// server/zone/objects/player/PlayerObject.idl():  		lastPvpRatingUpdate.
	if ((&newKillerList)->size() > 20)	// server/zone/objects/player/PlayerObject.idl():  			newKillerList.remove(newKillerList.size() - 1);
	(&newKillerList)->remove((&newKillerList)->size() - 1);
	// server/zone/objects/player/PlayerObject.idl():  		lastPvpRatingUpdate.updateToCurrentTime();
	(&lastPvpRatingUpdate)->updateToCurrentTime();
}

bool PlayerObjectImplementation::hasOnKillerList(unsigned int playerID) {
	// server/zone/objects/player/PlayerObject.idl():  		return 
	if ((&lastPvpRatingUpdate)->miliDifference() >= PVP_RESET_TIME && (&newKillerList)->size() > 0){
	// server/zone/objects/player/PlayerObject.idl():  			newKillerList.removeAll();
	(&newKillerList)->removeAll();
	// server/zone/objects/player/PlayerObject.idl():  			return false;
	return false;
}
	// server/zone/objects/player/PlayerObject.idl():  		return newKillerList.contains(playerID);
	return (&newKillerList)->contains(playerID);
}

int PlayerObjectImplementation::getPvpRating() const{
	// server/zone/objects/player/PlayerObject.idl():  		return 
	if (pvpRating == 0)	// server/zone/objects/player/PlayerObject.idl():  			return 1200;
	return 1200;
	// server/zone/objects/player/PlayerObject.idl():  		return pvpRating;
	return pvpRating;
}

void PlayerObjectImplementation::setPvpRating(int rating) {
	// server/zone/objects/player/PlayerObject.idl():  		pvpRating 
	if (rating < PVP_RATING_FLOOR)	// server/zone/objects/player/PlayerObject.idl():  			rating = PVP_RATING_FLOOR;
	rating = PVP_RATING_FLOOR;
	// server/zone/objects/player/PlayerObject.idl():  		pvpRating = rating;
	pvpRating = rating;
}

/*
 *	PlayerObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


PlayerObjectAdapter::PlayerObjectAdapter(PlayerObject* obj) : IntangibleObjectAdapter(obj) {
}

void PlayerObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_FINALIZE__:
		{
			
			finalize();
			
		}
		break;
	case RPC_SETCLIENTPATHWAYPOINT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setClientPathWaypoint(obj);
			
		}
		break;
	case RPC_INITIALIZEACCOUNT__:
		{
			
			initializeAccount();
			
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_UNLOAD__:
		{
			
			unload();
			
		}
		break;
	case RPC_CALCULATEBHREWARD__:
		{
			
			int _m_res = calculateBhReward();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_SENDMESSAGE__BASEPACKET_:
		{
			BasePacket* msg = static_cast<BasePacket*>(inv->getObjectParameter());
			
			sendMessage(msg);
			
		}
		break;
	case RPC_ADDOWNEDSTRUCTURE__STRUCTUREOBJECT_:
		{
			StructureObject* obj = static_cast<StructureObject*>(inv->getObjectParameter());
			
			addOwnedStructure(obj);
			
		}
		break;
	case RPC_REMOVEOWNEDSTRUCTURE__STRUCTUREOBJECT_:
		{
			StructureObject* obj = static_cast<StructureObject*>(inv->getObjectParameter());
			
			removeOwnedStructure(obj);
			
		}
		break;
	case RPC_GETTOTALOWNEDSTRUCTURECOUNT__:
		{
			
			int _m_res = getTotalOwnedStructureCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISOWNEDSTRUCTURE__STRUCTUREOBJECT_:
		{
			StructureObject* obj = static_cast<StructureObject*>(inv->getObjectParameter());
			
			bool _m_res = isOwnedStructure(obj);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETOWNEDSTRUCTURE__INT_:
		{
			int i = inv->getSignedIntParameter();
			
			unsigned long long _m_res = getOwnedStructure(i);
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETLOTSREMAINING__:
		{
			
			int _m_res = getLotsRemaining();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASLOTSREMAINING__INT_:
		{
			int lots = inv->getSignedIntParameter();
			
			bool _m_res = hasLotsRemaining(lots);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_NOTIFYSCENEREADY__:
		{
			
			notifySceneReady();
			
		}
		break;
	case RPC_CHECKPENDINGMESSAGES__:
		{
			
			checkPendingMessages();
			
		}
		break;
	case RPC_ADDEXPERIENCE__STRING_INT_BOOL_:
		{
			 String xpType; inv->getAsciiParameter(xpType);
			int xp = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			int _m_res = addExperience(xpType, xp, notifyClient);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_REMOVEEXPERIENCE__STRING_BOOL_:
		{
			 String xpType; inv->getAsciiParameter(xpType);
			bool notifyClient = inv->getBooleanParameter();
			
			removeExperience(xpType, notifyClient);
			
		}
		break;
	case RPC_HASCAPPEDEXPERIENCE__STRING_:
		{
			 String xpType; inv->getAsciiParameter(xpType);
			
			bool _m_res = hasCappedExperience(xpType);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDWAYPOINT__WAYPOINTOBJECT_BOOL_BOOL_:
		{
			WaypointObject* waypoint = static_cast<WaypointObject*>(inv->getObjectParameter());
			bool checkName = inv->getBooleanParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addWaypoint(waypoint, checkName, notifyClient);
			
		}
		break;
	case RPC_SETWAYPOINT__WAYPOINTOBJECT_BOOL_:
		{
			WaypointObject* waypoint = static_cast<WaypointObject*>(inv->getObjectParameter());
			bool notifyClient = inv->getBooleanParameter();
			
			setWaypoint(waypoint, notifyClient);
			
		}
		break;
	case RPC_REMOVEWAYPOINT__LONG_BOOL_BOOL_:
		{
			unsigned long long waypointID = inv->getUnsignedLongParameter();
			bool notifyClient = inv->getBooleanParameter();
			bool destroy = inv->getBooleanParameter();
			
			removeWaypoint(waypointID, notifyClient, destroy);
			
		}
		break;
	case RPC_UPDATEWAYPOINT__LONG_:
		{
			unsigned long long waypointID = inv->getUnsignedLongParameter();
			
			updateWaypoint(waypointID);
			
		}
		break;
	case RPC_REMOVEWAYPOINTBYSPECIALTYPE__INT_BOOL_:
		{
			int specialTypeID = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			removeWaypointBySpecialType(specialTypeID, notifyClient);
			
		}
		break;
	case RPC_GETWAYPOINTBYSPECIALTYPE__INT_:
		{
			int specialTypeID = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getWaypointBySpecialType(specialTypeID);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETSURVEYWAYPOINT__:
		{
			
			DistributedObject* _m_res = getSurveyWaypoint();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_HASWAYPOINT__LONG_:
		{
			unsigned long long objectID = inv->getUnsignedLongParameter();
			
			bool _m_res = hasWaypoint(objectID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETWAYPOINTAT__FLOAT_FLOAT_STRING_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			String planet; inv->getAsciiParameter(planet);
			
			DistributedObject* _m_res = getWaypointAt(x, y, planet);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_INSERTWAYPOINTLISTTOMESSAGE__BASEMESSAGE_:
		{
			BaseMessage* msg = static_cast<BaseMessage*>(inv->getObjectParameter());
			
			insertWaypointListToMessage(msg);
			
		}
		break;
	case RPC_GETWAYPOINTLISTSIZE__:
		{
			
			int _m_res = getWaypointListSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETWAYPOINT__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getWaypoint(index);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_SETLANGUAGEID__BYTE_BOOL_:
		{
			byte language = inv->getByteParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setLanguageID(language, notifyClient);
			
		}
		break;
	case RPC_ADDFRIEND__STRING_BOOL_:
		{
			 String name; inv->getAsciiParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			addFriend(name, notifyClient);
			
		}
		break;
	case RPC_REMOVEFRIEND__STRING_BOOL_:
		{
			 String name; inv->getAsciiParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			removeFriend(name, notifyClient);
			
		}
		break;
	case RPC_REMOVEALLREVERSEFRIENDS__STRING_:
		{
			 String oldName; inv->getAsciiParameter(oldName);
			
			removeAllReverseFriends(oldName);
			
		}
		break;
	case RPC_ADDIGNORE__STRING_BOOL_:
		{
			 String name; inv->getAsciiParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			addIgnore(name, notifyClient);
			
		}
		break;
	case RPC_REMOVEIGNORE__STRING_BOOL_:
		{
			 String name; inv->getAsciiParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			removeIgnore(name, notifyClient);
			
		}
		break;
	case RPC_SETTITLE__STRING_BOOL_:
		{
			 String characterTitle; inv->getAsciiParameter(characterTitle);
			bool notifyClient = inv->getBooleanParameter();
			
			setTitle(characterTitle, notifyClient);
			
		}
		break;
	case RPC_SETFOODFILLING__INT_BOOL_:
		{
			int newValue = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setFoodFilling(newValue, notifyClient);
			
		}
		break;
	case RPC_SETDRINKFILLING__INT_BOOL_:
		{
			int newValue = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setDrinkFilling(newValue, notifyClient);
			
		}
		break;
	case RPC_INCREASEFACTIONSTANDING__STRING_FLOAT_:
		{
			 String factionName; inv->getAsciiParameter(factionName);
			float amount = inv->getFloatParameter();
			
			increaseFactionStanding(factionName, amount);
			
		}
		break;
	case RPC_DECREASEFACTIONSTANDING__STRING_FLOAT_:
		{
			 String factionName; inv->getAsciiParameter(factionName);
			float amount = inv->getFloatParameter();
			
			decreaseFactionStanding(factionName, amount);
			
		}
		break;
	case RPC_SETFACTIONSTANDING__STRING_FLOAT_:
		{
			 String factionName; inv->getAsciiParameter(factionName);
			float amount = inv->getFloatParameter();
			
			setFactionStanding(factionName, amount);
			
		}
		break;
	case RPC_GETFACTIONSTANDING__STRING_:
		{
			 String factionName; inv->getAsciiParameter(factionName);
			
			float _m_res = getFactionStanding(factionName);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETSCREENPLAYDATA__STRING_STRING_STRING_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			 String variable; inv->getAsciiParameter(variable);
			 String data; inv->getAsciiParameter(data);
			
			setScreenPlayData(screenPlay, variable, data);
			
		}
		break;
	case RPC_DELETESCREENPLAYDATA__STRING_STRING_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			 String variable; inv->getAsciiParameter(variable);
			
			deleteScreenPlayData(screenPlay, variable);
			
		}
		break;
	case RPC_GETSCREENPLAYDATA__STRING_STRING_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			 String variable; inv->getAsciiParameter(variable);
			
			String _m_res = getScreenPlayData(screenPlay, variable);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_CLEARSCREENPLAYDATA__STRING_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			
			clearScreenPlayData(screenPlay);
			
		}
		break;
	case RPC_ACTIVATERECOVERY__:
		{
			
			activateRecovery();
			
		}
		break;
	case RPC_ACTIVATEFORCEPOWERREGEN__:
		{
			
			activateForcePowerRegen();
			
		}
		break;
	case RPC_DORECOVERY__INT_:
		{
			int latency = inv->getSignedIntParameter();
			
			doRecovery(latency);
			
		}
		break;
	case RPC_DISCONNECT__BOOL_BOOL_:
		{
			bool closeClient = inv->getBooleanParameter();
			bool doLock = inv->getBooleanParameter();
			
			disconnect(closeClient, doLock);
			
		}
		break;
	case RPC_RELOAD__ZONECLIENTSESSION_:
		{
			ZoneClientSession* client = static_cast<ZoneClientSession*>(inv->getObjectParameter());
			
			reload(client);
			
		}
		break;
	case RPC_SETOFFLINE__:
		{
			
			setOffline();
			
		}
		break;
	case RPC_SETLINKDEAD__BOOL_:
		{
			bool isSafeLogout = inv->getBooleanParameter();
			
			setLinkDead(isSafeLogout);
			
		}
		break;
	case RPC_SETONLINE__:
		{
			
			setOnline();
			
		}
		break;
	case RPC_SETLOGGINGOUT__:
		{
			
			setLoggingOut();
			
		}
		break;
	case RPC_SENDBADGESRESPONSETO__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendBadgesResponseTo(player);
			
		}
		break;
	case RPC_LOGOUT__BOOL_:
		{
			bool doLock = inv->getBooleanParameter();
			
			logout(doLock);
			
		}
		break;
	case RPC_SETJEDISTATE__INT_BOOL_:
		{
			int state = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setJediState(state, notifyClient);
			
		}
		break;
	case RPC_SETACTIVEQUESTSBIT__INT_BYTE_BOOL_:
		{
			int bitIndex = inv->getSignedIntParameter();
			byte value = inv->getByteParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setActiveQuestsBit(bitIndex, value, notifyClient);
			
		}
		break;
	case RPC_CLEARACTIVEQUESTSBIT__INT_BOOL_:
		{
			int bitIndex = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			clearActiveQuestsBit(bitIndex, notifyClient);
			
		}
		break;
	case RPC_CANACTIVATEQUEST__INT_:
		{
			int questID = inv->getSignedIntParameter();
			
			bool _m_res = canActivateQuest(questID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ACTIVATEQUEST__INT_:
		{
			int questID = inv->getSignedIntParameter();
			
			activateQuest(questID);
			
		}
		break;
	case RPC_HASACTIVEQUESTBITSET__INT_:
		{
			int bitIndex = inv->getSignedIntParameter();
			
			bool _m_res = hasActiveQuestBitSet(bitIndex);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASCOMPLETEDQUESTSBITSET__INT_:
		{
			int bitIndex = inv->getSignedIntParameter();
			
			bool _m_res = hasCompletedQuestsBitSet(bitIndex);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCOMPLETEDQUESTSBIT__INT_BYTE_BOOL_:
		{
			int bitIndex = inv->getSignedIntParameter();
			byte value = inv->getByteParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCompletedQuestsBit(bitIndex, value, notifyClient);
			
		}
		break;
	case RPC_CLEARCOMPLETEDQUESTSBIT__INT_BOOL_:
		{
			int bitIndex = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			clearCompletedQuestsBit(bitIndex, notifyClient);
			
		}
		break;
	case RPC_COMPLETEQUEST__INT_:
		{
			int questID = inv->getSignedIntParameter();
			
			completeQuest(questID);
			
		}
		break;
	case RPC_HASQUESTDATA__INT_:
		{
			unsigned int questHashCode = inv->getUnsignedIntParameter();
			
			bool _m_res = hasQuestData(questHashCode);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETLASTNPCCONVSTR__STRING_:
		{
			 String conv; inv->getAsciiParameter(conv);
			
			setLastNpcConvStr(conv);
			
		}
		break;
	case RPC_SETLASTNPCCONVMESSSTR__STRING_:
		{
			 String mess; inv->getAsciiParameter(mess);
			
			setLastNpcConvMessStr(mess);
			
		}
		break;
	case RPC_GETLASTNPCCONVSTR__:
		{
			
			String _m_res = getLastNpcConvStr();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETLASTNPCCONVMESSSTR__:
		{
			
			String _m_res = getLastNpcConvMessStr();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETLASTNPCCONVOPTION__INT_:
		{
			int idx = inv->getSignedIntParameter();
			
			String _m_res = getLastNpcConvOption(idx);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ADDLASTNPCCONVOPTIONS__STRING_:
		{
			 String option; inv->getAsciiParameter(option);
			
			addLastNpcConvOptions(option);
			
		}
		break;
	case RPC_COUNTLASTNPCCONVOPTIONS__:
		{
			
			int _m_res = countLastNpcConvOptions();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CLEARLASTNPCCONVOPTIONS__:
		{
			
			clearLastNpcConvOptions();
			
		}
		break;
	case RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			setConversatingCreature(creature);
			
		}
		break;
	case RPC_GETCONVERSATINGCREATURE__:
		{
			
			unsigned long long _m_res = getConversatingCreature();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETTRAINERZONENAME__STRING_:
		{
			String zoneName; inv->getAsciiParameter(zoneName);
			
			setTrainerZoneName(zoneName);
			
		}
		break;
	case RPC_GETTRAINERZONENAME__:
		{
			
			String _m_res = getTrainerZoneName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ADDPERSISTENTMESSAGE__LONG_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			
			addPersistentMessage(id);
			
		}
		break;
	case RPC_DROPPERSISTENTMESSAGE__LONG_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			
			dropPersistentMessage(id);
			
		}
		break;
	case RPC_UNLOADSPAWNEDCHILDREN__:
		{
			
			unloadSpawnedChildren();
			
		}
		break;
	case RPC_ADDTOCONSENTLIST__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			addToConsentList(name);
			
		}
		break;
	case RPC_HASINCONSENTLIST__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			bool _m_res = hasInConsentList(name);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_REMOVEFROMCONSENTLIST__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			removeFromConsentList(name);
			
		}
		break;
	case RPC_GETCONSENTNAME__INT_:
		{
			int i = inv->getSignedIntParameter();
			
			String _m_res = getConsentName(i);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETCONSENTLISTSIZE__:
		{
			
			int _m_res = getConsentListSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETREACTIONFINES__:
		{
			
			int _m_res = getReactionFines();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETCOMMANDMESSAGESTRING__INT_STRING_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			String message; inv->getAsciiParameter(message);
			
			setCommandMessageString(actionCRC, message);
			
		}
		break;
	case RPC_REMOVECOMMANDMESSAGESTRING__INT_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			
			removeCommandMessageString(actionCRC);
			
		}
		break;
	case RPC_GETDECLAREDRESIDENCE__:
		{
			
			unsigned long long _m_res = getDeclaredResidence();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_:
		{
			BuildingObject* residence = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			setDeclaredResidence(residence);
			
		}
		break;
	case RPC_SETCLONINGFACILITY__BUILDINGOBJECT_:
		{
			BuildingObject* cloningfac = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			setCloningFacility(cloningfac);
			
		}
		break;
	case RPC_GETCLONINGFACILITY__:
		{
			
			unsigned long long _m_res = getCloningFacility();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_NOTIFYONLINE__:
		{
			
			notifyOnline();
			
		}
		break;
	case RPC_DODIGEST__INT_:
		{
			int fillingReduction = inv->getSignedIntParameter();
			
			doDigest(fillingReduction);
			
		}
		break;
	case RPC_ISDIGESTING__:
		{
			
			bool _m_res = isDigesting();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSAVEDTERRAINNAME__:
		{
			
			String _m_res = getSavedTerrainName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETSAVEDPARENTID__LONG_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			
			setSavedParentID(id);
			
		}
		break;
	case RPC_SETSAVEDTERRAINNAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			setSavedTerrainName(name);
			
		}
		break;
	case RPC_SETFORCEPOWER__INT_BOOL_:
		{
			int fp = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setForcePower(fp, notifyClient);
			
		}
		break;
	case RPC_SETFORCEPOWERMAX__INT_BOOL_:
		{
			int newValue = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setForcePowerMax(newValue, notifyClient);
			
		}
		break;
	case RPC_DOFORCEREGEN__:
		{
			
			doForceRegen();
			
		}
		break;
	case RPC_GETFORCEPOWERREGEN__:
		{
			
			int _m_res = getForcePowerRegen();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSAVEDPARENTID__:
		{
			
			unsigned long long _m_res = getSavedParentID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETNEWSUIBOXID__INT_:
		{
			unsigned int type = inv->getUnsignedIntParameter();
			
			unsigned int _m_res = getNewSuiBoxID(type);
			resp->insertInt(_m_res);
		}
		break;
	case RPC_HASSUIBOX__INT_:
		{
			unsigned int boxID = inv->getUnsignedIntParameter();
			
			bool _m_res = hasSuiBox(boxID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSUIBOX__INT_:
		{
			unsigned int boxID = inv->getUnsignedIntParameter();
			
			DistributedObject* _m_res = getSuiBox(boxID);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_REMOVESUIBOX__INT_BOOL_:
		{
			unsigned int boxID = inv->getUnsignedIntParameter();
			bool closeWindowToClient = inv->getBooleanParameter();
			
			removeSuiBox(boxID, closeWindowToClient);
			
		}
		break;
	case RPC_REMOVESUIBOXTYPE__INT_:
		{
			unsigned int windowType = inv->getUnsignedIntParameter();
			
			removeSuiBoxType(windowType);
			
		}
		break;
	case RPC_HASSUIBOXWINDOWTYPE__INT_:
		{
			unsigned int windowType = inv->getUnsignedIntParameter();
			
			bool _m_res = hasSuiBoxWindowType(windowType);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLOSESUIWINDOWTYPE__INT_:
		{
			unsigned int windowType = inv->getUnsignedIntParameter();
			
			closeSuiWindowType(windowType);
			
		}
		break;
	case RPC_GETSUIBOXFROMWINDOWTYPE__INT_:
		{
			unsigned int windowType = inv->getUnsignedIntParameter();
			
			DistributedObject* _m_res = getSuiBoxFromWindowType(windowType);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_ADDSUIBOX__SUIBOX_:
		{
			SuiBox* sui = static_cast<SuiBox*>(inv->getObjectParameter());
			
			addSuiBox(sui);
			
		}
		break;
	case RPC_ADDPERMISSIONGROUP__STRING_BOOL_:
		{
			 String group; inv->getAsciiParameter(group);
			bool updatePermissions = inv->getBooleanParameter();
			
			addPermissionGroup(group, updatePermissions);
			
		}
		break;
	case RPC_REMOVEPERMISSIONGROUP__STRING_BOOL_:
		{
			 String group; inv->getAsciiParameter(group);
			bool updatePermissions = inv->getBooleanParameter();
			
			removePermissionGroup(group, updatePermissions);
			
		}
		break;
	case RPC_UPDATEINRANGEBUILDINGPERMISSIONS__:
		{
			
			updateInRangeBuildingPermissions();
			
		}
		break;
	case RPC_HASPERMISSIONGROUP__STRING_:
		{
			 String group; inv->getAsciiParameter(group);
			
			bool _m_res = hasPermissionGroup(group);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDINCAPACITATIONTIME__:
		{
			
			addIncapacitationTime();
			
		}
		break;
	case RPC_GETINCAPACITATIONCOUNTER__:
		{
			
			byte _m_res = getIncapacitationCounter();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_RESETINCAPACITATIONTIMES__:
		{
			
			resetIncapacitationTimes();
			
		}
		break;
	case RPC_ADDTODUELLIST__CREATUREOBJECT_:
		{
			CreatureObject* targetPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			addToDuelList(targetPlayer);
			
		}
		break;
	case RPC_REMOVEFROMDUELLIST__CREATUREOBJECT_:
		{
			CreatureObject* targetPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			removeFromDuelList(targetPlayer);
			
		}
		break;
	case RPC_GETDUELLISTOBJECT__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getDuelListObject(index);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_REQUESTEDDUELTO__CREATUREOBJECT_:
		{
			CreatureObject* targetPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = requestedDuelTo(targetPlayer);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISDUELLISTEMPTY__:
		{
			
			bool _m_res = isDuelListEmpty();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETDUELLISTSIZE__:
		{
			
			int _m_res = getDuelListSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ADDTOACTIVEPETS__AIAGENT_:
		{
			AiAgent* pet = static_cast<AiAgent*>(inv->getObjectParameter());
			
			addToActivePets(pet);
			
		}
		break;
	case RPC_REMOVEFROMACTIVEPETS__AIAGENT_:
		{
			AiAgent* pet = static_cast<AiAgent*>(inv->getObjectParameter());
			
			removeFromActivePets(pet);
			
		}
		break;
	case RPC_GETACTIVEPET__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getActivePet(index);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_HASACTIVEPET__AIAGENT_:
		{
			AiAgent* pet = static_cast<AiAgent*>(inv->getObjectParameter());
			
			bool _m_res = hasActivePet(pet);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETACTIVEPETSSIZE__:
		{
			
			int _m_res = getActivePetsSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBIOGRAPHY__:
		{
			
			UnicodeString _m_res = getBiography();
			resp->insertUnicode(_m_res);
		}
		break;
	case RPC_NOTIFYOFFLINE__:
		{
			
			notifyOffline();
			
		}
		break;
	case RPC_SETBADGE__INT_:
		{
			unsigned int badge = inv->getUnsignedIntParameter();
			
			setBadge(badge);
			
		}
		break;
	case RPC_AWARDBADGE__INT_:
		{
			unsigned int badge = inv->getUnsignedIntParameter();
			
			awardBadge(badge);
			
		}
		break;
	case RPC_SETTELEPORTING__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setTeleporting(val);
			
		}
		break;
	case RPC_SETONLOADSCREEN__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setOnLoadScreen(val);
			
		}
		break;
	case RPC_GETNUMBADGES__:
		{
			
			int _m_res = getNumBadges();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBADGETYPECOUNT__INT_:
		{
			unsigned int type = inv->getUnsignedIntParameter();
			
			int _m_res = getBadgeTypeCount(type);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASFRIEND__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			bool _m_res = hasFriend(name);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETFRIENDLISTSIZE__:
		{
			
			int _m_res = getFriendListSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISIGNORING__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			bool _m_res = isIgnoring(name);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDREVERSEFRIEND__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			addReverseFriend(name);
			
		}
		break;
	case RPC_REMOVEREVERSEFRIEND__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			removeReverseFriend(name);
			
		}
		break;
	case RPC_SENDFRIENDLISTS__:
		{
			
			sendFriendLists();
			
		}
		break;
	case RPC_HASCOMMANDMESSAGESTRING__INT_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			
			bool _m_res = hasCommandMessageString(actionCRC);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETCHARACTERBITMASK__:
		{
			
			unsigned int _m_res = getCharacterBitmask();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETTITLE__:
		{
			
			String _m_res = getTitle();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETADMINLEVEL__:
		{
			
			unsigned int _m_res = getAdminLevel();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETADMINLEVEL__INT_:
		{
			unsigned int adminlvl = inv->getUnsignedIntParameter();
			
			setAdminLevel(adminlvl);
			
		}
		break;
	case RPC_GETPRIVILEDGEFLAG__:
		{
			
			int _m_res = getPriviledgeFlag();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETPRIVILEDGEFLAG__INT_:
		{
			int flag = inv->getSignedIntParameter();
			
			setPriviledgeFlag(flag);
			
		}
		break;
	case RPC_SETBIOGRAPHY__UNICODESTRING_:
		{
			 UnicodeString bio; inv->getUnicodeParameter(bio);
			
			setBiography(bio);
			
		}
		break;
	case RPC_HASGODMODE__:
		{
			
			bool _m_res = hasGodMode();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPRIVILEGED__:
		{
			
			bool _m_res = isPrivileged();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSTAFF__:
		{
			
			bool _m_res = isStaff();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISADMIN__:
		{
			
			bool _m_res = isAdmin();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCHARACTERBITMASK__INT_:
		{
			unsigned int bitmask = inv->getUnsignedIntParameter();
			
			setCharacterBitmask(bitmask);
			
		}
		break;
	case RPC_SETCHARACTERBIT__INT_BOOL_:
		{
			unsigned int bit = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			bool _m_res = setCharacterBit(bit, notifyClient);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARCHARACTERBIT__INT_BOOL_:
		{
			unsigned int bit = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			bool _m_res = clearCharacterBit(bit, notifyClient);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_TOGGLECHARACTERBIT__INT_:
		{
			unsigned int bit = inv->getUnsignedIntParameter();
			
			toggleCharacterBit(bit);
			
		}
		break;
	case RPC_ISLFG__:
		{
			
			bool _m_res = isLFG();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISAFK__:
		{
			
			bool _m_res = isAFK();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISANONYMOUS__:
		{
			
			bool _m_res = isAnonymous();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISROLEPLAYER__:
		{
			
			bool _m_res = isRoleplayer();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNEWBIEHELPER__:
		{
			
			bool _m_res = isNewbieHelper();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETFORCEPOWER__:
		{
			
			int _m_res = getForcePower();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFORCEPOWERMAX__:
		{
			
			int _m_res = getForcePowerMax();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSCHEMATIC__INT_:
		{
			int i = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getSchematic(i);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETFOODFILLING__:
		{
			
			int _m_res = getFoodFilling();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFOODFILLINGMAX__:
		{
			
			int _m_res = getFoodFillingMax();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDRINKFILLING__:
		{
			
			int _m_res = getDrinkFilling();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDRINKFILLINGMAX__:
		{
			
			int _m_res = getDrinkFillingMax();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETJEDISTATE__:
		{
			
			int _m_res = getJediState();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETLANGUAGEID__:
		{
			
			byte _m_res = getLanguageID();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_ISTELEPORTING__:
		{
			
			bool _m_res = isTeleporting();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISONLOADSCREEN__:
		{
			
			bool _m_res = isOnLoadScreen();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDCHATROOM__INT_:
		{
			unsigned int roomID = inv->getUnsignedIntParameter();
			
			addChatRoom(roomID);
			
		}
		break;
	case RPC_REMOVECHATROOM__INT_:
		{
			unsigned int roomID = inv->getUnsignedIntParameter();
			
			removeChatRoom(roomID);
			
		}
		break;
	case RPC_ADDOWNEDCHATROOM__INT_:
		{
			unsigned int roomID = inv->getUnsignedIntParameter();
			
			addOwnedChatRoom(roomID);
			
		}
		break;
	case RPC_REMOVEOWNEDCHATROOM__INT_:
		{
			unsigned int roomID = inv->getUnsignedIntParameter();
			
			removeOwnedChatRoom(roomID);
			
		}
		break;
	case RPC_GETOWNEDCHATROOMCOUNT__:
		{
			
			int _m_res = getOwnedChatRoomCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETBANKLOCATION__STRING_:
		{
			 String location; inv->getAsciiParameter(location);
			
			setBankLocation(location);
			
		}
		break;
	case RPC_GETBANKLOCATION__:
		{
			
			String _m_res = getBankLocation();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETEXPERIENCE__STRING_:
		{
			 String xp; inv->getAsciiParameter(xp);
			
			int _m_res = getExperience(xp);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_MAXIMIZEEXPERIENCE__:
		{
			
			maximizeExperience();
			
		}
		break;
	case RPC_ACTIVATEMISSIONS__:
		{
			
			activateMissions();
			
		}
		break;
	case RPC_GETCOMMANDMESSAGESTRING__INT_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			
			String _m_res = getCommandMessageString(actionCRC);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_HASBADGE__INT_:
		{
			unsigned int badge = inv->getUnsignedIntParameter();
			
			bool _m_res = hasBadge(badge);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARDISCONNECTEVENT__:
		{
			
			clearDisconnectEvent();
			
		}
		break;
	case RPC_ISONLINE__:
		{
			
			bool _m_res = isOnline();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISOFFLINE__:
		{
			
			bool _m_res = isOffline();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISLOADING__:
		{
			
			bool _m_res = isLoading();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISLINKDEAD__:
		{
			
			bool _m_res = isLinkDead();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISLOGGINGIN__:
		{
			
			bool _m_res = isLoggingIn();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISLOGGINGOUT__:
		{
			
			bool _m_res = isLoggingOut();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETSKILLPOINTS__INT_:
		{
			int points = inv->getSignedIntParameter();
			
			setSkillPoints(points);
			
		}
		break;
	case RPC_ADDSKILLPOINTS__INT_:
		{
			int points = inv->getSignedIntParameter();
			
			addSkillPoints(points);
			
		}
		break;
	case RPC_GETSKILLPOINTS__:
		{
			
			int _m_res = getSkillPoints();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_UPDATELASTVALIDATEDPOSITION__:
		{
			
			updateLastValidatedPosition();
			
		}
		break;
	case RPC_GETACCOUNTID__:
		{
			
			unsigned int _m_res = getAccountID();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETSERVERMOVEMENTTIMEDELTA__:
		{
			
			unsigned long long _m_res = getServerMovementTimeDelta();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_:
		{
			unsigned int stamp = inv->getUnsignedIntParameter();
			
			setClientLastMovementStamp(stamp);
			
		}
		break;
	case RPC_UPDATESERVERLASTMOVEMENTSTAMP__:
		{
			
			updateServerLastMovementStamp();
			
		}
		break;
	case RPC_SETACCOUNTID__INT_:
		{
			unsigned int id = inv->getUnsignedIntParameter();
			
			setAccountID(id);
			
		}
		break;
	case RPC_GETCLIENTLASTMOVEMENTSTAMP__:
		{
			
			unsigned int _m_res = getClientLastMovementStamp();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_ADDHOLOGRINDPROFESSION__BYTE_:
		{
			byte prof = inv->getByteParameter();
			
			addHologrindProfession(prof);
			
		}
		break;
	case RPC_SETMAXIMUMLOTS__BYTE_:
		{
			byte lots = inv->getByteParameter();
			
			setMaximumLots(lots);
			
		}
		break;
	case RPC_GETMAXIMUMLOTS__:
		{
			
			byte _m_res = getMaximumLots();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_GETSTARTERPROFESSION__:
		{
			
			String _m_res = getStarterProfession();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETSTARTERPROFESSION__STRING_:
		{
			String profession; inv->getAsciiParameter(profession);
			
			setStarterProfession(profession);
			
		}
		break;
	case RPC_GETPERFORMANCEBUFFTARGET__:
		{
			
			unsigned long long _m_res = getPerformanceBuffTarget();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETPERFORMANCEBUFFTARGET__LONG_:
		{
			unsigned long long target = inv->getUnsignedLongParameter();
			
			setPerformanceBuffTarget(target);
			
		}
		break;
	case RPC_SETDEBUG__BOOL_:
		{
			bool value = inv->getBooleanParameter();
			
			setDebug(value);
			
		}
		break;
	case RPC_GETDEBUG__:
		{
			
			bool _m_res = getDebug();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETVISIBILITY__:
		{
			
			float _m_res = getVisibility();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETVISIBILITY__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setVisibility(value);
			
		}
		break;
	case RPC_UPDATELASTPVPCOMBATACTIONTIMESTAMP__BOOL_BOOL_:
		{
			bool updateGcwAction = inv->getBooleanParameter();
			bool updateBhAction = inv->getBooleanParameter();
			
			updateLastPvpCombatActionTimestamp(updateGcwAction, updateBhAction);
			
		}
		break;
	case RPC_UPDATELASTBHPVPCOMBATACTIONTIMESTAMP__:
		{
			
			updateLastBhPvpCombatActionTimestamp();
			
		}
		break;
	case RPC_UPDATELASTGCWPVPCOMBATACTIONTIMESTAMP__:
		{
			
			updateLastGcwPvpCombatActionTimestamp();
			
		}
		break;
	case RPC_HASPVPTEF__:
		{
			
			bool _m_res = hasPvpTef();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASBHTEF__:
		{
			
			bool _m_res = hasBhTef();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_BOOL_:
		{
			bool removeGcwTefNow = inv->getBooleanParameter();
			bool removeBhTefNow = inv->getBooleanParameter();
			
			schedulePvpTefRemovalTask(removeGcwTefNow, removeBhTefNow);
			
		}
		break;
	case RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_:
		{
			bool removeNow = inv->getBooleanParameter();
			
			schedulePvpTefRemovalTask(removeNow);
			
		}
		break;
	case RPC_ADDVENDOR__SCENEOBJECT_:
		{
			SceneObject* vendor = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addVendor(vendor);
			
		}
		break;
	case RPC_REMOVEVENDOR__SCENEOBJECT_:
		{
			SceneObject* vendor = static_cast<SceneObject*>(inv->getObjectParameter());
			
			removeVendor(vendor);
			
		}
		break;
	case RPC_GETVENDORCOUNT__:
		{
			
			int _m_res = getVendorCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_DESTROYOBJECTFROMDATABASE__BOOL_:
		{
			bool destroyContainedObjects = inv->getBooleanParameter();
			
			destroyObjectFromDatabase(destroyContainedObjects);
			
		}
		break;
	case RPC_DELETEALLPERSISTENTMESSAGES__:
		{
			
			deleteAllPersistentMessages();
			
		}
		break;
	case RPC_ISJEDI__:
		{
			
			bool _m_res = isJedi();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJEDILIGHT__:
		{
			
			bool _m_res = isJediLight();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJEDIDARK__:
		{
			
			bool _m_res = isJediDark();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISMUTED__:
		{
			
			bool _m_res = isMuted();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETMUTEDSTATE__BOOL_:
		{
			bool mute = inv->getBooleanParameter();
			
			setMutedState(mute);
			
		}
		break;
	case RPC_GETMUTEDREASON__:
		{
			
			String _m_res = getMutedReason();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETMUTEDREASON__STRING_:
		{
			String reason; inv->getAsciiParameter(reason);
			
			setMutedReason(reason);
			
		}
		break;
	case RPC_GETINSTALLEDHOLOEMOTE__:
		{
			
			String _m_res = getInstalledHoloEmote();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETINSTALLEDHOLOEMOTE__STRING_:
		{
			String holoEmote; inv->getAsciiParameter(holoEmote);
			
			setInstalledHoloEmote(holoEmote);
			
		}
		break;
	case RPC_REMOVEINSTALLEDHOLOEMOTE__:
		{
			
			removeInstalledHoloEmote();
			
		}
		break;
	case RPC_GETHOLOEMOTEUSECOUNT__:
		{
			
			int _m_res = getHoloEmoteUseCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_DECREASEHOLOEMOTEUSECOUNT__:
		{
			
			decreaseHoloEmoteUseCount();
			
		}
		break;
	case RPC_ISMARRIED__:
		{
			
			bool _m_res = isMarried();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSPOUSENAME__:
		{
			
			String _m_res = getSpouseName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETSPOUSENAME__STRING_:
		{
			String firstName; inv->getAsciiParameter(firstName);
			
			setSpouseName(firstName);
			
		}
		break;
	case RPC_REMOVESPOUSE__:
		{
			
			removeSpouse();
			
		}
		break;
	case RPC_GETACCOUNT__:
		{
			
			DistributedObject* _m_res = getAccount();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETCHOSENVETERANREWARD__INT_:
		{
			unsigned int milestone = inv->getUnsignedIntParameter();
			
			String _m_res = getChosenVeteranReward(milestone);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_HASCHOSENVETERANREWARD__STRING_:
		{
			 String rewardTemplate; inv->getAsciiParameter(rewardTemplate);
			
			bool _m_res = hasChosenVeteranReward(rewardTemplate);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARVETERANREWARD__INT_:
		{
			unsigned int milestone = inv->getUnsignedIntParameter();
			
			clearVeteranReward(milestone);
			
		}
		break;
	case RPC_ADDEVENTPERK__SCENEOBJECT_:
		{
			SceneObject* deed = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addEventPerk(deed);
			
		}
		break;
	case RPC_REMOVEEVENTPERK__SCENEOBJECT_:
		{
			SceneObject* deed = static_cast<SceneObject*>(inv->getObjectParameter());
			
			removeEventPerk(deed);
			
		}
		break;
	case RPC_GETEVENTPERKCOUNT__:
		{
			
			int _m_res = getEventPerkCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCHARACTERAGEINDAYS__:
		{
			
			int _m_res = getCharacterAgeInDays();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ADDTOREACTIONFINES__INT_:
		{
			int fine = inv->getSignedIntParameter();
			
			addToReactionFines(fine);
			
		}
		break;
	case RPC_SETREACTIONFINES__INT_:
		{
			int amount = inv->getSignedIntParameter();
			
			setReactionFines(amount);
			
		}
		break;
	case RPC_SUBTRACTFROMREACTIONFINES__INT_:
		{
			int amount = inv->getSignedIntParameter();
			
			subtractFromReactionFines(amount);
			
		}
		break;
	case RPC_UPDATEREACTIONFINETIMESTAMP__:
		{
			
			updateReactionFineTimestamp();
			
		}
		break;
	case RPC_UPDATEREACTIONFINEMAILTIMESTAMP__:
		{
			
			updateReactionFineMailTimestamp();
			
		}
		break;
	case RPC_GETXPCAP__STRING_:
		{
			 String type; inv->getAsciiParameter(type);
			
			int _m_res = getXpCap(type);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSPENTJEDISKILLPOINTS__:
		{
			
			int _m_res = getSpentJediSkillPoints();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASSCHEMATIC__DRAFTSCHEMATIC_:
		{
			DraftSchematic* schematic = static_cast<DraftSchematic*>(inv->getObjectParameter());
			
			bool _m_res = hasSchematic(schematic);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASEVENTPERK__STRING_:
		{
			 String templatePath; inv->getAsciiParameter(templatePath);
			
			bool _m_res = hasEventPerk(templatePath);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_DOFIELDFACTIONCHANGE__INT_:
		{
			int newStatus = inv->getSignedIntParameter();
			
			doFieldFactionChange(newStatus);
			
		}
		break;
	case RPC_ADDTOKILLERLIST__INT_:
		{
			unsigned int playerID = inv->getUnsignedIntParameter();
			
			addToKillerList(playerID);
			
		}
		break;
	case RPC_HASONKILLERLIST__INT_:
		{
			unsigned int playerID = inv->getUnsignedIntParameter();
			
			bool _m_res = hasOnKillerList(playerID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPVPRATING__:
		{
			
			int _m_res = getPvpRating();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETPVPRATING__INT_:
		{
			int rating = inv->getSignedIntParameter();
			
			setPvpRating(rating);
			
		}
		break;
	default:
		IntangibleObjectAdapter::invokeMethod(methid, inv);
	}
}

void PlayerObjectAdapter::finalize() {
	(static_cast<PlayerObject*>(stub))->finalize();
}

void PlayerObjectAdapter::setClientPathWaypoint(SceneObject* obj) {
	(static_cast<PlayerObject*>(stub))->setClientPathWaypoint(obj);
}

void PlayerObjectAdapter::initializeAccount() {
	(static_cast<PlayerObject*>(stub))->initializeAccount();
}

void PlayerObjectAdapter::notifyLoadFromDatabase() {
	(static_cast<PlayerObject*>(stub))->notifyLoadFromDatabase();
}

void PlayerObjectAdapter::unload() {
	(static_cast<PlayerObject*>(stub))->unload();
}

int PlayerObjectAdapter::calculateBhReward() {
	return (static_cast<PlayerObject*>(stub))->calculateBhReward();
}

void PlayerObjectAdapter::initializeTransientMembers() {
	(static_cast<PlayerObject*>(stub))->initializeTransientMembers();
}

void PlayerObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<PlayerObject*>(stub))->sendBaselinesTo(player);
}

void PlayerObjectAdapter::sendMessage(BasePacket* msg) {
	(static_cast<PlayerObject*>(stub))->sendMessage(msg);
}

void PlayerObjectAdapter::addOwnedStructure(StructureObject* obj) {
	(static_cast<PlayerObject*>(stub))->addOwnedStructure(obj);
}

void PlayerObjectAdapter::removeOwnedStructure(StructureObject* obj) {
	(static_cast<PlayerObject*>(stub))->removeOwnedStructure(obj);
}

int PlayerObjectAdapter::getTotalOwnedStructureCount() {
	return (static_cast<PlayerObject*>(stub))->getTotalOwnedStructureCount();
}

bool PlayerObjectAdapter::isOwnedStructure(StructureObject* obj) {
	return (static_cast<PlayerObject*>(stub))->isOwnedStructure(obj);
}

unsigned long long PlayerObjectAdapter::getOwnedStructure(int i) {
	return (static_cast<PlayerObject*>(stub))->getOwnedStructure(i);
}

int PlayerObjectAdapter::getLotsRemaining() {
	return (static_cast<PlayerObject*>(stub))->getLotsRemaining();
}

bool PlayerObjectAdapter::hasLotsRemaining(int lots) {
	return (static_cast<PlayerObject*>(stub))->hasLotsRemaining(lots);
}

void PlayerObjectAdapter::notifySceneReady() {
	(static_cast<PlayerObject*>(stub))->notifySceneReady();
}

void PlayerObjectAdapter::checkPendingMessages() {
	(static_cast<PlayerObject*>(stub))->checkPendingMessages();
}

int PlayerObjectAdapter::addExperience(const String& xpType, int xp, bool notifyClient) {
	return (static_cast<PlayerObject*>(stub))->addExperience(xpType, xp, notifyClient);
}

void PlayerObjectAdapter::removeExperience(const String& xpType, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeExperience(xpType, notifyClient);
}

bool PlayerObjectAdapter::hasCappedExperience(const String& xpType) {
	return (static_cast<PlayerObject*>(stub))->hasCappedExperience(xpType);
}

void PlayerObjectAdapter::addWaypoint(WaypointObject* waypoint, bool checkName, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addWaypoint(waypoint, checkName, notifyClient);
}

void PlayerObjectAdapter::setWaypoint(WaypointObject* waypoint, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setWaypoint(waypoint, notifyClient);
}

void PlayerObjectAdapter::removeWaypoint(unsigned long long waypointID, bool notifyClient, bool destroy) {
	(static_cast<PlayerObject*>(stub))->removeWaypoint(waypointID, notifyClient, destroy);
}

void PlayerObjectAdapter::updateWaypoint(unsigned long long waypointID) {
	(static_cast<PlayerObject*>(stub))->updateWaypoint(waypointID);
}

void PlayerObjectAdapter::removeWaypointBySpecialType(int specialTypeID, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeWaypointBySpecialType(specialTypeID, notifyClient);
}

WaypointObject* PlayerObjectAdapter::getWaypointBySpecialType(int specialTypeID) {
	return (static_cast<PlayerObject*>(stub))->getWaypointBySpecialType(specialTypeID);
}

WaypointObject* PlayerObjectAdapter::getSurveyWaypoint() {
	return (static_cast<PlayerObject*>(stub))->getSurveyWaypoint();
}

bool PlayerObjectAdapter::hasWaypoint(unsigned long long objectID) {
	return (static_cast<PlayerObject*>(stub))->hasWaypoint(objectID);
}

WaypointObject* PlayerObjectAdapter::getWaypointAt(float x, float y, String& planet) {
	return (static_cast<PlayerObject*>(stub))->getWaypointAt(x, y, planet);
}

void PlayerObjectAdapter::insertWaypointListToMessage(BaseMessage* msg) {
	(static_cast<PlayerObject*>(stub))->insertWaypointListToMessage(msg);
}

int PlayerObjectAdapter::getWaypointListSize() {
	return (static_cast<PlayerObject*>(stub))->getWaypointListSize();
}

WaypointObject* PlayerObjectAdapter::getWaypoint(int index) {
	return (static_cast<PlayerObject*>(stub))->getWaypoint(index);
}

void PlayerObjectAdapter::setLanguageID(byte language, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setLanguageID(language, notifyClient);
}

void PlayerObjectAdapter::addFriend(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addFriend(name, notifyClient);
}

void PlayerObjectAdapter::removeFriend(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeFriend(name, notifyClient);
}

void PlayerObjectAdapter::removeAllReverseFriends(const String& oldName) {
	(static_cast<PlayerObject*>(stub))->removeAllReverseFriends(oldName);
}

void PlayerObjectAdapter::addIgnore(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addIgnore(name, notifyClient);
}

void PlayerObjectAdapter::removeIgnore(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeIgnore(name, notifyClient);
}

void PlayerObjectAdapter::setTitle(const String& characterTitle, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setTitle(characterTitle, notifyClient);
}

void PlayerObjectAdapter::setFoodFilling(int newValue, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setFoodFilling(newValue, notifyClient);
}

void PlayerObjectAdapter::setDrinkFilling(int newValue, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setDrinkFilling(newValue, notifyClient);
}

void PlayerObjectAdapter::increaseFactionStanding(const String& factionName, float amount) {
	(static_cast<PlayerObject*>(stub))->increaseFactionStanding(factionName, amount);
}

void PlayerObjectAdapter::decreaseFactionStanding(const String& factionName, float amount) {
	(static_cast<PlayerObject*>(stub))->decreaseFactionStanding(factionName, amount);
}

void PlayerObjectAdapter::setFactionStanding(const String& factionName, float amount) {
	(static_cast<PlayerObject*>(stub))->setFactionStanding(factionName, amount);
}

float PlayerObjectAdapter::getFactionStanding(const String& factionName) {
	return (static_cast<PlayerObject*>(stub))->getFactionStanding(factionName);
}

void PlayerObjectAdapter::setScreenPlayData(const String& screenPlay, const String& variable, const String& data) {
	(static_cast<PlayerObject*>(stub))->setScreenPlayData(screenPlay, variable, data);
}

void PlayerObjectAdapter::deleteScreenPlayData(const String& screenPlay, const String& variable) {
	(static_cast<PlayerObject*>(stub))->deleteScreenPlayData(screenPlay, variable);
}

String PlayerObjectAdapter::getScreenPlayData(const String& screenPlay, const String& variable) {
	return (static_cast<PlayerObject*>(stub))->getScreenPlayData(screenPlay, variable);
}

void PlayerObjectAdapter::clearScreenPlayData(const String& screenPlay) {
	(static_cast<PlayerObject*>(stub))->clearScreenPlayData(screenPlay);
}

void PlayerObjectAdapter::activateRecovery() {
	(static_cast<PlayerObject*>(stub))->activateRecovery();
}

void PlayerObjectAdapter::activateForcePowerRegen() {
	(static_cast<PlayerObject*>(stub))->activateForcePowerRegen();
}

void PlayerObjectAdapter::doRecovery(int latency) {
	(static_cast<PlayerObject*>(stub))->doRecovery(latency);
}

void PlayerObjectAdapter::disconnect(bool closeClient, bool doLock) {
	(static_cast<PlayerObject*>(stub))->disconnect(closeClient, doLock);
}

void PlayerObjectAdapter::reload(ZoneClientSession* client) {
	(static_cast<PlayerObject*>(stub))->reload(client);
}

void PlayerObjectAdapter::setOffline() {
	(static_cast<PlayerObject*>(stub))->setOffline();
}

void PlayerObjectAdapter::setLinkDead(bool isSafeLogout) {
	(static_cast<PlayerObject*>(stub))->setLinkDead(isSafeLogout);
}

void PlayerObjectAdapter::setOnline() {
	(static_cast<PlayerObject*>(stub))->setOnline();
}

void PlayerObjectAdapter::setLoggingOut() {
	(static_cast<PlayerObject*>(stub))->setLoggingOut();
}

void PlayerObjectAdapter::sendBadgesResponseTo(CreatureObject* player) {
	(static_cast<PlayerObject*>(stub))->sendBadgesResponseTo(player);
}

void PlayerObjectAdapter::logout(bool doLock) {
	(static_cast<PlayerObject*>(stub))->logout(doLock);
}

void PlayerObjectAdapter::setJediState(int state, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setJediState(state, notifyClient);
}

void PlayerObjectAdapter::setActiveQuestsBit(int bitIndex, byte value, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setActiveQuestsBit(bitIndex, value, notifyClient);
}

void PlayerObjectAdapter::clearActiveQuestsBit(int bitIndex, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->clearActiveQuestsBit(bitIndex, notifyClient);
}

bool PlayerObjectAdapter::canActivateQuest(int questID) {
	return (static_cast<PlayerObject*>(stub))->canActivateQuest(questID);
}

void PlayerObjectAdapter::activateQuest(int questID) {
	(static_cast<PlayerObject*>(stub))->activateQuest(questID);
}

bool PlayerObjectAdapter::hasActiveQuestBitSet(int bitIndex) {
	return (static_cast<PlayerObject*>(stub))->hasActiveQuestBitSet(bitIndex);
}

bool PlayerObjectAdapter::hasCompletedQuestsBitSet(int bitIndex) {
	return (static_cast<PlayerObject*>(stub))->hasCompletedQuestsBitSet(bitIndex);
}

void PlayerObjectAdapter::setCompletedQuestsBit(int bitIndex, byte value, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setCompletedQuestsBit(bitIndex, value, notifyClient);
}

void PlayerObjectAdapter::clearCompletedQuestsBit(int bitIndex, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->clearCompletedQuestsBit(bitIndex, notifyClient);
}

void PlayerObjectAdapter::completeQuest(int questID) {
	(static_cast<PlayerObject*>(stub))->completeQuest(questID);
}

bool PlayerObjectAdapter::hasQuestData(unsigned int questHashCode) {
	return (static_cast<PlayerObject*>(stub))->hasQuestData(questHashCode);
}

void PlayerObjectAdapter::setLastNpcConvStr(const String& conv) {
	(static_cast<PlayerObject*>(stub))->setLastNpcConvStr(conv);
}

void PlayerObjectAdapter::setLastNpcConvMessStr(const String& mess) {
	(static_cast<PlayerObject*>(stub))->setLastNpcConvMessStr(mess);
}

String PlayerObjectAdapter::getLastNpcConvStr() {
	return (static_cast<PlayerObject*>(stub))->getLastNpcConvStr();
}

String PlayerObjectAdapter::getLastNpcConvMessStr() {
	return (static_cast<PlayerObject*>(stub))->getLastNpcConvMessStr();
}

String PlayerObjectAdapter::getLastNpcConvOption(int idx) {
	return (static_cast<PlayerObject*>(stub))->getLastNpcConvOption(idx);
}

void PlayerObjectAdapter::addLastNpcConvOptions(const String& option) {
	(static_cast<PlayerObject*>(stub))->addLastNpcConvOptions(option);
}

int PlayerObjectAdapter::countLastNpcConvOptions() {
	return (static_cast<PlayerObject*>(stub))->countLastNpcConvOptions();
}

void PlayerObjectAdapter::clearLastNpcConvOptions() {
	(static_cast<PlayerObject*>(stub))->clearLastNpcConvOptions();
}

void PlayerObjectAdapter::setConversatingCreature(CreatureObject* creature) {
	(static_cast<PlayerObject*>(stub))->setConversatingCreature(creature);
}

unsigned long long PlayerObjectAdapter::getConversatingCreature() {
	return (static_cast<PlayerObject*>(stub))->getConversatingCreature();
}

void PlayerObjectAdapter::setTrainerZoneName(String& zoneName) {
	(static_cast<PlayerObject*>(stub))->setTrainerZoneName(zoneName);
}

String PlayerObjectAdapter::getTrainerZoneName() {
	return (static_cast<PlayerObject*>(stub))->getTrainerZoneName();
}

void PlayerObjectAdapter::addPersistentMessage(unsigned long long id) {
	(static_cast<PlayerObject*>(stub))->addPersistentMessage(id);
}

void PlayerObjectAdapter::dropPersistentMessage(unsigned long long id) {
	(static_cast<PlayerObject*>(stub))->dropPersistentMessage(id);
}

void PlayerObjectAdapter::unloadSpawnedChildren() {
	(static_cast<PlayerObject*>(stub))->unloadSpawnedChildren();
}

void PlayerObjectAdapter::addToConsentList(const String& name) {
	(static_cast<PlayerObject*>(stub))->addToConsentList(name);
}

bool PlayerObjectAdapter::hasInConsentList(const String& name) {
	return (static_cast<PlayerObject*>(stub))->hasInConsentList(name);
}

void PlayerObjectAdapter::removeFromConsentList(const String& name) {
	(static_cast<PlayerObject*>(stub))->removeFromConsentList(name);
}

String PlayerObjectAdapter::getConsentName(int i) {
	return (static_cast<PlayerObject*>(stub))->getConsentName(i);
}

int PlayerObjectAdapter::getConsentListSize() {
	return (static_cast<PlayerObject*>(stub))->getConsentListSize();
}

int PlayerObjectAdapter::getReactionFines() {
	return (static_cast<PlayerObject*>(stub))->getReactionFines();
}

void PlayerObjectAdapter::setCommandMessageString(unsigned int actionCRC, String& message) {
	(static_cast<PlayerObject*>(stub))->setCommandMessageString(actionCRC, message);
}

void PlayerObjectAdapter::removeCommandMessageString(unsigned int actionCRC) {
	(static_cast<PlayerObject*>(stub))->removeCommandMessageString(actionCRC);
}

unsigned long long PlayerObjectAdapter::getDeclaredResidence() const {
	return (static_cast<PlayerObject*>(stub))->getDeclaredResidence();
}

void PlayerObjectAdapter::setDeclaredResidence(BuildingObject* residence) {
	(static_cast<PlayerObject*>(stub))->setDeclaredResidence(residence);
}

void PlayerObjectAdapter::setCloningFacility(BuildingObject* cloningfac) {
	(static_cast<PlayerObject*>(stub))->setCloningFacility(cloningfac);
}

unsigned long long PlayerObjectAdapter::getCloningFacility() const {
	return (static_cast<PlayerObject*>(stub))->getCloningFacility();
}

void PlayerObjectAdapter::notifyOnline() {
	(static_cast<PlayerObject*>(stub))->notifyOnline();
}

void PlayerObjectAdapter::doDigest(int fillingReduction) {
	(static_cast<PlayerObject*>(stub))->doDigest(fillingReduction);
}

bool PlayerObjectAdapter::isDigesting() {
	return (static_cast<PlayerObject*>(stub))->isDigesting();
}

String PlayerObjectAdapter::getSavedTerrainName() const {
	return (static_cast<PlayerObject*>(stub))->getSavedTerrainName();
}

void PlayerObjectAdapter::setSavedParentID(unsigned long long id) {
	(static_cast<PlayerObject*>(stub))->setSavedParentID(id);
}

void PlayerObjectAdapter::setSavedTerrainName(const String& name) {
	(static_cast<PlayerObject*>(stub))->setSavedTerrainName(name);
}

void PlayerObjectAdapter::setForcePower(int fp, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setForcePower(fp, notifyClient);
}

void PlayerObjectAdapter::setForcePowerMax(int newValue, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setForcePowerMax(newValue, notifyClient);
}

void PlayerObjectAdapter::doForceRegen() {
	(static_cast<PlayerObject*>(stub))->doForceRegen();
}

int PlayerObjectAdapter::getForcePowerRegen() {
	return (static_cast<PlayerObject*>(stub))->getForcePowerRegen();
}

unsigned long long PlayerObjectAdapter::getSavedParentID() const {
	return (static_cast<PlayerObject*>(stub))->getSavedParentID();
}

unsigned int PlayerObjectAdapter::getNewSuiBoxID(unsigned int type) {
	return (static_cast<PlayerObject*>(stub))->getNewSuiBoxID(type);
}

bool PlayerObjectAdapter::hasSuiBox(unsigned int boxID) {
	return (static_cast<PlayerObject*>(stub))->hasSuiBox(boxID);
}

Reference<SuiBox* > PlayerObjectAdapter::getSuiBox(unsigned int boxID) {
	return (static_cast<PlayerObject*>(stub))->getSuiBox(boxID);
}

void PlayerObjectAdapter::removeSuiBox(unsigned int boxID, bool closeWindowToClient) {
	(static_cast<PlayerObject*>(stub))->removeSuiBox(boxID, closeWindowToClient);
}

void PlayerObjectAdapter::removeSuiBoxType(unsigned int windowType) {
	(static_cast<PlayerObject*>(stub))->removeSuiBoxType(windowType);
}

bool PlayerObjectAdapter::hasSuiBoxWindowType(unsigned int windowType) {
	return (static_cast<PlayerObject*>(stub))->hasSuiBoxWindowType(windowType);
}

void PlayerObjectAdapter::closeSuiWindowType(unsigned int windowType) {
	(static_cast<PlayerObject*>(stub))->closeSuiWindowType(windowType);
}

Reference<SuiBox* > PlayerObjectAdapter::getSuiBoxFromWindowType(unsigned int windowType) {
	return (static_cast<PlayerObject*>(stub))->getSuiBoxFromWindowType(windowType);
}

void PlayerObjectAdapter::addSuiBox(SuiBox* sui) {
	(static_cast<PlayerObject*>(stub))->addSuiBox(sui);
}

void PlayerObjectAdapter::addPermissionGroup(const String& group, bool updatePermissions) {
	(static_cast<PlayerObject*>(stub))->addPermissionGroup(group, updatePermissions);
}

void PlayerObjectAdapter::removePermissionGroup(const String& group, bool updatePermissions) {
	(static_cast<PlayerObject*>(stub))->removePermissionGroup(group, updatePermissions);
}

void PlayerObjectAdapter::updateInRangeBuildingPermissions() {
	(static_cast<PlayerObject*>(stub))->updateInRangeBuildingPermissions();
}

bool PlayerObjectAdapter::hasPermissionGroup(const String& group) {
	return (static_cast<PlayerObject*>(stub))->hasPermissionGroup(group);
}

void PlayerObjectAdapter::addIncapacitationTime() {
	(static_cast<PlayerObject*>(stub))->addIncapacitationTime();
}

byte PlayerObjectAdapter::getIncapacitationCounter() const {
	return (static_cast<PlayerObject*>(stub))->getIncapacitationCounter();
}

void PlayerObjectAdapter::resetIncapacitationTimes() {
	(static_cast<PlayerObject*>(stub))->resetIncapacitationTimes();
}

void PlayerObjectAdapter::addToDuelList(CreatureObject* targetPlayer) {
	(static_cast<PlayerObject*>(stub))->addToDuelList(targetPlayer);
}

void PlayerObjectAdapter::removeFromDuelList(CreatureObject* targetPlayer) {
	(static_cast<PlayerObject*>(stub))->removeFromDuelList(targetPlayer);
}

Reference<CreatureObject* > PlayerObjectAdapter::getDuelListObject(int index) {
	return (static_cast<PlayerObject*>(stub))->getDuelListObject(index);
}

bool PlayerObjectAdapter::requestedDuelTo(CreatureObject* targetPlayer) {
	return (static_cast<PlayerObject*>(stub))->requestedDuelTo(targetPlayer);
}

bool PlayerObjectAdapter::isDuelListEmpty() {
	return (static_cast<PlayerObject*>(stub))->isDuelListEmpty();
}

int PlayerObjectAdapter::getDuelListSize() {
	return (static_cast<PlayerObject*>(stub))->getDuelListSize();
}

void PlayerObjectAdapter::addToActivePets(AiAgent* pet) {
	(static_cast<PlayerObject*>(stub))->addToActivePets(pet);
}

void PlayerObjectAdapter::removeFromActivePets(AiAgent* pet) {
	(static_cast<PlayerObject*>(stub))->removeFromActivePets(pet);
}

AiAgent* PlayerObjectAdapter::getActivePet(int index) {
	return (static_cast<PlayerObject*>(stub))->getActivePet(index);
}

bool PlayerObjectAdapter::hasActivePet(AiAgent* pet) {
	return (static_cast<PlayerObject*>(stub))->hasActivePet(pet);
}

int PlayerObjectAdapter::getActivePetsSize() {
	return (static_cast<PlayerObject*>(stub))->getActivePetsSize();
}

UnicodeString PlayerObjectAdapter::getBiography() const {
	return (static_cast<PlayerObject*>(stub))->getBiography();
}

void PlayerObjectAdapter::notifyOffline() {
	(static_cast<PlayerObject*>(stub))->notifyOffline();
}

void PlayerObjectAdapter::setBadge(unsigned int badge) {
	(static_cast<PlayerObject*>(stub))->setBadge(badge);
}

void PlayerObjectAdapter::awardBadge(unsigned int badge) {
	(static_cast<PlayerObject*>(stub))->awardBadge(badge);
}

void PlayerObjectAdapter::setTeleporting(bool val) {
	(static_cast<PlayerObject*>(stub))->setTeleporting(val);
}

void PlayerObjectAdapter::setOnLoadScreen(bool val) {
	(static_cast<PlayerObject*>(stub))->setOnLoadScreen(val);
}

int PlayerObjectAdapter::getNumBadges() {
	return (static_cast<PlayerObject*>(stub))->getNumBadges();
}

int PlayerObjectAdapter::getBadgeTypeCount(unsigned int type) {
	return (static_cast<PlayerObject*>(stub))->getBadgeTypeCount(type);
}

bool PlayerObjectAdapter::hasFriend(const String& name) {
	return (static_cast<PlayerObject*>(stub))->hasFriend(name);
}

int PlayerObjectAdapter::getFriendListSize() {
	return (static_cast<PlayerObject*>(stub))->getFriendListSize();
}

bool PlayerObjectAdapter::isIgnoring(const String& name) {
	return (static_cast<PlayerObject*>(stub))->isIgnoring(name);
}

void PlayerObjectAdapter::addReverseFriend(const String& name) {
	(static_cast<PlayerObject*>(stub))->addReverseFriend(name);
}

void PlayerObjectAdapter::removeReverseFriend(const String& name) {
	(static_cast<PlayerObject*>(stub))->removeReverseFriend(name);
}

void PlayerObjectAdapter::sendFriendLists() {
	(static_cast<PlayerObject*>(stub))->sendFriendLists();
}

bool PlayerObjectAdapter::hasCommandMessageString(unsigned int actionCRC) {
	return (static_cast<PlayerObject*>(stub))->hasCommandMessageString(actionCRC);
}

unsigned int PlayerObjectAdapter::getCharacterBitmask() const {
	return (static_cast<PlayerObject*>(stub))->getCharacterBitmask();
}

String PlayerObjectAdapter::getTitle() const {
	return (static_cast<PlayerObject*>(stub))->getTitle();
}

unsigned int PlayerObjectAdapter::getAdminLevel() const {
	return (static_cast<PlayerObject*>(stub))->getAdminLevel();
}

void PlayerObjectAdapter::setAdminLevel(unsigned int adminlvl) {
	(static_cast<PlayerObject*>(stub))->setAdminLevel(adminlvl);
}

int PlayerObjectAdapter::getPriviledgeFlag() const {
	return (static_cast<PlayerObject*>(stub))->getPriviledgeFlag();
}

void PlayerObjectAdapter::setPriviledgeFlag(int flag) {
	(static_cast<PlayerObject*>(stub))->setPriviledgeFlag(flag);
}

void PlayerObjectAdapter::setBiography(const UnicodeString& bio) {
	(static_cast<PlayerObject*>(stub))->setBiography(bio);
}

bool PlayerObjectAdapter::hasGodMode() {
	return (static_cast<PlayerObject*>(stub))->hasGodMode();
}

bool PlayerObjectAdapter::isPrivileged() {
	return (static_cast<PlayerObject*>(stub))->isPrivileged();
}

bool PlayerObjectAdapter::isStaff() {
	return (static_cast<PlayerObject*>(stub))->isStaff();
}

bool PlayerObjectAdapter::isAdmin() {
	return (static_cast<PlayerObject*>(stub))->isAdmin();
}

void PlayerObjectAdapter::setCharacterBitmask(unsigned int bitmask) {
	(static_cast<PlayerObject*>(stub))->setCharacterBitmask(bitmask);
}

bool PlayerObjectAdapter::setCharacterBit(unsigned int bit, bool notifyClient) {
	return (static_cast<PlayerObject*>(stub))->setCharacterBit(bit, notifyClient);
}

bool PlayerObjectAdapter::clearCharacterBit(unsigned int bit, bool notifyClient) {
	return (static_cast<PlayerObject*>(stub))->clearCharacterBit(bit, notifyClient);
}

void PlayerObjectAdapter::toggleCharacterBit(unsigned int bit) {
	(static_cast<PlayerObject*>(stub))->toggleCharacterBit(bit);
}

bool PlayerObjectAdapter::isLFG() {
	return (static_cast<PlayerObject*>(stub))->isLFG();
}

bool PlayerObjectAdapter::isAFK() {
	return (static_cast<PlayerObject*>(stub))->isAFK();
}

bool PlayerObjectAdapter::isAnonymous() {
	return (static_cast<PlayerObject*>(stub))->isAnonymous();
}

bool PlayerObjectAdapter::isRoleplayer() {
	return (static_cast<PlayerObject*>(stub))->isRoleplayer();
}

bool PlayerObjectAdapter::isNewbieHelper() {
	return (static_cast<PlayerObject*>(stub))->isNewbieHelper();
}

int PlayerObjectAdapter::getForcePower() const {
	return (static_cast<PlayerObject*>(stub))->getForcePower();
}

int PlayerObjectAdapter::getForcePowerMax() const {
	return (static_cast<PlayerObject*>(stub))->getForcePowerMax();
}

DraftSchematic* PlayerObjectAdapter::getSchematic(int i) {
	return (static_cast<PlayerObject*>(stub))->getSchematic(i);
}

int PlayerObjectAdapter::getFoodFilling() const {
	return (static_cast<PlayerObject*>(stub))->getFoodFilling();
}

int PlayerObjectAdapter::getFoodFillingMax() const {
	return (static_cast<PlayerObject*>(stub))->getFoodFillingMax();
}

int PlayerObjectAdapter::getDrinkFilling() const {
	return (static_cast<PlayerObject*>(stub))->getDrinkFilling();
}

int PlayerObjectAdapter::getDrinkFillingMax() const {
	return (static_cast<PlayerObject*>(stub))->getDrinkFillingMax();
}

int PlayerObjectAdapter::getJediState() const {
	return (static_cast<PlayerObject*>(stub))->getJediState();
}

byte PlayerObjectAdapter::getLanguageID() const {
	return (static_cast<PlayerObject*>(stub))->getLanguageID();
}

bool PlayerObjectAdapter::isTeleporting() const {
	return (static_cast<PlayerObject*>(stub))->isTeleporting();
}

bool PlayerObjectAdapter::isOnLoadScreen() const {
	return (static_cast<PlayerObject*>(stub))->isOnLoadScreen();
}

void PlayerObjectAdapter::addChatRoom(unsigned int roomID) {
	(static_cast<PlayerObject*>(stub))->addChatRoom(roomID);
}

void PlayerObjectAdapter::removeChatRoom(unsigned int roomID) {
	(static_cast<PlayerObject*>(stub))->removeChatRoom(roomID);
}

void PlayerObjectAdapter::addOwnedChatRoom(unsigned int roomID) {
	(static_cast<PlayerObject*>(stub))->addOwnedChatRoom(roomID);
}

void PlayerObjectAdapter::removeOwnedChatRoom(unsigned int roomID) {
	(static_cast<PlayerObject*>(stub))->removeOwnedChatRoom(roomID);
}

int PlayerObjectAdapter::getOwnedChatRoomCount() {
	return (static_cast<PlayerObject*>(stub))->getOwnedChatRoomCount();
}

void PlayerObjectAdapter::setBankLocation(const String& location) {
	(static_cast<PlayerObject*>(stub))->setBankLocation(location);
}

String PlayerObjectAdapter::getBankLocation() const {
	return (static_cast<PlayerObject*>(stub))->getBankLocation();
}

int PlayerObjectAdapter::getExperience(const String& xp) {
	return (static_cast<PlayerObject*>(stub))->getExperience(xp);
}

void PlayerObjectAdapter::maximizeExperience() {
	(static_cast<PlayerObject*>(stub))->maximizeExperience();
}

void PlayerObjectAdapter::activateMissions() {
	(static_cast<PlayerObject*>(stub))->activateMissions();
}

String PlayerObjectAdapter::getCommandMessageString(unsigned int actionCRC) {
	return (static_cast<PlayerObject*>(stub))->getCommandMessageString(actionCRC);
}

bool PlayerObjectAdapter::hasBadge(unsigned int badge) {
	return (static_cast<PlayerObject*>(stub))->hasBadge(badge);
}

void PlayerObjectAdapter::clearDisconnectEvent() {
	(static_cast<PlayerObject*>(stub))->clearDisconnectEvent();
}

bool PlayerObjectAdapter::isOnline() const {
	return (static_cast<PlayerObject*>(stub))->isOnline();
}

bool PlayerObjectAdapter::isOffline() const {
	return (static_cast<PlayerObject*>(stub))->isOffline();
}

bool PlayerObjectAdapter::isLoading() const {
	return (static_cast<PlayerObject*>(stub))->isLoading();
}

bool PlayerObjectAdapter::isLinkDead() const {
	return (static_cast<PlayerObject*>(stub))->isLinkDead();
}

bool PlayerObjectAdapter::isLoggingIn() const {
	return (static_cast<PlayerObject*>(stub))->isLoggingIn();
}

bool PlayerObjectAdapter::isLoggingOut() const {
	return (static_cast<PlayerObject*>(stub))->isLoggingOut();
}

void PlayerObjectAdapter::setSkillPoints(int points) {
	(static_cast<PlayerObject*>(stub))->setSkillPoints(points);
}

void PlayerObjectAdapter::addSkillPoints(int points) {
	(static_cast<PlayerObject*>(stub))->addSkillPoints(points);
}

int PlayerObjectAdapter::getSkillPoints() const {
	return (static_cast<PlayerObject*>(stub))->getSkillPoints();
}

void PlayerObjectAdapter::updateLastValidatedPosition() {
	(static_cast<PlayerObject*>(stub))->updateLastValidatedPosition();
}

unsigned int PlayerObjectAdapter::getAccountID() const {
	return (static_cast<PlayerObject*>(stub))->getAccountID();
}

unsigned long long PlayerObjectAdapter::getServerMovementTimeDelta() {
	return (static_cast<PlayerObject*>(stub))->getServerMovementTimeDelta();
}

void PlayerObjectAdapter::setClientLastMovementStamp(unsigned int stamp) {
	(static_cast<PlayerObject*>(stub))->setClientLastMovementStamp(stamp);
}

void PlayerObjectAdapter::updateServerLastMovementStamp() {
	(static_cast<PlayerObject*>(stub))->updateServerLastMovementStamp();
}

void PlayerObjectAdapter::setAccountID(unsigned int id) {
	(static_cast<PlayerObject*>(stub))->setAccountID(id);
}

unsigned int PlayerObjectAdapter::getClientLastMovementStamp() const {
	return (static_cast<PlayerObject*>(stub))->getClientLastMovementStamp();
}

void PlayerObjectAdapter::addHologrindProfession(byte prof) {
	(static_cast<PlayerObject*>(stub))->addHologrindProfession(prof);
}

void PlayerObjectAdapter::setMaximumLots(byte lots) {
	(static_cast<PlayerObject*>(stub))->setMaximumLots(lots);
}

byte PlayerObjectAdapter::getMaximumLots() const {
	return (static_cast<PlayerObject*>(stub))->getMaximumLots();
}

String PlayerObjectAdapter::getStarterProfession() const {
	return (static_cast<PlayerObject*>(stub))->getStarterProfession();
}

void PlayerObjectAdapter::setStarterProfession(String& profession) {
	(static_cast<PlayerObject*>(stub))->setStarterProfession(profession);
}

unsigned long long PlayerObjectAdapter::getPerformanceBuffTarget() const {
	return (static_cast<PlayerObject*>(stub))->getPerformanceBuffTarget();
}

void PlayerObjectAdapter::setPerformanceBuffTarget(unsigned long long target) {
	(static_cast<PlayerObject*>(stub))->setPerformanceBuffTarget(target);
}

void PlayerObjectAdapter::setDebug(bool value) {
	(static_cast<PlayerObject*>(stub))->setDebug(value);
}

bool PlayerObjectAdapter::getDebug() const {
	return (static_cast<PlayerObject*>(stub))->getDebug();
}

float PlayerObjectAdapter::getVisibility() const {
	return (static_cast<PlayerObject*>(stub))->getVisibility();
}

void PlayerObjectAdapter::setVisibility(float value) {
	(static_cast<PlayerObject*>(stub))->setVisibility(value);
}

void PlayerObjectAdapter::updateLastPvpCombatActionTimestamp(bool updateGcwAction, bool updateBhAction) {
	(static_cast<PlayerObject*>(stub))->updateLastPvpCombatActionTimestamp(updateGcwAction, updateBhAction);
}

void PlayerObjectAdapter::updateLastBhPvpCombatActionTimestamp() {
	(static_cast<PlayerObject*>(stub))->updateLastBhPvpCombatActionTimestamp();
}

void PlayerObjectAdapter::updateLastGcwPvpCombatActionTimestamp() {
	(static_cast<PlayerObject*>(stub))->updateLastGcwPvpCombatActionTimestamp();
}

bool PlayerObjectAdapter::hasPvpTef() {
	return (static_cast<PlayerObject*>(stub))->hasPvpTef();
}

bool PlayerObjectAdapter::hasBhTef() {
	return (static_cast<PlayerObject*>(stub))->hasBhTef();
}

void PlayerObjectAdapter::schedulePvpTefRemovalTask(bool removeGcwTefNow, bool removeBhTefNow) {
	(static_cast<PlayerObject*>(stub))->schedulePvpTefRemovalTask(removeGcwTefNow, removeBhTefNow);
}

void PlayerObjectAdapter::schedulePvpTefRemovalTask(bool removeNow) {
	(static_cast<PlayerObject*>(stub))->schedulePvpTefRemovalTask(removeNow);
}

void PlayerObjectAdapter::addVendor(SceneObject* vendor) {
	(static_cast<PlayerObject*>(stub))->addVendor(vendor);
}

void PlayerObjectAdapter::removeVendor(SceneObject* vendor) {
	(static_cast<PlayerObject*>(stub))->removeVendor(vendor);
}

int PlayerObjectAdapter::getVendorCount() {
	return (static_cast<PlayerObject*>(stub))->getVendorCount();
}

void PlayerObjectAdapter::destroyObjectFromDatabase(bool destroyContainedObjects) {
	(static_cast<PlayerObject*>(stub))->destroyObjectFromDatabase(destroyContainedObjects);
}

void PlayerObjectAdapter::deleteAllPersistentMessages() {
	(static_cast<PlayerObject*>(stub))->deleteAllPersistentMessages();
}

bool PlayerObjectAdapter::isJedi() const {
	return (static_cast<PlayerObject*>(stub))->isJedi();
}

bool PlayerObjectAdapter::isJediLight() {
	return (static_cast<PlayerObject*>(stub))->isJediLight();
}

bool PlayerObjectAdapter::isJediDark() {
	return (static_cast<PlayerObject*>(stub))->isJediDark();
}

bool PlayerObjectAdapter::isMuted() const {
	return (static_cast<PlayerObject*>(stub))->isMuted();
}

void PlayerObjectAdapter::setMutedState(bool mute) {
	(static_cast<PlayerObject*>(stub))->setMutedState(mute);
}

String PlayerObjectAdapter::getMutedReason() const {
	return (static_cast<PlayerObject*>(stub))->getMutedReason();
}

void PlayerObjectAdapter::setMutedReason(String& reason) {
	(static_cast<PlayerObject*>(stub))->setMutedReason(reason);
}

String PlayerObjectAdapter::getInstalledHoloEmote() const {
	return (static_cast<PlayerObject*>(stub))->getInstalledHoloEmote();
}

void PlayerObjectAdapter::setInstalledHoloEmote(String& holoEmote) {
	(static_cast<PlayerObject*>(stub))->setInstalledHoloEmote(holoEmote);
}

void PlayerObjectAdapter::removeInstalledHoloEmote() {
	(static_cast<PlayerObject*>(stub))->removeInstalledHoloEmote();
}

int PlayerObjectAdapter::getHoloEmoteUseCount() const {
	return (static_cast<PlayerObject*>(stub))->getHoloEmoteUseCount();
}

void PlayerObjectAdapter::decreaseHoloEmoteUseCount() {
	(static_cast<PlayerObject*>(stub))->decreaseHoloEmoteUseCount();
}

bool PlayerObjectAdapter::isMarried() const {
	return (static_cast<PlayerObject*>(stub))->isMarried();
}

String PlayerObjectAdapter::getSpouseName() const {
	return (static_cast<PlayerObject*>(stub))->getSpouseName();
}

void PlayerObjectAdapter::setSpouseName(String& firstName) {
	(static_cast<PlayerObject*>(stub))->setSpouseName(firstName);
}

void PlayerObjectAdapter::removeSpouse() {
	(static_cast<PlayerObject*>(stub))->removeSpouse();
}

Account* PlayerObjectAdapter::getAccount() {
	return (static_cast<PlayerObject*>(stub))->getAccount();
}

String PlayerObjectAdapter::getChosenVeteranReward(unsigned int milestone) {
	return (static_cast<PlayerObject*>(stub))->getChosenVeteranReward(milestone);
}

bool PlayerObjectAdapter::hasChosenVeteranReward(const String& rewardTemplate) {
	return (static_cast<PlayerObject*>(stub))->hasChosenVeteranReward(rewardTemplate);
}

void PlayerObjectAdapter::clearVeteranReward(unsigned int milestone) {
	(static_cast<PlayerObject*>(stub))->clearVeteranReward(milestone);
}

void PlayerObjectAdapter::addEventPerk(SceneObject* deed) {
	(static_cast<PlayerObject*>(stub))->addEventPerk(deed);
}

void PlayerObjectAdapter::removeEventPerk(SceneObject* deed) {
	(static_cast<PlayerObject*>(stub))->removeEventPerk(deed);
}

int PlayerObjectAdapter::getEventPerkCount() {
	return (static_cast<PlayerObject*>(stub))->getEventPerkCount();
}

int PlayerObjectAdapter::getCharacterAgeInDays() {
	return (static_cast<PlayerObject*>(stub))->getCharacterAgeInDays();
}

void PlayerObjectAdapter::addToReactionFines(int fine) {
	(static_cast<PlayerObject*>(stub))->addToReactionFines(fine);
}

void PlayerObjectAdapter::setReactionFines(int amount) {
	(static_cast<PlayerObject*>(stub))->setReactionFines(amount);
}

void PlayerObjectAdapter::subtractFromReactionFines(int amount) {
	(static_cast<PlayerObject*>(stub))->subtractFromReactionFines(amount);
}

void PlayerObjectAdapter::updateReactionFineTimestamp() {
	(static_cast<PlayerObject*>(stub))->updateReactionFineTimestamp();
}

void PlayerObjectAdapter::updateReactionFineMailTimestamp() {
	(static_cast<PlayerObject*>(stub))->updateReactionFineMailTimestamp();
}

int PlayerObjectAdapter::getXpCap(const String& type) {
	return (static_cast<PlayerObject*>(stub))->getXpCap(type);
}

int PlayerObjectAdapter::getSpentJediSkillPoints() {
	return (static_cast<PlayerObject*>(stub))->getSpentJediSkillPoints();
}

bool PlayerObjectAdapter::hasSchematic(DraftSchematic* schematic) {
	return (static_cast<PlayerObject*>(stub))->hasSchematic(schematic);
}

bool PlayerObjectAdapter::hasEventPerk(const String& templatePath) {
	return (static_cast<PlayerObject*>(stub))->hasEventPerk(templatePath);
}

void PlayerObjectAdapter::doFieldFactionChange(int newStatus) {
	(static_cast<PlayerObject*>(stub))->doFieldFactionChange(newStatus);
}

void PlayerObjectAdapter::addToKillerList(unsigned int playerID) {
	(static_cast<PlayerObject*>(stub))->addToKillerList(playerID);
}

bool PlayerObjectAdapter::hasOnKillerList(unsigned int playerID) {
	return (static_cast<PlayerObject*>(stub))->hasOnKillerList(playerID);
}

int PlayerObjectAdapter::getPvpRating() const {
	return (static_cast<PlayerObject*>(stub))->getPvpRating();
}

void PlayerObjectAdapter::setPvpRating(int rating) {
	(static_cast<PlayerObject*>(stub))->setPvpRating(rating);
}

/*
 *	PlayerObjectHelper
 */

PlayerObjectHelper* PlayerObjectHelper::staticInitializer = PlayerObjectHelper::instance();

PlayerObjectHelper::PlayerObjectHelper() {
	className = "PlayerObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void PlayerObjectHelper::finalizeHelper() {
	PlayerObjectHelper::finalize();
}

DistributedObject* PlayerObjectHelper::instantiateObject() {
	return new PlayerObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* PlayerObjectHelper::instantiateServant() {
	return new PlayerObjectImplementation();
}

DistributedObjectAdapter* PlayerObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new PlayerObjectAdapter(static_cast<PlayerObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

