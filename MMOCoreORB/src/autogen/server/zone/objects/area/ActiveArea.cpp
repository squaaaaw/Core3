/*
 *	autogen/server/zone/objects/area/ActiveArea.cpp generated by engine3 IDL compiler 0.60
 */

#include "ActiveArea.h"

#include "server/zone/objects/area/areashapes/AreaShape.h"

#include "server/zone/objects/pathfinding/NavArea.h"

#include "server/zone/Zone.h"

/*
 *	ActiveAreaStub
 */

enum {RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_ = 1878528101,RPC_ENQUEUEENTEREVENT__SCENEOBJECT_,RPC_ENQUEUEEXITEVENT__SCENEOBJECT_,RPC_NOTIFYENTER__SCENEOBJECT_,RPC_NOTIFYEXIT__SCENEOBJECT_,RPC_SETZONE__ZONE_,RPC_ISACTIVEAREA__,RPC_ISREGION__,RPC_ISCITYREGION__,RPC_ISNAVAREA__,RPC_ISNOBUILDAREA__,RPC_ISCAMPINGPERMITTED__,RPC_CONTAINSPOINT__FLOAT_FLOAT_LONG_,RPC_CONTAINSPOINT__FLOAT_FLOAT_,RPC_GETRADIUS2__,RPC_SETNOBUILDAREA__BOOL_,RPC_SETCAMPINGPERMITTED__BOOL_,RPC_SETMUNICIPALZONE__BOOL_,RPC_SETRADIUS__FLOAT_,RPC_ISCAMPAREA__,RPC_SETNOSPAWNAREA__BOOL_,RPC_ISNOSPAWNAREA__,RPC_ISMUNICIPALZONE__,RPC_GETCELLOBJECTID__,RPC_SETCELLOBJECTID__LONG_,RPC_SETAREASHAPE__AREASHAPE_,RPC_GETAREASHAPE__,RPC_INTERSECTSWITH__ACTIVEAREA_,RPC_ATTACHSCENERY__SCENEOBJECT_,RPC_INITIALIZECHILDOBJECT__SCENEOBJECT_};

ActiveArea::ActiveArea() : SceneObject(DummyConstructorParameter::instance()) {
	ActiveAreaImplementation* _implementation = new ActiveAreaImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("ActiveArea");
}

ActiveArea::ActiveArea(DummyConstructorParameter* param) : SceneObject(param) {
	_setClassName("ActiveArea");
}

ActiveArea::~ActiveArea() {
}



void ActiveArea::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);
		method.addBooleanParameter(forceLoadContainer);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendTo(player, doClose, forceLoadContainer);
	}
}

void ActiveArea::enqueueEnterEvent(SceneObject* obj) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENQUEUEENTEREVENT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->enqueueEnterEvent(obj);
	}
}

void ActiveArea::enqueueExitEvent(SceneObject* obj) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENQUEUEEXITEVENT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->enqueueExitEvent(obj);
	}
}

void ActiveArea::notifyEnter(SceneObject* object) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYENTER__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyEnter(object);
	}
}

void ActiveArea::notifyExit(SceneObject* object) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYEXIT__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyExit(object);
	}
}

void ActiveArea::setZone(Zone* zone) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETZONE__ZONE_);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else {
		_implementation->setZone(zone);
	}
}

bool ActiveArea::isActiveArea() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISACTIVEAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isActiveArea();
	}
}

bool ActiveArea::isRegion() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISREGION__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRegion();
	}
}

bool ActiveArea::isCityRegion() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCITYREGION__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCityRegion();
	}
}

bool ActiveArea::isNavArea() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNAVAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNavArea();
	}
}

NavArea* ActiveArea::asNavArea() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->asNavArea();
	}
}

bool ActiveArea::isNoBuildArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNOBUILDAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNoBuildArea();
	}
}

bool ActiveArea::isCampingPermitted() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMPINGPERMITTED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCampingPermitted();
	}
}

bool ActiveArea::containsPoint(float x, float y, unsigned long long cellid) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONTAINSPOINT__FLOAT_FLOAT_LONG_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addUnsignedLongParameter(cellid);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->containsPoint(x, y, cellid);
	}
}

bool ActiveArea::containsPoint(float x, float y) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONTAINSPOINT__FLOAT_FLOAT_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->containsPoint(x, y);
	}
}

float ActiveArea::getRadius2() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRADIUS2__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getRadius2();
	}
}

void ActiveArea::setNoBuildArea(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNOBUILDAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setNoBuildArea(val);
	}
}

void ActiveArea::setCampingPermitted(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCAMPINGPERMITTED__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCampingPermitted(val);
	}
}

void ActiveArea::setMunicipalZone(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMUNICIPALZONE__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMunicipalZone(val);
	}
}

void ActiveArea::setRadius(float r) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRADIUS__FLOAT_);
		method.addFloatParameter(r);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRadius(r);
	}
}

bool ActiveArea::isCampArea() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMPAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCampArea();
	}
}

void ActiveArea::setNoSpawnArea(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNOSPAWNAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setNoSpawnArea(val);
	}
}

bool ActiveArea::isNoSpawnArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNOSPAWNAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNoSpawnArea();
	}
}

bool ActiveArea::isMunicipalZone() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMUNICIPALZONE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMunicipalZone();
	}
}

unsigned long long ActiveArea::getCellObjectID() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCELLOBJECTID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getCellObjectID();
	}
}

void ActiveArea::setCellObjectID(unsigned long long celloid) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCELLOBJECTID__LONG_);
		method.addUnsignedLongParameter(celloid);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCellObjectID(celloid);
	}
}

void ActiveArea::setAreaShape(AreaShape* area) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAREASHAPE__AREASHAPE_);
		method.addObjectParameter(area);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAreaShape(area);
	}
}

AreaShape* ActiveArea::getAreaShape() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAREASHAPE__);

		return static_cast<AreaShape*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getAreaShape();
	}
}

bool ActiveArea::intersectsWith(ActiveArea* area) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INTERSECTSWITH__ACTIVEAREA_);
		method.addObjectParameter(area);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->intersectsWith(area);
	}
}

void ActiveArea::attachScenery(SceneObject* scene) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ATTACHSCENERY__SCENEOBJECT_);
		method.addObjectParameter(scene);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->attachScenery(scene);
	}
}

void ActiveArea::initializeChildObject(SceneObject* controllerObject) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZECHILDOBJECT__SCENEOBJECT_);
		method.addObjectParameter(controllerObject);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeChildObject(controllerObject);
	}
}

DistributedObjectServant* ActiveArea::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* ActiveArea::_getImplementationForRead() const {
	return _impl;
}

void ActiveArea::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ActiveAreaImplementation
 */

ActiveAreaImplementation::ActiveAreaImplementation(DummyConstructorParameter* param) : SceneObjectImplementation(param) {
	_initializeImplementation();
}


ActiveAreaImplementation::~ActiveAreaImplementation() {
}


void ActiveAreaImplementation::finalize() {
}

void ActiveAreaImplementation::_initializeImplementation() {
	_setClassHelper(ActiveAreaHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ActiveAreaImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<ActiveArea*>(stub);
	SceneObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ActiveAreaImplementation::_getStub() {
	return _this.get();
}

ActiveAreaImplementation::operator const ActiveArea*() {
	return _this.get();
}

void ActiveAreaImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ActiveAreaImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ActiveAreaImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ActiveAreaImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ActiveAreaImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ActiveAreaImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ActiveAreaImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ActiveAreaImplementation::_serializationHelperMethod() {
	SceneObjectImplementation::_serializationHelperMethod();

	_setClassName("ActiveArea");

}

void ActiveAreaImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ActiveAreaImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ActiveAreaImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x331902db: //ActiveArea.noBuildArea
		TypeInfo<bool >::parseFromBinaryStream(&noBuildArea, stream);
		return true;

	case 0x157f549a: //ActiveArea.campingPermitted
		TypeInfo<bool >::parseFromBinaryStream(&campingPermitted, stream);
		return true;

	case 0x3690552d: //ActiveArea.municipalZone
		TypeInfo<bool >::parseFromBinaryStream(&municipalZone, stream);
		return true;

	case 0x1d1bd89e: //ActiveArea.cellObjectID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&cellObjectID, stream);
		return true;

	case 0xa0804b0: //ActiveArea.noSpawnArea
		TypeInfo<bool >::parseFromBinaryStream(&noSpawnArea, stream);
		return true;

	case 0x1bb3704b: //ActiveArea.areaShape
		TypeInfo<ManagedReference<AreaShape* > >::parseFromBinaryStream(&areaShape, stream);
		return true;

	}

	return false;
}

void ActiveAreaImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ActiveAreaImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ActiveAreaImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x331902db; //ActiveArea.noBuildArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&noBuildArea, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x157f549a; //ActiveArea.campingPermitted
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&campingPermitted, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3690552d; //ActiveArea.municipalZone
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&municipalZone, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1d1bd89e; //ActiveArea.cellObjectID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&cellObjectID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xa0804b0; //ActiveArea.noSpawnArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&noSpawnArea, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1bb3704b; //ActiveArea.areaShape
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<AreaShape* > >::toBinaryStream(&areaShape, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 6;
}

ActiveAreaImplementation::ActiveAreaImplementation() {
	_initializeImplementation();
	// server/zone/objects/area/ActiveArea.idl():  		cellObjectID = 0;
	cellObjectID = 0;
	// server/zone/objects/area/ActiveArea.idl():  		noBuildArea = false;
	noBuildArea = false;
	// server/zone/objects/area/ActiveArea.idl():  		campingPermitted = false;
	campingPermitted = false;
	// server/zone/objects/area/ActiveArea.idl():  		municipalZone = false;
	municipalZone = false;
	// server/zone/objects/area/ActiveArea.idl():  		noSpawnArea = false;
	noSpawnArea = false;
	// server/zone/objects/area/ActiveArea.idl():  		areaShape = null;
	areaShape = NULL;
	// server/zone/objects/area/ActiveArea.idl():  		Logger.setLoggingName("ActiveArea");
	Logger::setLoggingName("ActiveArea");
}

void ActiveAreaImplementation::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
}

bool ActiveAreaImplementation::isActiveArea() {
	// server/zone/objects/area/ActiveArea.idl():  		return true;
	return true;
}

bool ActiveAreaImplementation::isRegion() {
	// server/zone/objects/area/ActiveArea.idl():  		return false;
	return false;
}

bool ActiveAreaImplementation::isCityRegion() {
	// server/zone/objects/area/ActiveArea.idl():  		return false;
	return false;
}

bool ActiveAreaImplementation::isNavArea() {
	// server/zone/objects/area/ActiveArea.idl():  		return false;
	return false;
}

NavArea* ActiveAreaImplementation::asNavArea() {
	// server/zone/objects/area/ActiveArea.idl():  		return null;
	return NULL;
}

bool ActiveAreaImplementation::isNoBuildArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return noBuildArea;
	return noBuildArea;
}

bool ActiveAreaImplementation::isCampingPermitted() const{
	// server/zone/objects/area/ActiveArea.idl():  		return campingPermitted;
	return campingPermitted;
}

float ActiveAreaImplementation::getRadius2() {
	// server/zone/objects/area/ActiveArea.idl():  		}
	if (areaShape != NULL){
	// server/zone/objects/area/ActiveArea.idl():  			return areaShape.getRadius() * areaShape.getRadius();
	return areaShape->getRadius() * areaShape->getRadius();
}

	else {
	// server/zone/objects/area/ActiveArea.idl():  			return super.getRadius() * super.getRadius();
	return SceneObjectImplementation::getRadius() * SceneObjectImplementation::getRadius();
}
}

void ActiveAreaImplementation::setNoBuildArea(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		noBuildArea = val;
	noBuildArea = val;
}

void ActiveAreaImplementation::setCampingPermitted(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		campingPermitted = val;
	campingPermitted = val;
}

void ActiveAreaImplementation::setMunicipalZone(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		municipalZone = val;
	municipalZone = val;
}

void ActiveAreaImplementation::setRadius(float r) {
	// server/zone/objects/area/ActiveArea.idl():  		super.
	if (areaShape != NULL && r < areaShape->getRadius()){
	// server/zone/objects/area/ActiveArea.idl():  			r = areaShape.getRadius();
	r = areaShape->getRadius();
}
	// server/zone/objects/area/ActiveArea.idl():  		super.setRadius(r);
	SceneObjectImplementation::setRadius(r);
}

bool ActiveAreaImplementation::isCampArea() {
	// server/zone/objects/area/ActiveArea.idl():  		return false;
	return false;
}

void ActiveAreaImplementation::setNoSpawnArea(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		noSpawnArea = val;
	noSpawnArea = val;
}

bool ActiveAreaImplementation::isNoSpawnArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return noSpawnArea;
	return noSpawnArea;
}

bool ActiveAreaImplementation::isMunicipalZone() const{
	// server/zone/objects/area/ActiveArea.idl():  		return municipalZone;
	return municipalZone;
}

unsigned long long ActiveAreaImplementation::getCellObjectID() const{
	// server/zone/objects/area/ActiveArea.idl():  		return cellObjectID;
	return cellObjectID;
}

void ActiveAreaImplementation::setCellObjectID(unsigned long long celloid) {
	// server/zone/objects/area/ActiveArea.idl():  		cellObjectID = celloid;
	cellObjectID = celloid;
}

void ActiveAreaImplementation::setAreaShape(AreaShape* area) {
	// server/zone/objects/area/ActiveArea.idl():  		areaShape = area;
	areaShape = area;
	// server/zone/objects/area/ActiveArea.idl():  	}
	if (areaShape != NULL){
	// server/zone/objects/area/ActiveArea.idl():  			setRadius(areaShape.getRadius());
	setRadius(areaShape->getRadius());
}
}

AreaShape* ActiveAreaImplementation::getAreaShape() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaShape;
	return areaShape;
}

void ActiveAreaImplementation::attachScenery(SceneObject* scene) {
	// server/zone/objects/area/ActiveArea.idl():  		attachedScenery.add(scene);
	(&attachedScenery)->add(scene);
}

/*
 *	ActiveAreaAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ActiveAreaAdapter::ActiveAreaAdapter(ActiveArea* obj) : SceneObjectAdapter(obj) {
}

void ActiveAreaAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			bool doClose = inv->getBooleanParameter();
			bool forceLoadContainer = inv->getBooleanParameter();
			
			sendTo(player, doClose, forceLoadContainer);
			
		}
		break;
	case RPC_ENQUEUEENTEREVENT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			enqueueEnterEvent(obj);
			
		}
		break;
	case RPC_ENQUEUEEXITEVENT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			enqueueExitEvent(obj);
			
		}
		break;
	case RPC_NOTIFYENTER__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyEnter(object);
			
		}
		break;
	case RPC_NOTIFYEXIT__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyExit(object);
			
		}
		break;
	case RPC_SETZONE__ZONE_:
		{
			Zone* zone = static_cast<Zone*>(inv->getObjectParameter());
			
			setZone(zone);
			
		}
		break;
	case RPC_ISACTIVEAREA__:
		{
			
			bool _m_res = isActiveArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISREGION__:
		{
			
			bool _m_res = isRegion();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCITYREGION__:
		{
			
			bool _m_res = isCityRegion();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNAVAREA__:
		{
			
			bool _m_res = isNavArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNOBUILDAREA__:
		{
			
			bool _m_res = isNoBuildArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCAMPINGPERMITTED__:
		{
			
			bool _m_res = isCampingPermitted();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CONTAINSPOINT__FLOAT_FLOAT_LONG_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			unsigned long long cellid = inv->getUnsignedLongParameter();
			
			bool _m_res = containsPoint(x, y, cellid);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CONTAINSPOINT__FLOAT_FLOAT_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			
			bool _m_res = containsPoint(x, y);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETRADIUS2__:
		{
			
			float _m_res = getRadius2();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETNOBUILDAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setNoBuildArea(val);
			
		}
		break;
	case RPC_SETCAMPINGPERMITTED__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setCampingPermitted(val);
			
		}
		break;
	case RPC_SETMUNICIPALZONE__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setMunicipalZone(val);
			
		}
		break;
	case RPC_SETRADIUS__FLOAT_:
		{
			float r = inv->getFloatParameter();
			
			setRadius(r);
			
		}
		break;
	case RPC_ISCAMPAREA__:
		{
			
			bool _m_res = isCampArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETNOSPAWNAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setNoSpawnArea(val);
			
		}
		break;
	case RPC_ISNOSPAWNAREA__:
		{
			
			bool _m_res = isNoSpawnArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISMUNICIPALZONE__:
		{
			
			bool _m_res = isMunicipalZone();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETCELLOBJECTID__:
		{
			
			unsigned long long _m_res = getCellObjectID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETCELLOBJECTID__LONG_:
		{
			unsigned long long celloid = inv->getUnsignedLongParameter();
			
			setCellObjectID(celloid);
			
		}
		break;
	case RPC_SETAREASHAPE__AREASHAPE_:
		{
			AreaShape* area = static_cast<AreaShape*>(inv->getObjectParameter());
			
			setAreaShape(area);
			
		}
		break;
	case RPC_GETAREASHAPE__:
		{
			
			DistributedObject* _m_res = getAreaShape();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_INTERSECTSWITH__ACTIVEAREA_:
		{
			ActiveArea* area = static_cast<ActiveArea*>(inv->getObjectParameter());
			
			bool _m_res = intersectsWith(area);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ATTACHSCENERY__SCENEOBJECT_:
		{
			SceneObject* scene = static_cast<SceneObject*>(inv->getObjectParameter());
			
			attachScenery(scene);
			
		}
		break;
	case RPC_INITIALIZECHILDOBJECT__SCENEOBJECT_:
		{
			SceneObject* controllerObject = static_cast<SceneObject*>(inv->getObjectParameter());
			
			initializeChildObject(controllerObject);
			
		}
		break;
	default:
		SceneObjectAdapter::invokeMethod(methid, inv);
	}
}

void ActiveAreaAdapter::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	(static_cast<ActiveArea*>(stub))->sendTo(player, doClose, forceLoadContainer);
}

void ActiveAreaAdapter::enqueueEnterEvent(SceneObject* obj) {
	(static_cast<ActiveArea*>(stub))->enqueueEnterEvent(obj);
}

void ActiveAreaAdapter::enqueueExitEvent(SceneObject* obj) {
	(static_cast<ActiveArea*>(stub))->enqueueExitEvent(obj);
}

void ActiveAreaAdapter::notifyEnter(SceneObject* object) {
	(static_cast<ActiveArea*>(stub))->notifyEnter(object);
}

void ActiveAreaAdapter::notifyExit(SceneObject* object) {
	(static_cast<ActiveArea*>(stub))->notifyExit(object);
}

void ActiveAreaAdapter::setZone(Zone* zone) {
	(static_cast<ActiveArea*>(stub))->setZone(zone);
}

bool ActiveAreaAdapter::isActiveArea() {
	return (static_cast<ActiveArea*>(stub))->isActiveArea();
}

bool ActiveAreaAdapter::isRegion() {
	return (static_cast<ActiveArea*>(stub))->isRegion();
}

bool ActiveAreaAdapter::isCityRegion() {
	return (static_cast<ActiveArea*>(stub))->isCityRegion();
}

bool ActiveAreaAdapter::isNavArea() {
	return (static_cast<ActiveArea*>(stub))->isNavArea();
}

bool ActiveAreaAdapter::isNoBuildArea() const {
	return (static_cast<ActiveArea*>(stub))->isNoBuildArea();
}

bool ActiveAreaAdapter::isCampingPermitted() const {
	return (static_cast<ActiveArea*>(stub))->isCampingPermitted();
}

bool ActiveAreaAdapter::containsPoint(float x, float y, unsigned long long cellid) {
	return (static_cast<ActiveArea*>(stub))->containsPoint(x, y, cellid);
}

bool ActiveAreaAdapter::containsPoint(float x, float y) {
	return (static_cast<ActiveArea*>(stub))->containsPoint(x, y);
}

float ActiveAreaAdapter::getRadius2() {
	return (static_cast<ActiveArea*>(stub))->getRadius2();
}

void ActiveAreaAdapter::setNoBuildArea(bool val) {
	(static_cast<ActiveArea*>(stub))->setNoBuildArea(val);
}

void ActiveAreaAdapter::setCampingPermitted(bool val) {
	(static_cast<ActiveArea*>(stub))->setCampingPermitted(val);
}

void ActiveAreaAdapter::setMunicipalZone(bool val) {
	(static_cast<ActiveArea*>(stub))->setMunicipalZone(val);
}

void ActiveAreaAdapter::setRadius(float r) {
	(static_cast<ActiveArea*>(stub))->setRadius(r);
}

bool ActiveAreaAdapter::isCampArea() {
	return (static_cast<ActiveArea*>(stub))->isCampArea();
}

void ActiveAreaAdapter::setNoSpawnArea(bool val) {
	(static_cast<ActiveArea*>(stub))->setNoSpawnArea(val);
}

bool ActiveAreaAdapter::isNoSpawnArea() const {
	return (static_cast<ActiveArea*>(stub))->isNoSpawnArea();
}

bool ActiveAreaAdapter::isMunicipalZone() const {
	return (static_cast<ActiveArea*>(stub))->isMunicipalZone();
}

unsigned long long ActiveAreaAdapter::getCellObjectID() const {
	return (static_cast<ActiveArea*>(stub))->getCellObjectID();
}

void ActiveAreaAdapter::setCellObjectID(unsigned long long celloid) {
	(static_cast<ActiveArea*>(stub))->setCellObjectID(celloid);
}

void ActiveAreaAdapter::setAreaShape(AreaShape* area) {
	(static_cast<ActiveArea*>(stub))->setAreaShape(area);
}

AreaShape* ActiveAreaAdapter::getAreaShape() const {
	return (static_cast<ActiveArea*>(stub))->getAreaShape();
}

bool ActiveAreaAdapter::intersectsWith(ActiveArea* area) {
	return (static_cast<ActiveArea*>(stub))->intersectsWith(area);
}

void ActiveAreaAdapter::attachScenery(SceneObject* scene) {
	(static_cast<ActiveArea*>(stub))->attachScenery(scene);
}

void ActiveAreaAdapter::initializeChildObject(SceneObject* controllerObject) {
	(static_cast<ActiveArea*>(stub))->initializeChildObject(controllerObject);
}

/*
 *	ActiveAreaHelper
 */

ActiveAreaHelper* ActiveAreaHelper::staticInitializer = ActiveAreaHelper::instance();

ActiveAreaHelper::ActiveAreaHelper() {
	className = "ActiveArea";

	Core::getObjectBroker()->registerClass(className, this);
}

void ActiveAreaHelper::finalizeHelper() {
	ActiveAreaHelper::finalize();
}

DistributedObject* ActiveAreaHelper::instantiateObject() {
	return new ActiveArea(DummyConstructorParameter::instance());
}

DistributedObjectServant* ActiveAreaHelper::instantiateServant() {
	return new ActiveAreaImplementation();
}

DistributedObjectAdapter* ActiveAreaHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ActiveAreaAdapter(static_cast<ActiveArea*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

