/*
 *	autogen/server/zone/objects/creature/CreatureObject.cpp generated by engine3 IDL compiler 0.60
 */

#include "CreatureObject.h"

#include "server/chat/StringIdChatParameter.h"

#include "server/zone/objects/group/GroupObject.h"

#include "server/zone/objects/guild/GuildObject.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

#include "server/zone/objects/player/PlayerObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/area/CampSiteActiveArea.h"

#include "server/zone/objects/creature/events/DizzyFallDownEvent.h"

#include "server/zone/objects/creature/buffs/Buff.h"

#include "server/zone/ZoneClientSession.h"

#include "server/zone/objects/creature/credits/CreditObject.h"

/*
 *	CreatureObjectStub
 */

unsigned const long long CreatureObject::DEAD_TOO_LONG = 1800000;

enum {RPC_INITIALIZEMEMBERS__ = 29990564,RPC_FINALIZE__,RPC_CREATECHILDOBJECTS__,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_SETCOUNTDOWNTIMER__INT_BOOL_,RPC_CLEARQUEUEACTION__INT_FLOAT_INT_INT_,RPC_CLEARQUEUEACTIONS__BOOL_,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SENDTOOWNER__BOOL_,RPC_SENDSYSTEMMESSAGE__STRING_,RPC_PLAYMUSICMESSAGE__STRING_,RPC_SENDNEWBIETUTORIALREQUEST__STRING_,RPC_SENDNEWBIETUTORIALENABLEHUDELEMENT__STRING_BOOL_FLOAT_,RPC_SENDOPENHOLOCRONTOPAGEMESSAGE__,RPC_SENDSYSTEMMESSAGE__UNICODESTRING_,RPC_SENDSLOTTEDOBJECTSTO__SCENEOBJECT_,RPC_SETCOMBATSTATE__,RPC_CLEARCOMBATSTATE__BOOL_,RPC_ADDMOUNTEDCOMBATSLOW__,RPC_REMOVEMOUNTEDCOMBATSLOW__BOOL_,RPC_SETPOSTURE__INT_BOOL_BOOL_,RPC_UPDATEPOSTURES__BOOL_,RPC_CALCULATESPEED__,RPC_UPDATELOCOMOTION__,RPC_SETHEIGHT__FLOAT_BOOL_,RPC_SETACCELERATIONMULTIPLIERBASE__FLOAT_BOOL_,RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_BOOL_,RPC_SETSPEEDMULTIPLIERBASE__FLOAT_BOOL_,RPC_SETSPEEDMULTIPLIERMOD__FLOAT_BOOL_,RPC_SETTURNSCALE__FLOAT_BOOL_,RPC_SETRUNSPEED__FLOAT_BOOL_,RPC_SETCURRENTSPEED__FLOAT_,RPC_SETHAM__INT_INT_BOOL_,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_,RPC_HASDAMAGE__INT_,RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_,RPC_HEALWOUND__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_,RPC_SETBASEHAM__INT_INT_BOOL_,RPC_SETWOUNDS__INT_INT_BOOL_,RPC_ADDWOUNDS__INT_INT_BOOL_BOOL_,RPC_SETMAXHAM__INT_INT_BOOL_,RPC_ADDMAXHAM__INT_INT_BOOL_,RPC_SETENCUMBRANCE__INT_INT_BOOL_,RPC_ADDENCUMBRANCE__INT_INT_BOOL_,RPC_SETWEAPON__WEAPONOBJECT_BOOL_,RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_,RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_,RPC_SETINSTRUMENTID__INT_BOOL_,RPC_SETLISTENTOID__LONG_BOOL_,RPC_SETPERFORMANCECOUNTER__INT_BOOL_,RPC_SETPERFORMANCEANIMATION__STRING_BOOL_,RPC_SETSHOCKWOUNDS__INT_BOOL_,RPC_ADDSHOCKWOUNDS__INT_BOOL_BOOL_,RPC_SETTARGETID__LONG_BOOL_,RPC_SETBANKCREDITS__INT_BOOL_,RPC_ADDBUFF__BUFF_,RPC_REMOVEBUFF__INT_,RPC_REMOVEBUFF__BUFF_,RPC_REMOVESTATEBUFF__LONG_,RPC_CLEARBUFFS__BOOL_BOOL_,RPC_RENEWBUFF__INT_INT_BOOL_,RPC_UPDATEVEHICLEPOSITION__BOOL_,RPC_ADDWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_,RPC_REMOVEWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_,RPC_SENDBUFFSTO__CREATUREOBJECT_,RPC_GETBUFF__INT_,RPC_GETSKILLMODFROMBUFFS__STRING_,RPC_ADDDOTSTATE__CREATUREOBJECT_LONG_LONG_INT_BYTE_INT_FLOAT_INT_INT_,RPC_HEALDOT__LONG_INT_BOOL_,RPC_CLEARDOTS__,RPC_HASBUFF__INT_,RPC_NOTIFYSELFPOSITIONUPDATE__,RPC_NOTIFYPOSTURECHANGE__INT_,RPC_SETLEVEL__INT_BOOL_,RPC_UPDATETODATABASEALLOBJECTS__BOOL_,RPC_ISRESUSCITABLE__,RPC_ADDBANKCREDITS__INT_BOOL_,RPC_ADDCASHCREDITS__INT_BOOL_,RPC_GETCREDITOBJECT__,RPC_SUBTRACTBANKCREDITS__INT_,RPC_SUBTRACTCASHCREDITS__INT_,RPC_VERIFYCASHCREDITS__INT_,RPC_VERIFYBANKCREDITS__INT_,RPC_ISDANCING__,RPC_ISPLAYINGMUSIC__,RPC_STOPENTERTAINING__,RPC_ISENTERTAINING__,RPC_SETCASHCREDITS__INT_BOOL_,RPC_SETTERRAINNEGOTIATION__FLOAT_BOOL_,RPC_UPDATETERRAINNEGOTIATION__,RPC_ADDSKILL__STRING_BOOL_,RPC_REMOVESKILL__STRING_BOOL_,RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_,RPC_REMOVESKILLMOD__INT_STRING_INT_BOOL_,RPC_REMOVEALLSKILLMODSOFTYPE__INT_BOOL_,RPC_UPDATEGROUPINVITERID__LONG_BOOL_,RPC_UPDATEGROUP__GROUPOBJECT_BOOL_,RPC_ENQUEUECOMMAND__INT_INT_LONG_UNICODESTRING_INT_INT_,RPC_SENDCOMMAND__INT_UNICODESTRING_LONG_INT_,RPC_SENDCOMMAND__STRING_UNICODESTRING_LONG_INT_,RPC_SETMOOD__BYTE_BOOL_,RPC_SETMOODSTRING__STRING_BOOL_,RPC_DELETEQUEUEACTION__INT_,RPC_SETSTATE__LONG_BOOL_,RPC_SETALTERNATEAPPEARANCE__STRING_BOOL_,RPC_CLEARSTATE__LONG_BOOL_,RPC_SETCONTROLDEVICE__CONTROLDEVICE_,RPC_SETCREATURELINK__CREATUREOBJECT_BOOL_,RPC_EXECUTEOBJECTCONTROLLERACTION__INT_,RPC_EXECUTEOBJECTCONTROLLERACTION__INT_LONG_UNICODESTRING_,RPC_ISATTACKABLEBY__CREATUREOBJECT_,RPC_ISATTACKABLEBY__CREATUREOBJECT_BOOL_,RPC_ISATTACKABLEBY__TANGIBLEOBJECT_,RPC_ISATTACKABLEBY__TANGIBLEOBJECT_BOOL_,RPC_ISHEALABLEBY__CREATUREOBJECT_,RPC_HASBOUNTYMISSIONFOR__CREATUREOBJECT_,RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_,RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_,RPC_SENDMESSAGE__BASEPACKET_,RPC_SENDSTATECOMBATSPAM__STRING_STRING_BYTE_INT_BOOL_,RPC_SENDCUSTOMCOMBATSPAM__UNICODESTRING_BYTE_,RPC_SENDEXECUTECONSOLECOMMAND__STRING_,RPC_ISAGGRESSIVETO__CREATUREOBJECT_,RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_,RPC_NOTIFYOBJECTKILLOBSERVERS__TANGIBLEOBJECT_,RPC_NOTIFYLOADFROMDATABASE__,RPC_DESTROYOBJECTFROMDATABASE__BOOL_,RPC_SETFACTIONRANK__INT_BOOL_,RPC_GETFIRSTNAME__,RPC_GETLASTNAME__,RPC_ISONLINE__,RPC_CANTREATINJURIES__,RPC_CANTREATSTATES__,RPC_CANTREATWOUNDS__,RPC_CANTREATCONDITIONS__,RPC_GETPLAYEROBJECT__,RPC_ISLISTENING__,RPC_ISWATCHING__,RPC_SETCLIENT__ZONECLIENTSESSION_,RPC_DISMOUNT__,RPC_CALCULATEBFRATIO__,RPC_REMOVEFEIGNEDDEATH__,RPC_CANFEIGNDEATH__,RPC_FEIGNDEATH__,RPC_SETFEIGNEDDEATHSTATE__,RPC_SETDIZZIEDSTATE__INT_,RPC_SETRALLIEDSTATE__INT_,RPC_SETAIMINGSTATE__INT_,RPC_SETCOVERSTATE__INT_,RPC_SETBERSERKEDSTATE__INT_,RPC_SETSTUNNEDSTATE__INT_,RPC_SETBLINDEDSTATE__INT_,RPC_SETINTIMIDATEDSTATE__INT_,RPC_SETSNAREDSTATE__INT_,RPC_SETROOTEDSTATE__INT_,RPC_SETNEXTATTACKDELAY__INT_INT_,RPC_SETMEDITATESTATE__,RPC_ACTIVATEHAMREGENERATION__INT_,RPC_ACTIVATEPASSIVEWOUNDREGENERATION__,RPC_ACTIVATESTATERECOVERY__,RPC_UPDATETIMEOFDEATH__,RPC_HASATTACKDELAY__,RPC_REMOVEATTACKDELAY__,RPC_HASINCAPTIMER__,RPC_HASSPICE__,RPC_UPDATELASTSUCCESSFULCOMBATACTION__,RPC_UPDATEPOSTURECHANGEDELAY__LONG_,RPC_CHECKPOSTURECHANGEDELAY__,RPC_UPDATEPOSTUREDOWNRECOVERY__,RPC_CHECKPOSTUREDOWNRECOVERY__,RPC_UPDATEPOSTUREUPRECOVERY__,RPC_CHECKPOSTUREUPRECOVERY__,RPC_UPDATEKNOCKDOWNRECOVERY__,RPC_CHECKKNOCKDOWNRECOVERY__,RPC_UPDATEGROUPMFDPOSITIONS__,RPC_QUEUEDIZZYFALLEVENT__,RPC_HASDIZZYEVENT__,RPC_CLEARDIZZYEVENT__,RPC_GETSCREENPLAYSTATE__STRING_,RPC_SETSCREENPLAYSTATE__STRING_LONG_,RPC_UPDATECOOLDOWNTIMER__STRING_LONG_,RPC_CHECKCOOLDOWNRECOVERY__STRING_,RPC_ADDCOOLDOWN__STRING_LONG_,RPC_DOANIMATION__STRING_,RPC_DOCOMBATANIMATION__TANGIBLEOBJECT_INT_BYTE_BYTE_LONG_,RPC_DOCOMBATANIMATION__INT_,RPC_ACTIVATEQUEUEACTION__,RPC_ACTIVATEIMMEDIATEACTION__,RPC_GETCREATURENAME__,RPC_ISGROUPED__,RPC_GETBANKCREDITS__,RPC_GETCASHCREDITS__,RPC_GETBASEHAM__INT_,RPC_GETWOUNDS__INT_,RPC_GETHAM__INT_,RPC_GETMAXHAM__INT_,RPC_GETENCUMBRANCE__INT_,RPC_GETPOSTURE__,RPC_GETLOCOMOTION__,RPC_GETFACTIONRANK__,RPC_GETLINKEDCREATURE__,RPC_GETCREATURELINKID__,RPC_GETSHOCKWOUNDS__,RPC_GETWATCHTOID__,RPC_GETSTATEBITMASK__,RPC_HASSTATE__LONG_,RPC_HASSTATES__,RPC_GETLISTENID__,RPC_GETACCELERATIONMULTIPLIERBASE__,RPC_GETACCELERATIONMULTIPLIERMOD__,RPC_GETSPEEDMULTIPLIERBASE__,RPC_GETSPEEDMULTIPLIERMOD__,RPC_GETCURRENTSPEED__,RPC_GETCOMMANDQUEUESIZE__,RPC_SETLASTACTIONCOUNTER__INT_,RPC_INCREMENTLASTACTIONCOUNTER__,RPC_GETLASTACTIONCOUNTER__,RPC_GETRUNSPEED__,RPC_GETWALKSPEED__,RPC_GETTURNSCALE__,RPC_GETTERRAINNEGOTIATION__,RPC_GETRUNACCELERATION__,RPC_GETWALKACCELERATION__,RPC_GETPERFORMANCEANIMATION__,RPC_GETMOODSTRING__,RPC_GETWEAPONID__,RPC_GETWEAPON__,RPC_GETGUILDOBJECT__,RPC_GETGUILDID__,RPC_ISINGUILD__,RPC_SETGUILDOBJECT__GUILDOBJECT_,RPC_GETGROUPID__,RPC_GETGROUPINVITERID__,RPC_GETGROUP__,RPC_GETGROUPINVITECOUNTER__,RPC_GETTARGETID__,RPC_GETMOODID__,RPC_GETSLOPEMODPERCENT__,RPC_GETPERFORMANCECOUNTER__,RPC_GETINSTRUMENTID__,RPC_GETFROZEN__,RPC_GETHEIGHT__,RPC_ISDROIDSPECIES__,RPC_ISWALKERSPECIES__,RPC_ISPROBOTSPECIES__,RPC_HASEFFECTIMMUNITY__BYTE_,RPC_HASDOTIMMUNITY__INT_,RPC_GETSPECIES__,RPC_GETSPECIESNAME__,RPC_GETGENDER__,RPC_GETSKILLMOD__STRING_,RPC_GETSKILLMODOFTYPE__STRING_INT_,RPC_HASSKILL__STRING_,RPC_SETWATCHTOID__LONG_,RPC_ISCREATUREOBJECT__,RPC_ISNEXTACTIONPAST__,RPC_ISSWIMMING__,RPC_GETCLIENT__,RPC_GETCONTROLDEVICE__,RPC_GETSWIMHEIGHT__,RPC_ISINCAPACITATED__,RPC_ISDEAD__,RPC_ISKNOCKEDDOWN__,RPC_ISKNEELING__,RPC_ISPRONE__,RPC_ISSTANDING__,RPC_ISSITTING__,RPC_ISSKILLANIMATING__,RPC_ISRALLIED__,RPC_ISINCOMBAT__,RPC_ISDIZZIED__,RPC_ISBERSERKED__,RPC_ISSTUNNED__,RPC_ISBLINDED__,RPC_ISINTIMIDATED__,RPC_ISSNARED__,RPC_ISIMMOBILIZED__,RPC_ISROOTED__,RPC_ISFROZEN__,RPC_ISDISEASED__,RPC_ISPOISONED__,RPC_ISBLEEDING__,RPC_ISONFIRE__,RPC_ISFEIGNINGDEATH__,RPC_ISRIDINGMOUNT__,RPC_HASRIDINGCREATURE__,RPC_ISPEACED__,RPC_ISMEDITATING__,RPC_ISAIMING__,RPC_ISINCOVER__,RPC_ISRUNNING__,RPC_ISNONPLAYERCREATUREOBJECT__,RPC_ISDROIDOBJECT__,RPC_ISPLAYERCREATURE__,RPC_REGISTERTOCLOSEOBJECTSRECEIVERS__,RPC_ISINFORMANTCREATURE__,RPC_GETCURRENTCAMP__,RPC_GETCURRENTWEATHER__,RPC_SETCURRENTWEATHER__BYTE_,RPC_GETCURRENTWIND__,RPC_SETCURRENTWIND__BYTE_,RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_GETALTERNATEAPPEARANCE__,RPC_CALCULATECOSTADJUSTMENT__BYTE_FLOAT_,RPC_UPDATESPEEDANDACCELERATIONMODS__,RPC_SETFACTION__INT_,RPC_DESTROYPLAYERCREATUREFROMDATABASE__BOOL_,RPC_GETTEMPLATERADIUS__,RPC_RELOADTEMPLATE__};

CreatureObject::CreatureObject() : TangibleObject(DummyConstructorParameter::instance()) {
	CreatureObjectImplementation* _implementation = new CreatureObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("CreatureObject");
}

CreatureObject::CreatureObject(DummyConstructorParameter* param) : TangibleObject(param) {
	_setClassName("CreatureObject");
}

CreatureObject::~CreatureObject() {
}



void CreatureObject::initializeMembers() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeMembers();
	}
}

void CreatureObject::createChildObjects() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATECHILDOBJECTS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->createChildObjects();
	}
}

void CreatureObject::loadTemplateData(SharedObjectTemplate* templateData) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void CreatureObject::initializeTransientMembers() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void CreatureObject::setCountdownTimer(unsigned int newCount, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOUNTDOWNTIMER__INT_BOOL_);
		method.addUnsignedIntParameter(newCount);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCountdownTimer(newCount, notifyClient);
	}
}

void CreatureObject::clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARQUEUEACTION__INT_FLOAT_INT_INT_);
		method.addUnsignedIntParameter(actioncntr);
		method.addFloatParameter(timer);
		method.addUnsignedIntParameter(tab1);
		method.addUnsignedIntParameter(tab2);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearQueueAction(actioncntr, timer, tab1, tab2);
	}
}

void CreatureObject::clearQueueActions(bool combatOnly) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARQUEUEACTIONS__BOOL_);
		method.addBooleanParameter(combatOnly);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearQueueActions(combatOnly);
	}
}

void CreatureObject::sendBaselinesTo(SceneObject* player) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

void CreatureObject::sendToOwner(bool doClose) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTOOWNER__BOOL_);
		method.addBooleanParameter(doClose);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendToOwner(doClose);
	}
}

void CreatureObject::sendSystemMessage(const String& message) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSYSTEMMESSAGE__STRING_);
		method.addAsciiParameter(message);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendSystemMessage(message);
	}
}

void CreatureObject::playMusicMessage(const String& file) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PLAYMUSICMESSAGE__STRING_);
		method.addAsciiParameter(file);

		method.executeWithVoidReturn();
	} else {
		_implementation->playMusicMessage(file);
	}
}

void CreatureObject::sendNewbieTutorialRequest(const String& request) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDNEWBIETUTORIALREQUEST__STRING_);
		method.addAsciiParameter(request);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendNewbieTutorialRequest(request);
	}
}

void CreatureObject::sendNewbieTutorialEnableHudElement(const String& ui, bool enable, float blinkCount) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDNEWBIETUTORIALENABLEHUDELEMENT__STRING_BOOL_FLOAT_);
		method.addAsciiParameter(ui);
		method.addBooleanParameter(enable);
		method.addFloatParameter(blinkCount);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendNewbieTutorialEnableHudElement(ui, enable, blinkCount);
	}
}

void CreatureObject::sendOpenHolocronToPageMessage() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDOPENHOLOCRONTOPAGEMESSAGE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendOpenHolocronToPageMessage();
	}
}

void CreatureObject::sendSystemMessage(UnicodeString& message) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSYSTEMMESSAGE__UNICODESTRING_);
		method.addUnicodeParameter(message);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendSystemMessage(message);
	}
}

void CreatureObject::sendSystemMessage(StringIdChatParameter& stringid) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->sendSystemMessage(stringid);
	}
}

void CreatureObject::sendSlottedObjectsTo(SceneObject* player) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSLOTTEDOBJECTSTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendSlottedObjectsTo(player);
	}
}

void CreatureObject::setCombatState() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMBATSTATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCombatState();
	}
}

void CreatureObject::clearCombatState(bool clearDefenders) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCOMBATSTATE__BOOL_);
		method.addBooleanParameter(clearDefenders);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearCombatState(clearDefenders);
	}
}

void CreatureObject::addMountedCombatSlow() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDMOUNTEDCOMBATSLOW__);

		method.executeWithVoidReturn();
	} else {
		_implementation->addMountedCombatSlow();
	}
}

void CreatureObject::removeMountedCombatSlow(bool showEndMessage) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEMOUNTEDCOMBATSLOW__BOOL_);
		method.addBooleanParameter(showEndMessage);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeMountedCombatSlow(showEndMessage);
	}
}

void CreatureObject::setPosture(int newPosture, bool immediate, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPOSTURE__INT_BOOL_BOOL_);
		method.addSignedIntParameter(newPosture);
		method.addBooleanParameter(immediate);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPosture(newPosture, immediate, notifyClient);
	}
}

void CreatureObject::updatePostures(bool immediate) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPOSTURES__BOOL_);
		method.addBooleanParameter(immediate);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updatePostures(immediate);
	}
}

float CreatureObject::calculateSpeed() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATESPEED__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->calculateSpeed();
	}
}

void CreatureObject::updateLocomotion() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELOCOMOTION__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updateLocomotion();
	}
}

void CreatureObject::setHeight(float heigh, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHEIGHT__FLOAT_BOOL_);
		method.addFloatParameter(heigh);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setHeight(heigh, notifyClient);
	}
}

void CreatureObject::setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCELERATIONMULTIPLIERBASE__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierBase);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAccelerationMultiplierBase(newMultiplierBase, notifyClient);
	}
}

void CreatureObject::setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierMod);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAccelerationMultiplierMod(newMultiplierMod, notifyClient);
	}
}

void CreatureObject::setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPEEDMULTIPLIERBASE__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierBase);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSpeedMultiplierBase(newMultiplierBase, notifyClient);
	}
}

void CreatureObject::setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPEEDMULTIPLIERMOD__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierMod);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSpeedMultiplierMod(newMultiplierMod, notifyClient);
	}
}

void CreatureObject::setTurnScale(float newMultiplierMod, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTURNSCALE__FLOAT_BOOL_);
		method.addFloatParameter(newMultiplierMod);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setTurnScale(newMultiplierMod, notifyClient);
	}
}

void CreatureObject::setRunSpeed(float newSpeed, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRUNSPEED__FLOAT_BOOL_);
		method.addFloatParameter(newSpeed);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRunSpeed(newSpeed, notifyClient);
	}
}

void CreatureObject::setCurrentSpeed(float newSpeed) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTSPEED__FLOAT_);
		method.addFloatParameter(newSpeed);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCurrentSpeed(newSpeed);
	}
}

void CreatureObject::setHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setHAM(type, value, notifyClient);
	}
}

int CreatureObject::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
	}
}

int CreatureObject::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addAsciiParameter(xp);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
	}
}

bool CreatureObject::hasDamage(int attribute) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASDAMAGE__INT_);
		method.addSignedIntParameter(attribute);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasDamage(attribute);
	}
}

int CreatureObject::healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_);
		method.addObjectParameter(healer);
		method.addSignedIntParameter(damageType);
		method.addSignedIntParameter(damage);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(notifyObservers);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->healDamage(healer, damageType, damage, notifyClient, notifyObservers);
	}
}

int CreatureObject::healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALWOUND__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_);
		method.addObjectParameter(healer);
		method.addSignedIntParameter(damageType);
		method.addSignedIntParameter(damage);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(notifyObservers);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->healWound(healer, damageType, damage, notifyClient, notifyObservers);
	}
}

void CreatureObject::setBaseHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBASEHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBaseHAM(type, value, notifyClient);
	}
}

void CreatureObject::setWounds(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWOUNDS__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setWounds(type, value, notifyClient);
	}
}

int CreatureObject::addWounds(int type, int value, bool notifyClient, bool doShockWounds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWOUNDS__INT_INT_BOOL_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(doShockWounds);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->addWounds(type, value, notifyClient, doShockWounds);
	}
}

void CreatureObject::setMaxHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMaxHAM(type, value, notifyClient);
	}
}

void CreatureObject::addMaxHAM(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDMAXHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addMaxHAM(type, value, notifyClient);
	}
}

void CreatureObject::setEncumbrance(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETENCUMBRANCE__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setEncumbrance(type, value, notifyClient);
	}
}

void CreatureObject::addEncumbrance(int type, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDENCUMBRANCE__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addEncumbrance(type, value, notifyClient);
	}
}

void CreatureObject::setWeapon(WeaponObject* weao, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWEAPON__WEAPONOBJECT_BOOL_);
		method.addObjectParameter(weao);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setWeapon(weao, notifyClient);
	}
}

int CreatureObject::notifyObjectInserted(SceneObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyObjectInserted(object);
	}
}

int CreatureObject::notifyObjectRemoved(SceneObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyObjectRemoved(object);
	}
}

void CreatureObject::setInstrumentID(int instrumentid, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINSTRUMENTID__INT_BOOL_);
		method.addSignedIntParameter(instrumentid);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setInstrumentID(instrumentid, notifyClient);
	}
}

void CreatureObject::setListenToID(unsigned long long id, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLISTENTOID__LONG_BOOL_);
		method.addUnsignedLongParameter(id);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setListenToID(id, notifyClient);
	}
}

void CreatureObject::setPerformanceCounter(int counter, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMANCECOUNTER__INT_BOOL_);
		method.addSignedIntParameter(counter);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPerformanceCounter(counter, notifyClient);
	}
}

void CreatureObject::setPerformanceAnimation(const String& animation, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMANCEANIMATION__STRING_BOOL_);
		method.addAsciiParameter(animation);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPerformanceAnimation(animation, notifyClient);
	}
}

void CreatureObject::setShockWounds(int newShock, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSHOCKWOUNDS__INT_BOOL_);
		method.addSignedIntParameter(newShock);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setShockWounds(newShock, notifyClient);
	}
}

void CreatureObject::addShockWounds(int shockToAdd, bool notiyClient, bool sendSpam) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSHOCKWOUNDS__INT_BOOL_BOOL_);
		method.addSignedIntParameter(shockToAdd);
		method.addBooleanParameter(notiyClient);
		method.addBooleanParameter(sendSpam);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addShockWounds(shockToAdd, notiyClient, sendSpam);
	}
}

void CreatureObject::setTargetID(unsigned long long targetID, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTARGETID__LONG_BOOL_);
		method.addUnsignedLongParameter(targetID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setTargetID(targetID, notifyClient);
	}
}

void CreatureObject::setBankCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBANKCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setBankCredits(credits, notifyClient);
	}
}

void CreatureObject::addBuff(Buff* buff) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDBUFF__BUFF_);
		method.addObjectParameter(buff);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((buff == NULL) || buff->isLockedByCurrentThread());
		_implementation->addBuff(buff);
	}
}

bool CreatureObject::removeBuff(unsigned int buffcrc) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEBUFF__INT_);
		method.addUnsignedIntParameter(buffcrc);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->removeBuff(buffcrc);
	}
}

void CreatureObject::removeBuff(Buff* buff) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEBUFF__BUFF_);
		method.addObjectParameter(buff);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((buff == NULL) || buff->isLockedByCurrentThread());
		_implementation->removeBuff(buff);
	}
}

bool CreatureObject::removeStateBuff(unsigned long long state) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESTATEBUFF__LONG_);
		method.addUnsignedLongParameter(state);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->removeStateBuff(state);
	}
}

void CreatureObject::clearBuffs(bool updateclient, bool removeAll) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARBUFFS__BOOL_BOOL_);
		method.addBooleanParameter(updateclient);
		method.addBooleanParameter(removeAll);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearBuffs(updateclient, removeAll);
	}
}

void CreatureObject::renewBuff(unsigned int buffCRC, int duration, bool sendToClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RENEWBUFF__INT_INT_BOOL_);
		method.addUnsignedIntParameter(buffCRC);
		method.addSignedIntParameter(duration);
		method.addBooleanParameter(sendToClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->renewBuff(buffCRC, duration, sendToClient);
	}
}

void CreatureObject::updateVehiclePosition(bool sendPackets) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEVEHICLEPOSITION__BOOL_);
		method.addBooleanParameter(sendPackets);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateVehiclePosition(sendPackets);
	}
}

void CreatureObject::addWearableObject(TangibleObject* object, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addWearableObject(object, notifyClient);
	}
}

void CreatureObject::removeWearableObject(TangibleObject* object, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeWearableObject(object, notifyClient);
	}
}

WearablesDeltaVector* CreatureObject::getWearablesDeltaVector() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getWearablesDeltaVector();
	}
}

void CreatureObject::sendBuffsTo(CreatureObject* creature) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBUFFSTO__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBuffsTo(creature);
	}
}

BuffList* CreatureObject::getBuffList() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getBuffList();
	}
}

Buff* CreatureObject::getBuff(unsigned int buffcrc) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBUFF__INT_);
		method.addUnsignedIntParameter(buffcrc);

		return static_cast<Buff*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getBuff(buffcrc);
	}
}

long long CreatureObject::getSkillModFromBuffs(const String& skillMod) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLMODFROMBUFFS__STRING_);
		method.addAsciiParameter(skillMod);

		return method.executeWithSignedLongReturn();
	} else {
		return _implementation->getSkillModFromBuffs(skillMod);
	}
}

int CreatureObject::addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTSTATE__CREATUREOBJECT_LONG_LONG_INT_BYTE_INT_FLOAT_INT_INT_);
		method.addObjectParameter(attacker);
		method.addUnsignedLongParameter(dotType);
		method.addUnsignedLongParameter(objectID);
		method.addUnsignedIntParameter(strength);
		method.addByteParameter(type);
		method.addUnsignedIntParameter(duration);
		method.addFloatParameter(potency);
		method.addUnsignedIntParameter(defense);
		method.addSignedIntParameter(secondaryStrength);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
	}
}

bool CreatureObject::healDot(unsigned long long dotType, int reduction, bool sendMsg) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALDOT__LONG_INT_BOOL_);
		method.addUnsignedLongParameter(dotType);
		method.addSignedIntParameter(reduction);
		method.addBooleanParameter(sendMsg);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->healDot(dotType, reduction, sendMsg);
	}
}

void CreatureObject::clearDots() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARDOTS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearDots();
	}
}

DamageOverTimeList* CreatureObject::getDamageOverTimeList() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getDamageOverTimeList();
	}
}

bool CreatureObject::hasBuff(unsigned int buffcrc) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASBUFF__INT_);
		method.addUnsignedIntParameter(buffcrc);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasBuff(buffcrc);
	}
}

void CreatureObject::notifySelfPositionUpdate() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYSELFPOSITIONUPDATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->notifySelfPositionUpdate();
	}
}

void CreatureObject::notifyPostureChange(int newPosture) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYPOSTURECHANGE__INT_);
		method.addSignedIntParameter(newPosture);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->notifyPostureChange(newPosture);
	}
}

void CreatureObject::setLevel(int level, bool randomHam) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLEVEL__INT_BOOL_);
		method.addSignedIntParameter(level);
		method.addBooleanParameter(randomHam);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLevel(level, randomHam);
	}
}

void CreatureObject::updateToDatabaseAllObjects(bool startTask) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATETODATABASEALLOBJECTS__BOOL_);
		method.addBooleanParameter(startTask);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateToDatabaseAllObjects(startTask);
	}
}

bool CreatureObject::isResuscitable() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRESUSCITABLE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isResuscitable();
	}
}

void CreatureObject::addBankCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDBANKCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addBankCredits(credits, notifyClient);
	}
}

void CreatureObject::addCashCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCASHCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addCashCredits(credits, notifyClient);
	}
}

CreditObject* CreatureObject::getCreditObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREDITOBJECT__);

		return static_cast<CreditObject*>(method.executeWithObjectReturn());
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getCreditObject();
	}
}

void CreatureObject::subtractBankCredits(int credits) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SUBTRACTBANKCREDITS__INT_);
		method.addSignedIntParameter(credits);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->subtractBankCredits(credits);
	}
}

void CreatureObject::subtractCashCredits(int credits) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SUBTRACTCASHCREDITS__INT_);
		method.addSignedIntParameter(credits);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->subtractCashCredits(credits);
	}
}

bool CreatureObject::verifyCashCredits(int credits) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VERIFYCASHCREDITS__INT_);
		method.addSignedIntParameter(credits);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->verifyCashCredits(credits);
	}
}

bool CreatureObject::verifyBankCredits(int credits) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VERIFYBANKCREDITS__INT_);
		method.addSignedIntParameter(credits);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->verifyBankCredits(credits);
	}
}

bool CreatureObject::isDancing() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDANCING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDancing();
	}
}

bool CreatureObject::isPlayingMusic() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYINGMUSIC__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPlayingMusic();
	}
}

void CreatureObject::stopEntertaining() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPENTERTAINING__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->stopEntertaining();
	}
}

bool CreatureObject::isEntertaining() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISENTERTAINING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isEntertaining();
	}
}

void CreatureObject::setCashCredits(int credits, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCASHCREDITS__INT_BOOL_);
		method.addSignedIntParameter(credits);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCashCredits(credits, notifyClient);
	}
}

void CreatureObject::setTerrainNegotiation(float value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTERRAINNEGOTIATION__FLOAT_BOOL_);
		method.addFloatParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setTerrainNegotiation(value, notifyClient);
	}
}

void CreatureObject::updateTerrainNegotiation() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATETERRAINNEGOTIATION__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateTerrainNegotiation();
	}
}

void CreatureObject::addSkill(Skill* skill, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addSkill(skill, notifyClient);
	}
}

void CreatureObject::addSkill(const String& skill, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILL__STRING_BOOL_);
		method.addAsciiParameter(skill);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addSkill(skill, notifyClient);
	}
}

void CreatureObject::removeSkill(Skill* skill, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeSkill(skill, notifyClient);
	}
}

void CreatureObject::removeSkill(const String& skill, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILL__STRING_BOOL_);
		method.addAsciiParameter(skill);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeSkill(skill, notifyClient);
	}
}

void CreatureObject::addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_);
		method.addSignedIntParameter(modType);
		method.addAsciiParameter(skillMod);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addSkillMod(modType, skillMod, value, notifyClient);
	}
}

void CreatureObject::removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILLMOD__INT_STRING_INT_BOOL_);
		method.addSignedIntParameter(modType);
		method.addAsciiParameter(skillMod);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeSkillMod(modType, skillMod, value, notifyClient);
	}
}

void CreatureObject::removeAllSkillModsOfType(const int modType, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEALLSKILLMODSOFTYPE__INT_BOOL_);
		method.addSignedIntParameter(modType);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeAllSkillModsOfType(modType, notifyClient);
	}
}

void CreatureObject::updateGroupInviterID(unsigned long long id, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEGROUPINVITERID__LONG_BOOL_);
		method.addUnsignedLongParameter(id);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updateGroupInviterID(id, notifyClient);
	}
}

void CreatureObject::updateGroup(GroupObject* group, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEGROUP__GROUPOBJECT_BOOL_);
		method.addObjectParameter(group);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updateGroup(group, notifyClient);
	}
}

void CreatureObject::enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority, int compareCount) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENQUEUECOMMAND__INT_INT_LONG_UNICODESTRING_INT_INT_);
		method.addUnsignedIntParameter(actionCRC);
		method.addUnsignedIntParameter(actionCount);
		method.addUnsignedLongParameter(targetID);
		method.addUnicodeParameter(arguments);
		method.addSignedIntParameter(priority);
		method.addSignedIntParameter(compareCount);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->enqueueCommand(actionCRC, actionCount, targetID, arguments, priority, compareCount);
	}
}

void CreatureObject::sendCommand(unsigned int crc, const UnicodeString& args, unsigned long long targetID, int priority) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCOMMAND__INT_UNICODESTRING_LONG_INT_);
		method.addUnsignedIntParameter(crc);
		method.addUnicodeParameter(args);
		method.addUnsignedLongParameter(targetID);
		method.addSignedIntParameter(priority);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->sendCommand(crc, args, targetID, priority);
	}
}

void CreatureObject::sendCommand(const String& action, const UnicodeString& args, unsigned long long targetID, int priority) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCOMMAND__STRING_UNICODESTRING_LONG_INT_);
		method.addAsciiParameter(action);
		method.addUnicodeParameter(args);
		method.addUnsignedLongParameter(targetID);
		method.addSignedIntParameter(priority);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->sendCommand(action, args, targetID, priority);
	}
}

void CreatureObject::setMood(byte moodID, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMOOD__BYTE_BOOL_);
		method.addByteParameter(moodID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMood(moodID, notifyClient);
	}
}

void CreatureObject::setMoodString(const String& animation, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMOODSTRING__STRING_BOOL_);
		method.addAsciiParameter(animation);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMoodString(animation, notifyClient);
	}
}

void CreatureObject::deleteQueueAction(unsigned int actionCount) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DELETEQUEUEACTION__INT_);
		method.addUnsignedIntParameter(actionCount);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->deleteQueueAction(actionCount);
	}
}

bool CreatureObject::setState(unsigned long long state, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTATE__LONG_BOOL_);
		method.addUnsignedLongParameter(state);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->setState(state, notifyClient);
	}
}

void CreatureObject::setAlternateAppearance(const String& appearanceTeamplate, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETALTERNATEAPPEARANCE__STRING_BOOL_);
		method.addAsciiParameter(appearanceTeamplate);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAlternateAppearance(appearanceTeamplate, notifyClient);
	}
}

bool CreatureObject::clearState(unsigned long long state, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSTATE__LONG_BOOL_);
		method.addUnsignedLongParameter(state);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->clearState(state, notifyClient);
	}
}

void CreatureObject::setControlDevice(ControlDevice* device) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONTROLDEVICE__CONTROLDEVICE_);
		method.addObjectParameter(device);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setControlDevice(device);
	}
}

void CreatureObject::setCreatureLink(CreatureObject* object, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCREATURELINK__CREATUREOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCreatureLink(object, notifyClient);
	}
}

void CreatureObject::executeObjectControllerAction(unsigned int actionCRC) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EXECUTEOBJECTCONTROLLERACTION__INT_);
		method.addUnsignedIntParameter(actionCRC);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->executeObjectControllerAction(actionCRC);
	}
}

void CreatureObject::executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EXECUTEOBJECTCONTROLLERACTION__INT_LONG_UNICODESTRING_);
		method.addUnsignedIntParameter(actionCRC);
		method.addUnsignedLongParameter(targetID);
		method.addUnicodeParameter(args);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->executeObjectControllerAction(actionCRC, targetID, args);
	}
}

bool CreatureObject::isAttackableBy(CreatureObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(object);
	}
}

bool CreatureObject::isAttackableBy(CreatureObject* object, bool bypassDeadCheck) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__CREATUREOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(bypassDeadCheck);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(object, bypassDeadCheck);
	}
}

bool CreatureObject::isAttackableBy(TangibleObject* attacker) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__TANGIBLEOBJECT_);
		method.addObjectParameter(attacker);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(attacker);
	}
}

bool CreatureObject::isAttackableBy(TangibleObject* object, bool bypassDeadCheck) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__TANGIBLEOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(bypassDeadCheck);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(object, bypassDeadCheck);
	}
}

bool CreatureObject::isHealableBy(CreatureObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHEALABLEBY__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isHealableBy(object);
	}
}

bool CreatureObject::hasBountyMissionFor(CreatureObject* target) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASBOUNTYMISSIONFOR__CREATUREOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasBountyMissionFor(target);
	}
}

bool CreatureObject::sendConversationStartTo(SceneObject* player) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->sendConversationStartTo(player);
	}
}

void CreatureObject::selectConversationOption(int option, SceneObject* obj) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_);
		method.addSignedIntParameter(option);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->selectConversationOption(option, obj);
	}
}

void CreatureObject::sendMessage(BasePacket* msg) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDMESSAGE__BASEPACKET_);
		method.addObjectParameter(msg);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendMessage(msg);
	}
}

void CreatureObject::sendStateCombatSpam(const String& fileName, const String& stringName, byte color, int damage, bool broadcast) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSTATECOMBATSPAM__STRING_STRING_BYTE_INT_BOOL_);
		method.addAsciiParameter(fileName);
		method.addAsciiParameter(stringName);
		method.addByteParameter(color);
		method.addSignedIntParameter(damage);
		method.addBooleanParameter(broadcast);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendStateCombatSpam(fileName, stringName, color, damage, broadcast);
	}
}

void CreatureObject::sendCustomCombatSpam(const UnicodeString& customString, byte color) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCUSTOMCOMBATSPAM__UNICODESTRING_BYTE_);
		method.addUnicodeParameter(customString);
		method.addByteParameter(color);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendCustomCombatSpam(customString, color);
	}
}

void CreatureObject::sendExecuteConsoleCommand(const String& command) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDEXECUTECONSOLECOMMAND__STRING_);
		method.addAsciiParameter(command);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendExecuteConsoleCommand(command);
	}
}

bool CreatureObject::isAggressiveTo(CreatureObject* object) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAGGRESSIVETO__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAggressiveTo(object);
	}
}

int CreatureObject::notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(condition);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->notifyObjectDestructionObservers(attacker, condition, isCombatAction);
	}
}

int CreatureObject::notifyObjectKillObservers(TangibleObject* killer) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTKILLOBSERVERS__TANGIBLEOBJECT_);
		method.addObjectParameter(killer);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((killer == NULL) || killer->isLockedByCurrentThread());
		return _implementation->notifyObjectKillObservers(killer);
	}
}

void CreatureObject::notifyLoadFromDatabase() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->notifyLoadFromDatabase();
	}
}

void CreatureObject::destroyObjectFromDatabase(bool destroyContainedObjects) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMDATABASE__BOOL_);
		method.addBooleanParameter(destroyContainedObjects);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->destroyObjectFromDatabase(destroyContainedObjects);
	}
}

void CreatureObject::setFactionRank(int rank, bool notifyClient) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFACTIONRANK__INT_BOOL_);
		method.addSignedIntParameter(rank);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setFactionRank(rank, notifyClient);
	}
}

String CreatureObject::getFirstName() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFIRSTNAME__);

		String _return_getFirstName;
		method.executeWithAsciiReturn(_return_getFirstName);
		return _return_getFirstName;
	} else {
		return _implementation->getFirstName();
	}
}

String CreatureObject::getLastName() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNAME__);

		String _return_getLastName;
		method.executeWithAsciiReturn(_return_getLastName);
		return _return_getLastName;
	} else {
		return _implementation->getLastName();
	}
}

bool CreatureObject::isOnline() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONLINE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOnline();
	}
}

bool CreatureObject::canTreatInjuries() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATINJURIES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canTreatInjuries();
	}
}

bool CreatureObject::canTreatStates() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATSTATES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canTreatStates();
	}
}

bool CreatureObject::canTreatWounds() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATWOUNDS__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canTreatWounds();
	}
}

bool CreatureObject::canTreatConditions() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTREATCONDITIONS__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canTreatConditions();
	}
}

Reference<PlayerObject* > CreatureObject::getPlayerObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLAYEROBJECT__);

		return static_cast<PlayerObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getPlayerObject();
	}
}

bool CreatureObject::isListening() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLISTENING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isListening();
	}
}

bool CreatureObject::isWatching() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWATCHING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isWatching();
	}
}

void CreatureObject::setClient(ZoneClientSession* cli) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLIENT__ZONECLIENTSESSION_);
		method.addObjectParameter(cli);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setClient(cli);
	}
}

void CreatureObject::dismount() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DISMOUNT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->dismount();
	}
}

float CreatureObject::calculateBFRatio() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEBFRATIO__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->calculateBFRatio();
	}
}

void CreatureObject::removeFeignedDeath() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFEIGNEDDEATH__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeFeignedDeath();
	}
}

bool CreatureObject::canFeignDeath() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANFEIGNDEATH__);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->canFeignDeath();
	}
}

void CreatureObject::feignDeath() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FEIGNDEATH__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->feignDeath();
	}
}

void CreatureObject::setFeignedDeathState() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFEIGNEDDEATHSTATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setFeignedDeathState();
	}
}

void CreatureObject::setDizziedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDIZZIEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDizziedState(durationSeconds);
	}
}

void CreatureObject::setRalliedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRALLIEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRalliedState(durationSeconds);
	}
}

void CreatureObject::setAimingState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAIMINGSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAimingState(durationSeconds);
	}
}

void CreatureObject::setCoverState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOVERSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCoverState(durationSeconds);
	}
}

void CreatureObject::setBerserkedState(unsigned int duration) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBERSERKEDSTATE__INT_);
		method.addUnsignedIntParameter(duration);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setBerserkedState(duration);
	}
}

void CreatureObject::setStunnedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTUNNEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setStunnedState(durationSeconds);
	}
}

void CreatureObject::setBlindedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBLINDEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setBlindedState(durationSeconds);
	}
}

void CreatureObject::setIntimidatedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINTIMIDATEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setIntimidatedState(durationSeconds);
	}
}

void CreatureObject::setSnaredState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSNAREDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSnaredState(durationSeconds);
	}
}

void CreatureObject::setRootedState(int durationSeconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETROOTEDSTATE__INT_);
		method.addSignedIntParameter(durationSeconds);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRootedState(durationSeconds);
	}
}

bool CreatureObject::setNextAttackDelay(unsigned int mod, int del) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNEXTATTACKDELAY__INT_INT_);
		method.addUnsignedIntParameter(mod);
		method.addSignedIntParameter(del);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->setNextAttackDelay(mod, del);
	}
}

void CreatureObject::setMeditateState() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMEDITATESTATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMeditateState();
	}
}

void CreatureObject::activateHAMRegeneration(int latency) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEHAMREGENERATION__INT_);
		method.addSignedIntParameter(latency);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateHAMRegeneration(latency);
	}
}

void CreatureObject::activatePassiveWoundRegeneration() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEPASSIVEWOUNDREGENERATION__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activatePassiveWoundRegeneration();
	}
}

void CreatureObject::activateStateRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATESTATERECOVERY__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateStateRecovery();
	}
}

void CreatureObject::updateTimeOfDeath() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATETIMEOFDEATH__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updateTimeOfDeath();
	}
}

bool CreatureObject::hasAttackDelay() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASATTACKDELAY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasAttackDelay();
	}
}

void CreatureObject::removeAttackDelay() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEATTACKDELAY__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeAttackDelay();
	}
}

bool CreatureObject::hasIncapTimer() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASINCAPTIMER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasIncapTimer();
	}
}

CooldownTimerMap* CreatureObject::getCooldownTimerMap() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCooldownTimerMap();
	}
}

bool CreatureObject::hasSpice() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSPICE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSpice();
	}
}

void CreatureObject::updateLastSuccessfulCombatAction() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTSUCCESSFULCOMBATACTION__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastSuccessfulCombatAction();
	}
}

void CreatureObject::updatePostureChangeDelay(unsigned long long delay) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPOSTURECHANGEDELAY__LONG_);
		method.addUnsignedLongParameter(delay);

		method.executeWithVoidReturn();
	} else {
		_implementation->updatePostureChangeDelay(delay);
	}
}

bool CreatureObject::checkPostureChangeDelay() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKPOSTURECHANGEDELAY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkPostureChangeDelay();
	}
}

void CreatureObject::updatePostureDownRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPOSTUREDOWNRECOVERY__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updatePostureDownRecovery();
	}
}

bool CreatureObject::checkPostureDownRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKPOSTUREDOWNRECOVERY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkPostureDownRecovery();
	}
}

void CreatureObject::updatePostureUpRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPOSTUREUPRECOVERY__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updatePostureUpRecovery();
	}
}

bool CreatureObject::checkPostureUpRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKPOSTUREUPRECOVERY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkPostureUpRecovery();
	}
}

void CreatureObject::updateKnockdownRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEKNOCKDOWNRECOVERY__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateKnockdownRecovery();
	}
}

bool CreatureObject::checkKnockdownRecovery() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKKNOCKDOWNRECOVERY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkKnockdownRecovery();
	}
}

void CreatureObject::updateGroupMFDPositions() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEGROUPMFDPOSITIONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateGroupMFDPositions();
	}
}

void CreatureObject::queueDizzyFallEvent() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_QUEUEDIZZYFALLEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->queueDizzyFallEvent();
	}
}

bool CreatureObject::hasDizzyEvent() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASDIZZYEVENT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasDizzyEvent();
	}
}

void CreatureObject::clearDizzyEvent() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARDIZZYEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearDizzyEvent();
	}
}

unsigned long long CreatureObject::getScreenPlayState(const String& screenPlay) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSCREENPLAYSTATE__STRING_);
		method.addAsciiParameter(screenPlay);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getScreenPlayState(screenPlay);
	}
}

void CreatureObject::setScreenPlayState(const String& screenPlay, unsigned long long state) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSCREENPLAYSTATE__STRING_LONG_);
		method.addAsciiParameter(screenPlay);
		method.addUnsignedLongParameter(state);

		method.executeWithVoidReturn();
	} else {
		_implementation->setScreenPlayState(screenPlay, state);
	}
}

void CreatureObject::updateCooldownTimer(const String& coooldownTimer, unsigned long long miliSecondsToAdd) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATECOOLDOWNTIMER__STRING_LONG_);
		method.addAsciiParameter(coooldownTimer);
		method.addUnsignedLongParameter(miliSecondsToAdd);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateCooldownTimer(coooldownTimer, miliSecondsToAdd);
	}
}

bool CreatureObject::checkCooldownRecovery(const String& cooldown) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKCOOLDOWNRECOVERY__STRING_);
		method.addAsciiParameter(cooldown);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkCooldownRecovery(cooldown);
	}
}

Time* CreatureObject::getCooldownTime(const String& cooldown) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCooldownTime(cooldown);
	}
}

void CreatureObject::addCooldown(const String& name, unsigned long long miliseconds) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCOOLDOWN__STRING_LONG_);
		method.addAsciiParameter(name);
		method.addUnsignedLongParameter(miliseconds);

		method.executeWithVoidReturn();
	} else {
		_implementation->addCooldown(name, miliseconds);
	}
}

void CreatureObject::doAnimation(const String& animation) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOANIMATION__STRING_);
		method.addAsciiParameter(animation);

		method.executeWithVoidReturn();
	} else {
		_implementation->doAnimation(animation);
	}
}

void CreatureObject::doCombatAnimation(TangibleObject* defender, unsigned int animationCRC, byte hit, byte trails, unsigned long long weaponID) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOCOMBATANIMATION__TANGIBLEOBJECT_INT_BYTE_BYTE_LONG_);
		method.addObjectParameter(defender);
		method.addUnsignedIntParameter(animationCRC);
		method.addByteParameter(hit);
		method.addByteParameter(trails);
		method.addUnsignedLongParameter(weaponID);

		method.executeWithVoidReturn();
	} else {
		_implementation->doCombatAnimation(defender, animationCRC, hit, trails, weaponID);
	}
}

void CreatureObject::doCombatAnimation(unsigned int animationCRC) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOCOMBATANIMATION__INT_);
		method.addUnsignedIntParameter(animationCRC);

		method.executeWithVoidReturn();
	} else {
		_implementation->doCombatAnimation(animationCRC);
	}
}

void CreatureObject::activateQueueAction() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEQUEUEACTION__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateQueueAction();
	}
}

void CreatureObject::activateImmediateAction() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEIMMEDIATEACTION__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateImmediateAction();
	}
}

UnicodeString CreatureObject::getCreatureName() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATURENAME__);

		UnicodeString _return_getCreatureName;
		method.executeWithUnicodeReturn(_return_getCreatureName);
		return _return_getCreatureName;
	} else {
		return _implementation->getCreatureName();
	}
}

bool CreatureObject::isGrouped() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISGROUPED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isGrouped();
	}
}

int CreatureObject::getBankCredits() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBANKCREDITS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBankCredits();
	}
}

int CreatureObject::getCashCredits() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCASHCREDITS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCashCredits();
	}
}

int CreatureObject::getBaseHAM(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASEHAM__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseHAM(idx);
	}
}

int CreatureObject::getWounds(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWOUNDS__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getWounds(idx);
	}
}

DeltaVector<int>* CreatureObject::getWounds() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getWounds();
	}
}

int CreatureObject::getHAM(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHAM__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHAM(idx);
	}
}

DeltaVector<int>* CreatureObject::getHAM() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getHAM();
	}
}

int CreatureObject::getMaxHAM(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXHAM__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMaxHAM(idx);
	}
}

DeltaVector<int>* CreatureObject::getMaxHAM() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getMaxHAM();
	}
}

int CreatureObject::getEncumbrance(int idx) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENCUMBRANCE__INT_);
		method.addSignedIntParameter(idx);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getEncumbrance(idx);
	}
}

DeltaVector<int>* CreatureObject::getEncumbrances() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getEncumbrances();
	}
}

byte CreatureObject::getPosture() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOSTURE__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getPosture();
	}
}

byte CreatureObject::getLocomotion() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLOCOMOTION__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getLocomotion();
	}
}

byte CreatureObject::getFactionRank() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONRANK__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getFactionRank();
	}
}

ManagedWeakReference<CreatureObject* > CreatureObject::getLinkedCreature() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLINKEDCREATURE__);

		return static_cast<CreatureObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getLinkedCreature();
	}
}

unsigned long long CreatureObject::getCreatureLinkID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATURELINKID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getCreatureLinkID();
	}
}

float CreatureObject::getShockWounds() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSHOCKWOUNDS__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getShockWounds();
	}
}

unsigned long long CreatureObject::getWatchToID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWATCHTOID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getWatchToID();
	}
}

unsigned long long CreatureObject::getStateBitmask() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTATEBITMASK__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getStateBitmask();
	}
}

bool CreatureObject::hasState(unsigned long long state) const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSTATE__LONG_);
		method.addUnsignedLongParameter(state);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasState(state);
	}
}

bool CreatureObject::hasStates() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSTATES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasStates();
	}
}

unsigned long long CreatureObject::getListenID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLISTENID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getListenID();
	}
}

float CreatureObject::getAccelerationMultiplierBase() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCELERATIONMULTIPLIERBASE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAccelerationMultiplierBase();
	}
}

float CreatureObject::getAccelerationMultiplierMod() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCELERATIONMULTIPLIERMOD__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAccelerationMultiplierMod();
	}
}

float CreatureObject::getSpeedMultiplierBase() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPEEDMULTIPLIERBASE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getSpeedMultiplierBase();
	}
}

float CreatureObject::getSpeedMultiplierMod() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPEEDMULTIPLIERMOD__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getSpeedMultiplierMod();
	}
}

float CreatureObject::getCurrentSpeed() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTSPEED__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getCurrentSpeed();
	}
}

SpeedMultiplierModChanges* CreatureObject::getSpeedMultiplierModChanges() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSpeedMultiplierModChanges();
	}
}

CommandQueueActionVector* CreatureObject::getCommandQueue() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCommandQueue();
	}
}

int CreatureObject::getCommandQueueSize() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOMMANDQUEUESIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCommandQueueSize();
	}
}

void CreatureObject::setLastActionCounter(unsigned int ctr) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTACTIONCOUNTER__INT_);
		method.addUnsignedIntParameter(ctr);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLastActionCounter(ctr);
	}
}

unsigned int CreatureObject::incrementLastActionCounter() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREMENTLASTACTIONCOUNTER__);

		return method.executeWithUnsignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->incrementLastActionCounter();
	}
}

unsigned int CreatureObject::getLastActionCounter() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTACTIONCOUNTER__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getLastActionCounter();
	}
}

float CreatureObject::getRunSpeed() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRUNSPEED__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getRunSpeed();
	}
}

float CreatureObject::getWalkSpeed() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWALKSPEED__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getWalkSpeed();
	}
}

float CreatureObject::getTurnScale() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTURNSCALE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getTurnScale();
	}
}

float CreatureObject::getTerrainNegotiation() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTERRAINNEGOTIATION__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getTerrainNegotiation();
	}
}

float CreatureObject::getRunAcceleration() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRUNACCELERATION__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getRunAcceleration();
	}
}

float CreatureObject::getWalkAcceleration() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWALKACCELERATION__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getWalkAcceleration();
	}
}

String CreatureObject::getPerformanceAnimation() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCEANIMATION__);

		String _return_getPerformanceAnimation;
		method.executeWithAsciiReturn(_return_getPerformanceAnimation);
		return _return_getPerformanceAnimation;
	} else {
		return _implementation->getPerformanceAnimation();
	}
}

String CreatureObject::getMoodString() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMOODSTRING__);

		String _return_getMoodString;
		method.executeWithAsciiReturn(_return_getMoodString);
		return _return_getMoodString;
	} else {
		return _implementation->getMoodString();
	}
}

unsigned long long CreatureObject::getWeaponID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEAPONID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getWeaponID();
	}
}

Reference<WeaponObject* > CreatureObject::getWeapon() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEAPON__);

		return static_cast<WeaponObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getWeapon();
	}
}

ManagedWeakReference<GuildObject* > CreatureObject::getGuildObject() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGUILDOBJECT__);

		return static_cast<GuildObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getGuildObject();
	}
}

int CreatureObject::getGuildID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGUILDID__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getGuildID();
	}
}

bool CreatureObject::isInGuild() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINGUILD__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInGuild();
	}
}

void CreatureObject::setGuildObject(GuildObject* guildobj) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETGUILDOBJECT__GUILDOBJECT_);
		method.addObjectParameter(guildobj);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setGuildObject(guildobj);
	}
}

unsigned long long CreatureObject::getGroupID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUPID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getGroupID();
	}
}

unsigned long long CreatureObject::getGroupInviterID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUPINVITERID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getGroupInviterID();
	}
}

Reference<GroupObject* > CreatureObject::getGroup() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUP__);

		return static_cast<GroupObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getGroup();
	}
}

unsigned long long CreatureObject::getGroupInviteCounter() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGROUPINVITECOUNTER__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getGroupInviteCounter();
	}
}

unsigned long long CreatureObject::getTargetID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getTargetID();
	}
}

byte CreatureObject::getMoodID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMOODID__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getMoodID();
	}
}

float CreatureObject::getSlopeModPercent() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSLOPEMODPERCENT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getSlopeModPercent();
	}
}

int CreatureObject::getPerformanceCounter() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCECOUNTER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPerformanceCounter();
	}
}

int CreatureObject::getInstrumentID() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINSTRUMENTID__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getInstrumentID();
	}
}

byte CreatureObject::getFrozen() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFROZEN__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getFrozen();
	}
}

float CreatureObject::getHeight() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEIGHT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHeight();
	}
}

bool CreatureObject::isDroidSpecies() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDROIDSPECIES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDroidSpecies();
	}
}

bool CreatureObject::isWalkerSpecies() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWALKERSPECIES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isWalkerSpecies();
	}
}

bool CreatureObject::isProbotSpecies() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPROBOTSPECIES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isProbotSpecies();
	}
}

bool CreatureObject::hasEffectImmunity(byte effectType) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASEFFECTIMMUNITY__BYTE_);
		method.addByteParameter(effectType);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasEffectImmunity(effectType);
	}
}

bool CreatureObject::hasDotImmunity(unsigned int dotType) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASDOTIMMUNITY__INT_);
		method.addUnsignedIntParameter(dotType);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasDotImmunity(dotType);
	}
}

int CreatureObject::getSpecies() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIES__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSpecies();
	}
}

String CreatureObject::getSpeciesName() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIESNAME__);

		String _return_getSpeciesName;
		method.executeWithAsciiReturn(_return_getSpeciesName);
		return _return_getSpeciesName;
	} else {
		return _implementation->getSpeciesName();
	}
}

int CreatureObject::getGender() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGENDER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getGender();
	}
}

DeltaVector<int>* CreatureObject::getBaseHAM() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getBaseHAM();
	}
}

SkillList* CreatureObject::getSkillList() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSkillList();
	}
}

int CreatureObject::getSkillMod(const String& skillmod) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLMOD__STRING_);
		method.addAsciiParameter(skillmod);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSkillMod(skillmod);
	}
}

int CreatureObject::getSkillModOfType(const String& skillmod, unsigned const int modType) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLMODOFTYPE__STRING_INT_);
		method.addAsciiParameter(skillmod);
		method.addUnsignedIntParameter(modType);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSkillModOfType(skillmod, modType);
	}
}

bool CreatureObject::hasSkill(const String& skill) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSKILL__STRING_);
		method.addAsciiParameter(skill);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSkill(skill);
	}
}

SkillModList* CreatureObject::getSkillModList() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSkillModList();
	}
}

void CreatureObject::setWatchToID(unsigned long long id) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWATCHTOID__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setWatchToID(id);
	}
}

bool CreatureObject::isCreatureObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCREATUREOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCreatureObject();
	}
}

CreatureObject* CreatureObject::__asCreatureObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->asCreatureObject();
	}
}

bool CreatureObject::isNextActionPast() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNEXTACTIONPAST__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNextActionPast();
	}
}

bool CreatureObject::isSwimming() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSWIMMING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSwimming();
	}
}

Reference<ZoneClientSession* > CreatureObject::getClient() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLIENT__);

		return static_cast<ZoneClientSession*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getClient();
	}
}

ManagedWeakReference<ControlDevice* > CreatureObject::getControlDevice() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTROLDEVICE__);

		return static_cast<ControlDevice*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getControlDevice();
	}
}

float CreatureObject::getSwimHeight() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSWIMHEIGHT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getSwimHeight();
	}
}

bool CreatureObject::isIncapacitated() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINCAPACITATED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isIncapacitated();
	}
}

bool CreatureObject::isDead() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDEAD__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDead();
	}
}

bool CreatureObject::isKnockedDown() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISKNOCKEDDOWN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isKnockedDown();
	}
}

bool CreatureObject::isKneeling() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISKNEELING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isKneeling();
	}
}

bool CreatureObject::isProne() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPRONE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isProne();
	}
}

bool CreatureObject::isStanding() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTANDING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isStanding();
	}
}

bool CreatureObject::isSitting() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSITTING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSitting();
	}
}

bool CreatureObject::isSkillAnimating() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSKILLANIMATING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSkillAnimating();
	}
}

bool CreatureObject::isRallied() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRALLIED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRallied();
	}
}

bool CreatureObject::isInCombat() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINCOMBAT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInCombat();
	}
}

bool CreatureObject::isDizzied() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDIZZIED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDizzied();
	}
}

bool CreatureObject::isBerserked() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBERSERKED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isBerserked();
	}
}

bool CreatureObject::isStunned() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTUNNED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isStunned();
	}
}

bool CreatureObject::isBlinded() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBLINDED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isBlinded();
	}
}

bool CreatureObject::isIntimidated() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINTIMIDATED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isIntimidated();
	}
}

bool CreatureObject::isSnared() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSNARED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSnared();
	}
}

bool CreatureObject::isImmobilized() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISIMMOBILIZED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isImmobilized();
	}
}

bool CreatureObject::isRooted() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISROOTED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRooted();
	}
}

bool CreatureObject::isFrozen() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFROZEN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFrozen();
	}
}

bool CreatureObject::isDiseased() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDISEASED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDiseased();
	}
}

bool CreatureObject::isPoisoned() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPOISONED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPoisoned();
	}
}

bool CreatureObject::isBleeding() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBLEEDING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isBleeding();
	}
}

bool CreatureObject::isOnFire() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONFIRE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOnFire();
	}
}

bool CreatureObject::isFeigningDeath() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFEIGNINGDEATH__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFeigningDeath();
	}
}

bool CreatureObject::isRidingMount() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRIDINGMOUNT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRidingMount();
	}
}

bool CreatureObject::hasRidingCreature() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASRIDINGCREATURE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasRidingCreature();
	}
}

bool CreatureObject::isPeaced() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPEACED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPeaced();
	}
}

bool CreatureObject::isMeditating() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMEDITATING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMeditating();
	}
}

bool CreatureObject::isAiming() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAIMING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAiming();
	}
}

bool CreatureObject::isInCover() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINCOVER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInCover();
	}
}

bool CreatureObject::isRunning() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRUNNING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRunning();
	}
}

bool CreatureObject::isNonPlayerCreatureObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNONPLAYERCREATUREOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNonPlayerCreatureObject();
	}
}

bool CreatureObject::isDroidObject() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDROIDOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDroidObject();
	}
}

bool CreatureObject::isPlayerCreature() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYERCREATURE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPlayerCreature();
	}
}

int CreatureObject::registerToCloseObjectsReceivers() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REGISTERTOCLOSEOBJECTSRECEIVERS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->registerToCloseObjectsReceivers();
	}
}

bool CreatureObject::isInformantCreature() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINFORMANTCREATURE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInformantCreature();
	}
}

CampSiteActiveArea* CreatureObject::getCurrentCamp() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTCAMP__);

		return static_cast<CampSiteActiveArea*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getCurrentCamp();
	}
}

byte CreatureObject::getCurrentWeather() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTWEATHER__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getCurrentWeather();
	}
}

void CreatureObject::setCurrentWeather(byte value) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTWEATHER__BYTE_);
		method.addByteParameter(value);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCurrentWeather(value);
	}
}

byte CreatureObject::getCurrentWind() const {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTWIND__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getCurrentWind();
	}
}

void CreatureObject::setCurrentWind(byte value) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTWIND__BYTE_);
		method.addByteParameter(value);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCurrentWind(value);
	}
}

int CreatureObject::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		return _implementation->handleObjectMenuSelect(player, selectedID);
	}
}

String CreatureObject::getAlternateAppearance() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETALTERNATEAPPEARANCE__);

		String _return_getAlternateAppearance;
		method.executeWithAsciiReturn(_return_getAlternateAppearance);
		return _return_getAlternateAppearance;
	} else {
		return _implementation->getAlternateAppearance();
	}
}

Mutex* CreatureObject::getSkillModMutex() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSkillModMutex();
	}
}

float CreatureObject::calculateCostAdjustment(byte stat, float baseCost) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATECOSTADJUSTMENT__BYTE_FLOAT_);
		method.addByteParameter(stat);
		method.addFloatParameter(baseCost);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->calculateCostAdjustment(stat, baseCost);
	}
}

void CreatureObject::updateSpeedAndAccelerationMods() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATESPEEDANDACCELERATIONMODS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updateSpeedAndAccelerationMods();
	}
}

void CreatureObject::setFaction(unsigned int crc) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFACTION__INT_);
		method.addUnsignedIntParameter(crc);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setFaction(crc);
	}
}

void CreatureObject::destroyPlayerCreatureFromDatabase(bool destroyContainedObjects) {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYPLAYERCREATUREFROMDATABASE__BOOL_);
		method.addBooleanParameter(destroyContainedObjects);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->destroyPlayerCreatureFromDatabase(destroyContainedObjects);
	}
}

float CreatureObject::getTemplateRadius() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTEMPLATERADIUS__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getTemplateRadius();
	}
}

void CreatureObject::reloadTemplate() {
	CreatureObjectImplementation* _implementation = static_cast<CreatureObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RELOADTEMPLATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->reloadTemplate();
	}
}

DistributedObjectServant* CreatureObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* CreatureObject::_getImplementationForRead() const {
	return _impl;
}

void CreatureObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	CreatureObjectImplementation
 */

unsigned const long long CreatureObjectImplementation::DEAD_TOO_LONG = 1800000;

CreatureObjectImplementation::CreatureObjectImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


CreatureObjectImplementation::~CreatureObjectImplementation() {
	CreatureObjectImplementation::finalize();
}


void CreatureObjectImplementation::_initializeImplementation() {
	_setClassHelper(CreatureObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void CreatureObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<CreatureObject*>(stub);
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* CreatureObjectImplementation::_getStub() {
	return _this.get();
}

CreatureObjectImplementation::operator const CreatureObject*() {
	return _this.get();
}

void CreatureObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void CreatureObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void CreatureObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void CreatureObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void CreatureObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void CreatureObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void CreatureObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void CreatureObjectImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("CreatureObject");

}

void CreatureObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(CreatureObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool CreatureObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x139546e0: //CreatureObject.creditObject
		TypeInfo<ManagedReference<CreditObject* > >::parseFromBinaryStream(&creditObject, stream);
		return true;

	case 0x4efbe84d: //CreatureObject.bankCredits
		TypeInfo<int >::parseFromBinaryStream(&bankCredits, stream);
		return true;

	case 0xfaf33732: //CreatureObject.cashCredits
		TypeInfo<int >::parseFromBinaryStream(&cashCredits, stream);
		return true;

	case 0xe9b502e0: //CreatureObject.baseHAM
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&baseHAM, stream);
		return true;

	case 0xeb725d47: //CreatureObject.posture
		TypeInfo<byte >::parseFromBinaryStream(&posture, stream);
		return true;

	case 0x1baa7e7: //CreatureObject.locomotion
		TypeInfo<byte >::parseFromBinaryStream(&locomotion, stream);
		return true;

	case 0xc718f22f: //CreatureObject.factionRank
		TypeInfo<byte >::parseFromBinaryStream(&factionRank, stream);
		return true;

	case 0xb981d90d: //CreatureObject.linkedCreature
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&linkedCreature, stream);
		return true;

	case 0x49ffc563: //CreatureObject.controlDevice
		TypeInfo<ManagedWeakReference<ControlDevice* > >::parseFromBinaryStream(&controlDevice, stream);
		return true;

	case 0xed4a9523: //CreatureObject.shockWounds
		TypeInfo<float >::parseFromBinaryStream(&shockWounds, stream);
		return true;

	case 0xc58d8e3a: //CreatureObject.wounds
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&wounds, stream);
		return true;

	case 0x28d872c3: //CreatureObject.stateBitmask
		TypeInfo<unsigned long long >::parseFromBinaryStream(&stateBitmask, stream);
		return true;

	case 0x7efecb9a: //CreatureObject.encumbrances
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&encumbrances, stream);
		return true;

	case 0x3f51e181: //CreatureObject.wearablesVector
		TypeInfo<WearablesDeltaVector >::parseFromBinaryStream(&wearablesVector, stream);
		return true;

	case 0xed98f6f1: //CreatureObject.accelerationMultiplierBase
		TypeInfo<float >::parseFromBinaryStream(&accelerationMultiplierBase, stream);
		return true;

	case 0xc1ae38c: //CreatureObject.accelerationMultiplierMod
		TypeInfo<float >::parseFromBinaryStream(&accelerationMultiplierMod, stream);
		return true;

	case 0x4114cdb5: //CreatureObject.speedMultiplierBase
		TypeInfo<float >::parseFromBinaryStream(&speedMultiplierBase, stream);
		return true;

	case 0x45a23b71: //CreatureObject.speedMultiplierModChanges
		TypeInfo<SpeedMultiplierModChanges >::parseFromBinaryStream(&speedMultiplierModChanges, stream);
		return true;

	case 0x612b07f7: //CreatureObject.speedMultiplierMod
		TypeInfo<float >::parseFromBinaryStream(&speedMultiplierMod, stream);
		return true;

	case 0xc5da611d: //CreatureObject.turnScale
		TypeInfo<float >::parseFromBinaryStream(&turnScale, stream);
		return true;

	case 0x76595507: //CreatureObject.runSpeed
		TypeInfo<float >::parseFromBinaryStream(&runSpeed, stream);
		return true;

	case 0x99e420df: //CreatureObject.walkSpeed
		TypeInfo<float >::parseFromBinaryStream(&walkSpeed, stream);
		return true;

	case 0x27abda40: //CreatureObject.currentSpeed
		TypeInfo<float >::parseFromBinaryStream(&currentSpeed, stream);
		return true;

	case 0xe5a6e8cb: //CreatureObject.terrainNegotiation
		TypeInfo<float >::parseFromBinaryStream(&terrainNegotiation, stream);
		return true;

	case 0xd126abdf: //CreatureObject.runAcceleration
		TypeInfo<float >::parseFromBinaryStream(&runAcceleration, stream);
		return true;

	case 0x7889ea2d: //CreatureObject.walkAcceleration
		TypeInfo<float >::parseFromBinaryStream(&walkAcceleration, stream);
		return true;

	case 0x949ac654: //CreatureObject.height
		TypeInfo<float >::parseFromBinaryStream(&height, stream);
		return true;

	case 0xe0f234f7: //CreatureObject.swimHeight
		TypeInfo<float >::parseFromBinaryStream(&swimHeight, stream);
		return true;

	case 0x3acb18b3: //CreatureObject.slopeModPercent
		TypeInfo<float >::parseFromBinaryStream(&slopeModPercent, stream);
		return true;

	case 0x1f13576: //CreatureObject.slopeModAngle
		TypeInfo<float >::parseFromBinaryStream(&slopeModAngle, stream);
		return true;

	case 0xc1faba17: //CreatureObject.listenToID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&listenToID, stream);
		return true;

	case 0x2322b2f8: //CreatureObject.watchToID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&watchToID, stream);
		return true;

	case 0xc8ec9744: //CreatureObject.performanceAnimation
		TypeInfo<String >::parseFromBinaryStream(&performanceAnimation, stream);
		return true;

	case 0xe9808458: //CreatureObject.moodString
		TypeInfo<String >::parseFromBinaryStream(&moodString, stream);
		return true;

	case 0xf7c21f8: //CreatureObject.weapon
		TypeInfo<ManagedReference<WeaponObject* > >::parseFromBinaryStream(&weapon, stream);
		return true;

	case 0x40463fdc: //CreatureObject.group
		TypeInfo<ManagedReference<GroupObject* > >::parseFromBinaryStream(&group, stream);
		return true;

	case 0x764b5acf: //CreatureObject.groupInviterID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&groupInviterID, stream);
		return true;

	case 0x80dbd4b5: //CreatureObject.groupInviteCounter
		TypeInfo<unsigned long long >::parseFromBinaryStream(&groupInviteCounter, stream);
		return true;

	case 0x4f029e94: //CreatureObject.guild
		TypeInfo<ManagedWeakReference<GuildObject* > >::parseFromBinaryStream(&guild, stream);
		return true;

	case 0xeb62addf: //CreatureObject.targetID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&targetID, stream);
		return true;

	case 0xd4ef3def: //CreatureObject.moodID
		TypeInfo<byte >::parseFromBinaryStream(&moodID, stream);
		return true;

	case 0x83a587da: //CreatureObject.performanceCounter
		TypeInfo<int >::parseFromBinaryStream(&performanceCounter, stream);
		return true;

	case 0x41617b95: //CreatureObject.instrumentID
		TypeInfo<int >::parseFromBinaryStream(&instrumentID, stream);
		return true;

	case 0xe7af3a39: //CreatureObject.hamList
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&hamList, stream);
		return true;

	case 0xe055bce7: //CreatureObject.maxHamList
		TypeInfo<DeltaVector<int> >::parseFromBinaryStream(&maxHamList, stream);
		return true;

	case 0xc4efdf12: //CreatureObject.frozen
		TypeInfo<byte >::parseFromBinaryStream(&frozen, stream);
		return true;

	case 0xd6174e91: //CreatureObject.templateString
		TypeInfo<String >::parseFromBinaryStream(&templateString, stream);
		return true;

	case 0x1a1789b3: //CreatureObject.skillList
		TypeInfo<SkillList >::parseFromBinaryStream(&skillList, stream);
		return true;

	case 0xbc739f7e: //CreatureObject.skillModList
		TypeInfo<SkillModList >::parseFromBinaryStream(&skillModList, stream);
		return true;

	case 0x763c81e: //CreatureObject.nextAction
		TypeInfo<Time >::parseFromBinaryStream(&nextAction, stream);
		return true;

	case 0xbc44e9f6: //CreatureObject.cooldownTimerMap
		TypeInfo<Reference<CooldownTimerMap* > >::parseFromBinaryStream(&cooldownTimerMap, stream);
		return true;

	case 0x905e244e: //CreatureObject.creatureBuffs
		TypeInfo<BuffList >::parseFromBinaryStream(&creatureBuffs, stream);
		return true;

	case 0xf65f1375: //CreatureObject.damageOverTimeList
		TypeInfo<DamageOverTimeList >::parseFromBinaryStream(&damageOverTimeList, stream);
		return true;

	case 0xe0c29f16: //CreatureObject.lastSuccessfulCombatAction
		TypeInfo<Time >::parseFromBinaryStream(&lastSuccessfulCombatAction, stream);
		return true;

	case 0x93032da8: //CreatureObject.timeOfDeath
		TypeInfo<Time >::parseFromBinaryStream(&timeOfDeath, stream);
		return true;

	case 0xfaac264a: //CreatureObject.screenPlayStates
		TypeInfo<VectorMap<String, unsigned long long> >::parseFromBinaryStream(&screenPlayStates, stream);
		return true;

	}

	return false;
}

void CreatureObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = CreatureObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int CreatureObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x139546e0; //CreatureObject.creditObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<CreditObject* > >::toBinaryStream(&creditObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x4efbe84d; //CreatureObject.bankCredits
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&bankCredits, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xfaf33732; //CreatureObject.cashCredits
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&cashCredits, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe9b502e0; //CreatureObject.baseHAM
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&baseHAM, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xeb725d47; //CreatureObject.posture
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&posture, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1baa7e7; //CreatureObject.locomotion
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&locomotion, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc718f22f; //CreatureObject.factionRank
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&factionRank, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb981d90d; //CreatureObject.linkedCreature
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&linkedCreature, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x49ffc563; //CreatureObject.controlDevice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<ControlDevice* > >::toBinaryStream(&controlDevice, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xed4a9523; //CreatureObject.shockWounds
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&shockWounds, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc58d8e3a; //CreatureObject.wounds
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&wounds, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x28d872c3; //CreatureObject.stateBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&stateBitmask, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7efecb9a; //CreatureObject.encumbrances
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&encumbrances, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3f51e181; //CreatureObject.wearablesVector
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<WearablesDeltaVector >::toBinaryStream(&wearablesVector, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xed98f6f1; //CreatureObject.accelerationMultiplierBase
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&accelerationMultiplierBase, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc1ae38c; //CreatureObject.accelerationMultiplierMod
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&accelerationMultiplierMod, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x4114cdb5; //CreatureObject.speedMultiplierBase
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&speedMultiplierBase, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x45a23b71; //CreatureObject.speedMultiplierModChanges
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SpeedMultiplierModChanges >::toBinaryStream(&speedMultiplierModChanges, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x612b07f7; //CreatureObject.speedMultiplierMod
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&speedMultiplierMod, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc5da611d; //CreatureObject.turnScale
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&turnScale, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x76595507; //CreatureObject.runSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&runSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x99e420df; //CreatureObject.walkSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&walkSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x27abda40; //CreatureObject.currentSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&currentSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe5a6e8cb; //CreatureObject.terrainNegotiation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&terrainNegotiation, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd126abdf; //CreatureObject.runAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&runAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x7889ea2d; //CreatureObject.walkAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&walkAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x949ac654; //CreatureObject.height
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&height, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe0f234f7; //CreatureObject.swimHeight
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&swimHeight, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3acb18b3; //CreatureObject.slopeModPercent
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&slopeModPercent, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1f13576; //CreatureObject.slopeModAngle
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&slopeModAngle, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc1faba17; //CreatureObject.listenToID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&listenToID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2322b2f8; //CreatureObject.watchToID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&watchToID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc8ec9744; //CreatureObject.performanceAnimation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&performanceAnimation, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe9808458; //CreatureObject.moodString
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&moodString, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xf7c21f8; //CreatureObject.weapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObject* > >::toBinaryStream(&weapon, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x40463fdc; //CreatureObject.group
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<GroupObject* > >::toBinaryStream(&group, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x764b5acf; //CreatureObject.groupInviterID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&groupInviterID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x80dbd4b5; //CreatureObject.groupInviteCounter
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&groupInviteCounter, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x4f029e94; //CreatureObject.guild
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<GuildObject* > >::toBinaryStream(&guild, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xeb62addf; //CreatureObject.targetID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&targetID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd4ef3def; //CreatureObject.moodID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&moodID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x83a587da; //CreatureObject.performanceCounter
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&performanceCounter, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x41617b95; //CreatureObject.instrumentID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&instrumentID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe7af3a39; //CreatureObject.hamList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&hamList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe055bce7; //CreatureObject.maxHamList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<int> >::toBinaryStream(&maxHamList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc4efdf12; //CreatureObject.frozen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&frozen, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xd6174e91; //CreatureObject.templateString
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&templateString, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1a1789b3; //CreatureObject.skillList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SkillList >::toBinaryStream(&skillList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xbc739f7e; //CreatureObject.skillModList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SkillModList >::toBinaryStream(&skillModList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x763c81e; //CreatureObject.nextAction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&nextAction, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xbc44e9f6; //CreatureObject.cooldownTimerMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Reference<CooldownTimerMap* > >::toBinaryStream(&cooldownTimerMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x905e244e; //CreatureObject.creatureBuffs
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<BuffList >::toBinaryStream(&creatureBuffs, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xf65f1375; //CreatureObject.damageOverTimeList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DamageOverTimeList >::toBinaryStream(&damageOverTimeList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe0c29f16; //CreatureObject.lastSuccessfulCombatAction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastSuccessfulCombatAction, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x93032da8; //CreatureObject.timeOfDeath
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&timeOfDeath, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xfaac264a; //CreatureObject.screenPlayStates
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, unsigned long long> >::toBinaryStream(&screenPlayStates, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 56;
}

CreatureObjectImplementation::CreatureObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/creature/CreatureObject.idl():  		Logger.setLoggingName("CreatureObject");
	Logger::setLoggingName("CreatureObject");
	// server/zone/objects/creature/CreatureObject.idl():  		initializeMembers();
	initializeMembers();
}

void CreatureObjectImplementation::setCountdownTimer(unsigned int newCount, bool notifyClient) {
	// server/zone/objects/creature/CreatureObject.idl():  		super.setCountdownTimer(newCount, notifyClient);
	TangibleObjectImplementation::setCountdownTimer(newCount, notifyClient);
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("incapTimer", getUseCount()*1000);
	cooldownTimerMap->updateToCurrentAndAddMili("incapTimer", getUseCount() * 1000);
}

void CreatureObjectImplementation::setCurrentSpeed(float newSpeed) {
	// server/zone/objects/creature/CreatureObject.idl():  		currentSpeed = newSpeed;
	currentSpeed = newSpeed;
}

bool CreatureObjectImplementation::hasDamage(int attribute) {
	// server/zone/objects/creature/CreatureObject.idl():  		return hamList.get(attribute) + wounds.get(attribute) < maxHamList.get(attribute);
	return (&hamList)->get(attribute) + (&wounds)->get(attribute) < (&maxHamList)->get(attribute);
}

WearablesDeltaVector* CreatureObjectImplementation::getWearablesDeltaVector() {
	// server/zone/objects/creature/CreatureObject.idl():  		return wearablesVector;
	return (&wearablesVector);
}

void CreatureObjectImplementation::sendBuffsTo(CreatureObject* creature) {
	// server/zone/objects/creature/CreatureObject.idl():  		creatureBuffs.sendTo(creature);
	(&creatureBuffs)->sendTo(creature);
}

BuffList* CreatureObjectImplementation::getBuffList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs;
	return (&creatureBuffs);
}

Buff* CreatureObjectImplementation::getBuff(unsigned int buffcrc) {
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if ((&creatureBuffs)->hasBuff(buffcrc))	// server/zone/objects/creature/CreatureObject.idl():  			return creatureBuffs.getBuffByCRC(buffcrc);
	return (&creatureBuffs)->getBuffByCRC(buffcrc);
	// server/zone/objects/creature/CreatureObject.idl():  		return null;
	return NULL;
}

long long CreatureObjectImplementation::getSkillModFromBuffs(const String& skillMod) {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs.getModifierByName(skillMod);
	return (&creatureBuffs)->getModifierByName(skillMod);
}

int CreatureObjectImplementation::addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength) {
	// server/zone/objects/creature/CreatureObject.idl():  										 secondaryStrength);
	return (&damageOverTimeList)->addDot(_this.get(), attacker, objectID, duration, dotType, type, strength, potency, defense, secondaryStrength);
}

bool CreatureObjectImplementation::healDot(unsigned long long dotType, int reduction, bool sendMsg) {
	// server/zone/objects/creature/CreatureObject.idl():  		return damageOverTimeList.healState(this, dotType, reduction, sendMsg);
	return (&damageOverTimeList)->healState(_this.get(), dotType, reduction, sendMsg);
}

void CreatureObjectImplementation::clearDots() {
	// server/zone/objects/creature/CreatureObject.idl():  		damageOverTimeList.clear(this);
	(&damageOverTimeList)->clear(_this.get());
}

DamageOverTimeList* CreatureObjectImplementation::getDamageOverTimeList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return damageOverTimeList;
	return (&damageOverTimeList);
}

bool CreatureObjectImplementation::hasBuff(unsigned int buffcrc) {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs.hasBuff(buffcrc);
	return (&creatureBuffs)->hasBuff(buffcrc);
}

void CreatureObjectImplementation::addBankCredits(int credits, bool notifyClient) {
	// server/zone/objects/creature/CreatureObject.idl():  		int newCredits = getBankCredits() + credits;
	int newCredits = getBankCredits() + credits;
	// server/zone/objects/creature/CreatureObject.idl():  		setBankCredits(newCredits);
	setBankCredits(newCredits);
}

void CreatureObjectImplementation::addCashCredits(int credits, bool notifyClient) {
	// server/zone/objects/creature/CreatureObject.idl():  		int newCredits = getCashCredits() + credits;
	int newCredits = getCashCredits() + credits;
	// server/zone/objects/creature/CreatureObject.idl():  		setCashCredits(newCredits);
	setCashCredits(newCredits);
}

bool CreatureObjectImplementation::verifyCashCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl():  		if 
	if (credits < 0)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (getCashCredits() < credits)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return true;
	return true;
}

bool CreatureObjectImplementation::verifyBankCredits(int credits) {
	// server/zone/objects/creature/CreatureObject.idl():  		if 
	if (credits < 0)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (getBankCredits() < credits)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return true;
	return true;
}

bool CreatureObjectImplementation::isEntertaining() {
	// server/zone/objects/creature/CreatureObject.idl():  		return isDancing() || isPlayingMusic();
	return isDancing() || isPlayingMusic();
}

void CreatureObjectImplementation::setControlDevice(ControlDevice* device) {
	// server/zone/objects/creature/CreatureObject.idl():  		controlDevice = device;
	controlDevice = device;
}

bool CreatureObjectImplementation::sendConversationStartTo(SceneObject* player) {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

void CreatureObjectImplementation::selectConversationOption(int option, SceneObject* obj) {
}

void CreatureObjectImplementation::destroyObjectFromDatabase(bool destroyContainedObjects) {
	// server/zone/objects/creature/CreatureObject.idl():  		clearBuffs(false, true);
	clearBuffs(false, true);
	// server/zone/objects/creature/CreatureObject.idl():  		super.destroyObjectFromDatabase(destroyContainedObjects);
	TangibleObjectImplementation::destroyObjectFromDatabase(destroyContainedObjects);
}

bool CreatureObjectImplementation::isOnline() {
	// server/zone/objects/creature/CreatureObject.idl():  		PlayerObject ghost = getPlayerObject();
	ManagedReference<PlayerObject* > ghost = getPlayerObject();
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (ghost == NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return false;
	return false;
	// server/zone/objects/creature/CreatureObject.idl():  		return ghost.isOnline();
	return ghost->isOnline();
}

bool CreatureObjectImplementation::canTreatInjuries() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("injuryTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("injuryTreatment") == NULL;
}

bool CreatureObjectImplementation::canTreatStates() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("stateTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("stateTreatment") == NULL;
}

bool CreatureObjectImplementation::canTreatWounds() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("woundTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("woundTreatment") == NULL;
}

bool CreatureObjectImplementation::canTreatConditions() {
	// server/zone/objects/creature/CreatureObject.idl():  		return super.getPendingTask("conditionTreatment") == null;
	return TangibleObjectImplementation::getPendingTask("conditionTreatment") == NULL;
}

bool CreatureObjectImplementation::isListening() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return listenToID != 0;
	return listenToID != 0;
}

bool CreatureObjectImplementation::isWatching() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return watchToID != 0;
	return watchToID != 0;
}

void CreatureObjectImplementation::setClient(ZoneClientSession* cli) {
	// server/zone/objects/creature/CreatureObject.idl():  		owner = cli;
	owner = cli;
}

void CreatureObjectImplementation::updateTimeOfDeath() {
	// server/zone/objects/creature/CreatureObject.idl():  		timeOfDeath.updateToCurrentTime();
	(&timeOfDeath)->updateToCurrentTime();
}

bool CreatureObjectImplementation::hasAttackDelay() {
	// server/zone/objects/creature/CreatureObject.idl():  		return !cooldownTimerMap.isPast("nextAttackDelay");
	return !cooldownTimerMap->isPast("nextAttackDelay");
}

void CreatureObjectImplementation::removeAttackDelay() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentTime("nextAttackDelay");
	cooldownTimerMap->updateToCurrentTime("nextAttackDelay");
}

bool CreatureObjectImplementation::hasIncapTimer() {
	// server/zone/objects/creature/CreatureObject.idl():  		return !cooldownTimerMap.isPast("incapTimer");
	return !cooldownTimerMap->isPast("incapTimer");
}

CooldownTimerMap* CreatureObjectImplementation::getCooldownTimerMap() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap;
	return cooldownTimerMap;
}

bool CreatureObjectImplementation::hasSpice() {
	// server/zone/objects/creature/CreatureObject.idl():  		return creatureBuffs.hasSpice();
	return (&creatureBuffs)->hasSpice();
}

void CreatureObjectImplementation::updateLastSuccessfulCombatAction() {
	// server/zone/objects/creature/CreatureObject.idl():  		lastSuccessfulCombatAction.updateToCurrentTime();
	(&lastSuccessfulCombatAction)->updateToCurrentTime();
}

void CreatureObjectImplementation::updatePostureChangeDelay(unsigned long long delay) {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("postureChangeDelay", delay);
	cooldownTimerMap->updateToCurrentAndAddMili("postureChangeDelay", delay);
}

bool CreatureObjectImplementation::checkPostureChangeDelay() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("postureChangeDelay");
	return cooldownTimerMap->isPast("postureChangeDelay");
}

void CreatureObjectImplementation::updatePostureDownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("postureDownRecovery", 30000);
	cooldownTimerMap->updateToCurrentAndAddMili("postureDownRecovery", 30000);
}

bool CreatureObjectImplementation::checkPostureDownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("postureDownRecovery");
	return cooldownTimerMap->isPast("postureDownRecovery");
}

void CreatureObjectImplementation::updatePostureUpRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("postureUpRecovery", 30000);
	cooldownTimerMap->updateToCurrentAndAddMili("postureUpRecovery", 30000);
}

bool CreatureObjectImplementation::checkPostureUpRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("postureUpRecovery");
	return cooldownTimerMap->isPast("postureUpRecovery");
}

void CreatureObjectImplementation::updateKnockdownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili("knockdownRecovery", 30000);
	cooldownTimerMap->updateToCurrentAndAddMili("knockdownRecovery", 30000);
}

bool CreatureObjectImplementation::checkKnockdownRecovery() {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast("knockdownRecovery");
	return cooldownTimerMap->isPast("knockdownRecovery");
}

bool CreatureObjectImplementation::hasDizzyEvent() {
	// server/zone/objects/creature/CreatureObject.idl():  		return dizzyFallDownEvent != null;
	return dizzyFallDownEvent != NULL;
}

void CreatureObjectImplementation::clearDizzyEvent() {
	// server/zone/objects/creature/CreatureObject.idl():  	}
	if (hasDizzyEvent()){
	// server/zone/objects/creature/CreatureObject.idl():  			dizzyFallDownEvent.cancel();
	dizzyFallDownEvent->cancel();
	// server/zone/objects/creature/CreatureObject.idl():  			dizzyFallDownEvent = null;
	dizzyFallDownEvent = NULL;
}
}

unsigned long long CreatureObjectImplementation::getScreenPlayState(const String& screenPlay) {
	// server/zone/objects/creature/CreatureObject.idl():  		}
{
	Locker _locker((&screenPlayStatesMutex));
	// server/zone/objects/creature/CreatureObject.idl():  			return screenPlayStates.get(screenPlay);
	return (&screenPlayStates)->get(screenPlay);
}
}

void CreatureObjectImplementation::setScreenPlayState(const String& screenPlay, unsigned long long state) {
	// server/zone/objects/creature/CreatureObject.idl():  		}
{
	Locker _locker((&screenPlayStatesMutex));
	// server/zone/objects/creature/CreatureObject.idl():  			screenPlayStates.put(screenPlay, state);
	(&screenPlayStates)->put(screenPlay, state);
}
}

void CreatureObjectImplementation::updateCooldownTimer(const String& coooldownTimer, unsigned long long miliSecondsToAdd) {
	// server/zone/objects/creature/CreatureObject.idl():  		}
	if (miliSecondsToAdd != 0){
	// server/zone/objects/creature/CreatureObject.idl():  			cooldownTimerMap.updateToCurrentAndAddMili(coooldownTimer, miliSecondsToAdd);
	cooldownTimerMap->updateToCurrentAndAddMili(coooldownTimer, miliSecondsToAdd);
}

	else {
	// server/zone/objects/creature/CreatureObject.idl():  			cooldownTimerMap.updateToCurrentTime(coooldownTimer);
	cooldownTimerMap->updateToCurrentTime(coooldownTimer);
}
}

bool CreatureObjectImplementation::checkCooldownRecovery(const String& cooldown) {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.isPast(cooldown);
	return cooldownTimerMap->isPast(cooldown);
}

Time* CreatureObjectImplementation::getCooldownTime(const String& cooldown) {
	// server/zone/objects/creature/CreatureObject.idl():  		return cooldownTimerMap.getTime(cooldown);
	return cooldownTimerMap->getTime(cooldown);
}

void CreatureObjectImplementation::addCooldown(const String& name, unsigned long long miliseconds) {
	// server/zone/objects/creature/CreatureObject.idl():  		cooldownTimerMap.updateToCurrentAndAddMili(name, miliseconds);
	cooldownTimerMap->updateToCurrentAndAddMili(name, miliseconds);
}

bool CreatureObjectImplementation::isGrouped() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return group != null;
	return group != NULL;
}

int CreatureObjectImplementation::getBankCredits() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return creditObject.getBankCredits();
	return creditObject->getBankCredits();
}

int CreatureObjectImplementation::getCashCredits() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return creditObject.getCashCredits();
	return creditObject->getCashCredits();
}

int CreatureObjectImplementation::getBaseHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return baseHAM.get(idx);
	return (&baseHAM)->get(idx);
}

int CreatureObjectImplementation::getWounds(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return wounds.get(idx);
	return (&wounds)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getWounds() {
	// server/zone/objects/creature/CreatureObject.idl():  		return wounds;
	return (&wounds);
}

int CreatureObjectImplementation::getHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return hamList.get(idx);
	return (&hamList)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getHAM() {
	// server/zone/objects/creature/CreatureObject.idl():  		return hamList;
	return (&hamList);
}

int CreatureObjectImplementation::getMaxHAM(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return maxHamList.get(idx);
	return (&maxHamList)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getMaxHAM() {
	// server/zone/objects/creature/CreatureObject.idl():  		return maxHamList;
	return (&maxHamList);
}

int CreatureObjectImplementation::getEncumbrance(int idx) {
	// server/zone/objects/creature/CreatureObject.idl():  		return encumbrances.get(idx);
	return (&encumbrances)->get(idx);
}

DeltaVector<int>* CreatureObjectImplementation::getEncumbrances() {
	// server/zone/objects/creature/CreatureObject.idl():  		return encumbrances;
	return (&encumbrances);
}

byte CreatureObjectImplementation::getPosture() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return posture;
	return posture;
}

byte CreatureObjectImplementation::getLocomotion() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return locomotion;
	return locomotion;
}

byte CreatureObjectImplementation::getFactionRank() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return factionRank;
	return factionRank;
}

ManagedWeakReference<CreatureObject* > CreatureObjectImplementation::getLinkedCreature() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return linkedCreature;
	return linkedCreature;
}

unsigned long long CreatureObjectImplementation::getCreatureLinkID() const{
	// server/zone/objects/creature/CreatureObject.idl():  		CreatureObject strongRef = linkedCreature;
	ManagedReference<CreatureObject* > strongRef = linkedCreature;
	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	if (strongRef != NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return strongRef.getObjectID();
	return strongRef->getObjectID();

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;
}

float CreatureObjectImplementation::getShockWounds() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return shockWounds;
	return shockWounds;
}

unsigned long long CreatureObjectImplementation::getWatchToID() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return watchToID;
	return watchToID;
}

unsigned long long CreatureObjectImplementation::getStateBitmask() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask;
	return stateBitmask;
}

bool CreatureObjectImplementation::hasState(unsigned long long state) const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & state;
	return stateBitmask & state;
}

bool CreatureObjectImplementation::hasStates() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask != 0;
	return stateBitmask != 0;
}

unsigned long long CreatureObjectImplementation::getListenID() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return listenToID;
	return listenToID;
}

float CreatureObjectImplementation::getAccelerationMultiplierBase() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return accelerationMultiplierBase;
	return accelerationMultiplierBase;
}

float CreatureObjectImplementation::getAccelerationMultiplierMod() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return accelerationMultiplierMod;
	return accelerationMultiplierMod;
}

float CreatureObjectImplementation::getSpeedMultiplierBase() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return speedMultiplierBase;
	return speedMultiplierBase;
}

float CreatureObjectImplementation::getSpeedMultiplierMod() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return speedMultiplierMod;
	return speedMultiplierMod;
}

float CreatureObjectImplementation::getCurrentSpeed() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return currentSpeed;
	return currentSpeed;
}

SpeedMultiplierModChanges* CreatureObjectImplementation::getSpeedMultiplierModChanges() {
	// server/zone/objects/creature/CreatureObject.idl():  		return speedMultiplierModChanges;
	return (&speedMultiplierModChanges);
}

CommandQueueActionVector* CreatureObjectImplementation::getCommandQueue() {
	// server/zone/objects/creature/CreatureObject.idl():  		return commandQueue;
	return commandQueue;
}

int CreatureObjectImplementation::getCommandQueueSize() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return commandQueue.size();
	return commandQueue->size();
}

void CreatureObjectImplementation::setLastActionCounter(unsigned int ctr) {
	// server/zone/objects/creature/CreatureObject.idl():  		lastActionCounter = ctr;
	lastActionCounter = ctr;
}

unsigned int CreatureObjectImplementation::incrementLastActionCounter() {
	// server/zone/objects/creature/CreatureObject.idl():  		lastActionCounter = lastActionCounter + 32;
	lastActionCounter = lastActionCounter + 32;
	// server/zone/objects/creature/CreatureObject.idl():  		return 
	if (lastActionCounter < 0x40000000)	// server/zone/objects/creature/CreatureObject.idl():  			lastActionCounter = 0x40000000;
	lastActionCounter = 0x40000000;
	// server/zone/objects/creature/CreatureObject.idl():  		return lastActionCounter;
	return lastActionCounter;
}

unsigned int CreatureObjectImplementation::getLastActionCounter() {
	// server/zone/objects/creature/CreatureObject.idl():  		return lastActionCounter;
	return lastActionCounter;
}

float CreatureObjectImplementation::getRunSpeed() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return runSpeed;
	return runSpeed;
}

float CreatureObjectImplementation::getWalkSpeed() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return walkSpeed;
	return walkSpeed;
}

float CreatureObjectImplementation::getTurnScale() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return turnScale;
	return turnScale;
}

float CreatureObjectImplementation::getRunAcceleration() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return runAcceleration;
	return runAcceleration;
}

float CreatureObjectImplementation::getWalkAcceleration() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return walkAcceleration;
	return walkAcceleration;
}

String CreatureObjectImplementation::getPerformanceAnimation() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return performanceAnimation;
	return performanceAnimation;
}

String CreatureObjectImplementation::getMoodString() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return moodString;
	return moodString;
}

unsigned long long CreatureObjectImplementation::getWeaponID() const{
	// server/zone/objects/creature/CreatureObject.idl():  			return weapon.getObjectID();
	if (weapon == NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return weapon.getObjectID();
	return weapon->getObjectID();
}

ManagedWeakReference<GuildObject* > CreatureObjectImplementation::getGuildObject() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return guild;
	return guild;
}

int CreatureObjectImplementation::getGuildID() const{
	// server/zone/objects/creature/CreatureObject.idl():  		GuildObject strongRef = guild;
	ManagedReference<GuildObject* > strongRef = guild;
	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	if (strongRef != NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return strongRef.getGuildID();
	return strongRef->getGuildID();

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;
}

bool CreatureObjectImplementation::isInGuild() const{
	// server/zone/objects/creature/CreatureObject.idl():  		GuildObject strongRef = guild;
	ManagedReference<GuildObject* > strongRef = guild;
	// server/zone/objects/creature/CreatureObject.idl():  		return strongRef != null;
	return strongRef != NULL;
}

void CreatureObjectImplementation::setGuildObject(GuildObject* guildobj) {
	// server/zone/objects/creature/CreatureObject.idl():  		guild = guildobj;
	guild = guildobj;
}

unsigned long long CreatureObjectImplementation::getGroupID() const{
	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	if (group != NULL)	// server/zone/objects/creature/CreatureObject.idl():  			return group.getObjectID();
	return group->getObjectID();

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return 0;
	return 0;
}

unsigned long long CreatureObjectImplementation::getGroupInviterID() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return groupInviterID;
	return groupInviterID;
}

Reference<GroupObject* > CreatureObjectImplementation::getGroup() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return group;
	return group;
}

unsigned long long CreatureObjectImplementation::getGroupInviteCounter() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return groupInviteCounter;
	return groupInviteCounter;
}

unsigned long long CreatureObjectImplementation::getTargetID() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return targetID;
	return targetID;
}

byte CreatureObjectImplementation::getMoodID() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return moodID;
	return moodID;
}

float CreatureObjectImplementation::getSlopeModPercent() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return slopeModPercent;
	return slopeModPercent;
}

int CreatureObjectImplementation::getPerformanceCounter() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return performanceCounter;
	return performanceCounter;
}

int CreatureObjectImplementation::getInstrumentID() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return instrumentID;
	return instrumentID;
}

byte CreatureObjectImplementation::getFrozen() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return frozen;
	return frozen;
}

float CreatureObjectImplementation::getHeight() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return height;
	return height;
}

bool CreatureObjectImplementation::isDroidSpecies() {
	// server/zone/objects/creature/CreatureObject.idl():  		return getSpecies() >= 203 && getSpecies() <= 225 && getSpecies() != 207;
	return getSpecies() >= 203 && getSpecies() <= 225 && getSpecies() != 207;
}

bool CreatureObjectImplementation::isWalkerSpecies() {
	// server/zone/objects/creature/CreatureObject.idl():  		return getSpecies() == 226;
	return getSpecies() == 226;
}

bool CreatureObjectImplementation::isProbotSpecies() {
	// server/zone/objects/creature/CreatureObject.idl():  		return getSpecies() == 216;
	return getSpecies() == 216;
}

String CreatureObjectImplementation::getSpeciesName() {
	// server/zone/objects/creature/CreatureObject.idl():  		int species = getSpecies();
	int species = getSpecies();
	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 0)	// server/zone/objects/creature/CreatureObject.idl():  			return "human";
	return "human";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 1)	// server/zone/objects/creature/CreatureObject.idl():  			return "rodian";
	return "rodian";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 2)	// server/zone/objects/creature/CreatureObject.idl():  			return "trandoshan";
	return "trandoshan";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 3)	// server/zone/objects/creature/CreatureObject.idl():  			return "moncal";
	return "moncal";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 4)	// server/zone/objects/creature/CreatureObject.idl():  			return "wookiee";
	return "wookiee";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 5)	// server/zone/objects/creature/CreatureObject.idl():  			return "bothan";
	return "bothan";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 6)	// server/zone/objects/creature/CreatureObject.idl():  			return "twilek";
	return "twilek";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 7)	// server/zone/objects/creature/CreatureObject.idl():  			return "zabrak";
	return "zabrak";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 0x21)	// server/zone/objects/creature/CreatureObject.idl():  			return "ithorian";
	return "ithorian";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	if (species == 0x31)	// server/zone/objects/creature/CreatureObject.idl():  			return "sullustan";
	return "sullustan";

	else 	// server/zone/objects/creature/CreatureObject.idl():  			return "";
	return "";
}

DeltaVector<int>* CreatureObjectImplementation::getBaseHAM() {
	// server/zone/objects/creature/CreatureObject.idl():  		return baseHAM;
	return (&baseHAM);
}

SkillList* CreatureObjectImplementation::getSkillList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillList;
	return (&skillList);
}

bool CreatureObjectImplementation::hasSkill(const String& skill) {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillList.containsSkill(skill);
	return (&skillList)->containsSkill(skill);
}

SkillModList* CreatureObjectImplementation::getSkillModList() {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillModList;
	return (&skillModList);
}

void CreatureObjectImplementation::setWatchToID(unsigned long long id) {
	// server/zone/objects/creature/CreatureObject.idl():  		watchToID = id;
	watchToID = id;
}

bool CreatureObjectImplementation::isCreatureObject() {
	// server/zone/objects/creature/CreatureObject.idl():  		return true;
	return true;
}

bool CreatureObjectImplementation::isNextActionPast() {
	// server/zone/objects/creature/CreatureObject.idl():  		return nextAction.isPast();
	return (&nextAction)->isPast();
}

bool CreatureObjectImplementation::isSwimming() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.SWIMMING;
	return stateBitmask & CreatureState::SWIMMING;
}

ManagedWeakReference<ControlDevice* > CreatureObjectImplementation::getControlDevice() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return controlDevice;
	return controlDevice;
}

float CreatureObjectImplementation::getSwimHeight() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return swimHeight;
	return swimHeight;
}

bool CreatureObjectImplementation::isIncapacitated() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.INCAPACITATED;
	return posture == CreaturePosture::INCAPACITATED;
}

bool CreatureObjectImplementation::isDead() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.DEAD;
	return posture == CreaturePosture::DEAD;
}

bool CreatureObjectImplementation::isKnockedDown() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.KNOCKEDDOWN;
	return posture == CreaturePosture::KNOCKEDDOWN;
}

bool CreatureObjectImplementation::isKneeling() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.CROUCHED;
	return posture == CreaturePosture::CROUCHED;
}

bool CreatureObjectImplementation::isProne() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.PRONE;
	return posture == CreaturePosture::PRONE;
}

bool CreatureObjectImplementation::isStanding() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.UPRIGHT;
	return posture == CreaturePosture::UPRIGHT;
}

bool CreatureObjectImplementation::isSitting() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.SITTING;
	return posture == CreaturePosture::SITTING;
}

bool CreatureObjectImplementation::isSkillAnimating() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return posture == CreaturePosture.SKILLANIMATING;
	return posture == CreaturePosture::SKILLANIMATING;
}

bool CreatureObjectImplementation::isRallied() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.RALLIED;
	return stateBitmask & CreatureState::RALLIED;
}

bool CreatureObjectImplementation::isInCombat() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.COMBAT;
	return stateBitmask & CreatureState::COMBAT;
}

bool CreatureObjectImplementation::isDizzied() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.DIZZY;
	return stateBitmask & CreatureState::DIZZY;
}

bool CreatureObjectImplementation::isBerserked() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.BERSERK;
	return stateBitmask & CreatureState::BERSERK;
}

bool CreatureObjectImplementation::isStunned() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.STUNNED;
	return stateBitmask & CreatureState::STUNNED;
}

bool CreatureObjectImplementation::isBlinded() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.BLINDED;
	return stateBitmask & CreatureState::BLINDED;
}

bool CreatureObjectImplementation::isIntimidated() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.INTIMIDATED;
	return stateBitmask & CreatureState::INTIMIDATED;
}

bool CreatureObjectImplementation::isSnared() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.IMMOBILIZED;
	return stateBitmask & CreatureState::IMMOBILIZED;
}

bool CreatureObjectImplementation::isImmobilized() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.IMMOBILIZED;
	return stateBitmask & CreatureState::IMMOBILIZED;
}

bool CreatureObjectImplementation::isRooted() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.FROZEN;
	return stateBitmask & CreatureState::FROZEN;
}

bool CreatureObjectImplementation::isFrozen() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.FROZEN;
	return stateBitmask & CreatureState::FROZEN;
}

bool CreatureObjectImplementation::isDiseased() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.DISEASED;
	return stateBitmask & CreatureState::DISEASED;
}

bool CreatureObjectImplementation::isPoisoned() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.POISONED;
	return stateBitmask & CreatureState::POISONED;
}

bool CreatureObjectImplementation::isBleeding() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.BLEEDING;
	return stateBitmask & CreatureState::BLEEDING;
}

bool CreatureObjectImplementation::isOnFire() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.ONFIRE;
	return stateBitmask & CreatureState::ONFIRE;
}

bool CreatureObjectImplementation::isFeigningDeath() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.FEIGNDEATH;
	return stateBitmask & CreatureState::FEIGNDEATH;
}

bool CreatureObjectImplementation::isRidingMount() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.RIDINGMOUNT;
	return stateBitmask & CreatureState::RIDINGMOUNT;
}

bool CreatureObjectImplementation::hasRidingCreature() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.MOUNTEDCREATURE;
	return stateBitmask & CreatureState::MOUNTEDCREATURE;
}

bool CreatureObjectImplementation::isPeaced() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.PEACE;
	return stateBitmask & CreatureState::PEACE;
}

bool CreatureObjectImplementation::isMeditating() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.ALERT;
	return stateBitmask & CreatureState::ALERT;
}

bool CreatureObjectImplementation::isAiming() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.AIMING;
	return stateBitmask & CreatureState::AIMING;
}

bool CreatureObjectImplementation::isInCover() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return stateBitmask & CreatureState.COVER;
	return stateBitmask & CreatureState::COVER;
}

bool CreatureObjectImplementation::isRunning() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return currentSpeed >= runSpeed;
	return currentSpeed >= runSpeed;
}

bool CreatureObjectImplementation::isNonPlayerCreatureObject() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

bool CreatureObjectImplementation::isDroidObject() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

int CreatureObjectImplementation::registerToCloseObjectsReceivers() {
	// server/zone/objects/creature/CreatureObject.idl():  	 return isPlayerCreature();
	return isPlayerCreature();
}

bool CreatureObjectImplementation::isInformantCreature() {
	// server/zone/objects/creature/CreatureObject.idl():  		return false;
	return false;
}

byte CreatureObjectImplementation::getCurrentWeather() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return currentWeather;
	return currentWeather;
}

void CreatureObjectImplementation::setCurrentWeather(byte value) {
	// server/zone/objects/creature/CreatureObject.idl():  		currentWeather = value;
	currentWeather = value;
}

byte CreatureObjectImplementation::getCurrentWind() const{
	// server/zone/objects/creature/CreatureObject.idl():  		return currentWind;
	return currentWind;
}

void CreatureObjectImplementation::setCurrentWind(byte value) {
	// server/zone/objects/creature/CreatureObject.idl():  		currentWind = value;
	currentWind = value;
}

String CreatureObjectImplementation::getAlternateAppearance() {
	// server/zone/objects/creature/CreatureObject.idl():  		return alternateAppearance;
	return alternateAppearance;
}

Mutex* CreatureObjectImplementation::getSkillModMutex() {
	// server/zone/objects/creature/CreatureObject.idl():  		return skillModMutex;
	return (&skillModMutex);
}

void CreatureObjectImplementation::reloadTemplate() {
}

/*
 *	CreatureObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


CreatureObjectAdapter::CreatureObjectAdapter(CreatureObject* obj) : TangibleObjectAdapter(obj) {
}

void CreatureObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZEMEMBERS__:
		{
			
			initializeMembers();
			
		}
		break;
	case RPC_FINALIZE__:
		{
			
			finalize();
			
		}
		break;
	case RPC_CREATECHILDOBJECTS__:
		{
			
			createChildObjects();
			
		}
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_SETCOUNTDOWNTIMER__INT_BOOL_:
		{
			unsigned int newCount = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCountdownTimer(newCount, notifyClient);
			
		}
		break;
	case RPC_CLEARQUEUEACTION__INT_FLOAT_INT_INT_:
		{
			unsigned int actioncntr = inv->getUnsignedIntParameter();
			float timer = inv->getFloatParameter();
			unsigned int tab1 = inv->getUnsignedIntParameter();
			unsigned int tab2 = inv->getUnsignedIntParameter();
			
			clearQueueAction(actioncntr, timer, tab1, tab2);
			
		}
		break;
	case RPC_CLEARQUEUEACTIONS__BOOL_:
		{
			bool combatOnly = inv->getBooleanParameter();
			
			clearQueueActions(combatOnly);
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_SENDTOOWNER__BOOL_:
		{
			bool doClose = inv->getBooleanParameter();
			
			sendToOwner(doClose);
			
		}
		break;
	case RPC_SENDSYSTEMMESSAGE__STRING_:
		{
			 String message; inv->getAsciiParameter(message);
			
			sendSystemMessage(message);
			
		}
		break;
	case RPC_PLAYMUSICMESSAGE__STRING_:
		{
			 String file; inv->getAsciiParameter(file);
			
			playMusicMessage(file);
			
		}
		break;
	case RPC_SENDNEWBIETUTORIALREQUEST__STRING_:
		{
			 String request; inv->getAsciiParameter(request);
			
			sendNewbieTutorialRequest(request);
			
		}
		break;
	case RPC_SENDNEWBIETUTORIALENABLEHUDELEMENT__STRING_BOOL_FLOAT_:
		{
			 String ui; inv->getAsciiParameter(ui);
			bool enable = inv->getBooleanParameter();
			float blinkCount = inv->getFloatParameter();
			
			sendNewbieTutorialEnableHudElement(ui, enable, blinkCount);
			
		}
		break;
	case RPC_SENDOPENHOLOCRONTOPAGEMESSAGE__:
		{
			
			sendOpenHolocronToPageMessage();
			
		}
		break;
	case RPC_SENDSYSTEMMESSAGE__UNICODESTRING_:
		{
			UnicodeString message; inv->getUnicodeParameter(message);
			
			sendSystemMessage(message);
			
		}
		break;
	case RPC_SENDSLOTTEDOBJECTSTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendSlottedObjectsTo(player);
			
		}
		break;
	case RPC_SETCOMBATSTATE__:
		{
			
			setCombatState();
			
		}
		break;
	case RPC_CLEARCOMBATSTATE__BOOL_:
		{
			bool clearDefenders = inv->getBooleanParameter();
			
			clearCombatState(clearDefenders);
			
		}
		break;
	case RPC_ADDMOUNTEDCOMBATSLOW__:
		{
			
			addMountedCombatSlow();
			
		}
		break;
	case RPC_REMOVEMOUNTEDCOMBATSLOW__BOOL_:
		{
			bool showEndMessage = inv->getBooleanParameter();
			
			removeMountedCombatSlow(showEndMessage);
			
		}
		break;
	case RPC_SETPOSTURE__INT_BOOL_BOOL_:
		{
			int newPosture = inv->getSignedIntParameter();
			bool immediate = inv->getBooleanParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setPosture(newPosture, immediate, notifyClient);
			
		}
		break;
	case RPC_UPDATEPOSTURES__BOOL_:
		{
			bool immediate = inv->getBooleanParameter();
			
			updatePostures(immediate);
			
		}
		break;
	case RPC_CALCULATESPEED__:
		{
			
			float _m_res = calculateSpeed();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_UPDATELOCOMOTION__:
		{
			
			updateLocomotion();
			
		}
		break;
	case RPC_SETHEIGHT__FLOAT_BOOL_:
		{
			float heigh = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setHeight(heigh, notifyClient);
			
		}
		break;
	case RPC_SETACCELERATIONMULTIPLIERBASE__FLOAT_BOOL_:
		{
			float newMultiplierBase = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setAccelerationMultiplierBase(newMultiplierBase, notifyClient);
			
		}
		break;
	case RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_BOOL_:
		{
			float newMultiplierMod = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setAccelerationMultiplierMod(newMultiplierMod, notifyClient);
			
		}
		break;
	case RPC_SETSPEEDMULTIPLIERBASE__FLOAT_BOOL_:
		{
			float newMultiplierBase = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setSpeedMultiplierBase(newMultiplierBase, notifyClient);
			
		}
		break;
	case RPC_SETSPEEDMULTIPLIERMOD__FLOAT_BOOL_:
		{
			float newMultiplierMod = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setSpeedMultiplierMod(newMultiplierMod, notifyClient);
			
		}
		break;
	case RPC_SETTURNSCALE__FLOAT_BOOL_:
		{
			float newMultiplierMod = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setTurnScale(newMultiplierMod, notifyClient);
			
		}
		break;
	case RPC_SETRUNSPEED__FLOAT_BOOL_:
		{
			float newSpeed = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setRunSpeed(newSpeed, notifyClient);
			
		}
		break;
	case RPC_SETCURRENTSPEED__FLOAT_:
		{
			float newSpeed = inv->getFloatParameter();
			
			setCurrentSpeed(newSpeed);
			
		}
		break;
	case RPC_SETHAM__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setHAM(type, value, notifyClient);
			
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			float damage = inv->getFloatParameter();
			bool destroy = inv->getBooleanParameter();
			bool notifyClient = inv->getBooleanParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			float damage = inv->getFloatParameter();
			bool destroy = inv->getBooleanParameter();
			 String xp; inv->getAsciiParameter(xp);
			bool notifyClient = inv->getBooleanParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASDAMAGE__INT_:
		{
			int attribute = inv->getSignedIntParameter();
			
			bool _m_res = hasDamage(attribute);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_:
		{
			TangibleObject* healer = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			int damage = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			bool notifyObservers = inv->getBooleanParameter();
			
			int _m_res = healDamage(healer, damageType, damage, notifyClient, notifyObservers);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HEALWOUND__TANGIBLEOBJECT_INT_INT_BOOL_BOOL_:
		{
			TangibleObject* healer = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			int damage = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			bool notifyObservers = inv->getBooleanParameter();
			
			int _m_res = healWound(healer, damageType, damage, notifyClient, notifyObservers);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETBASEHAM__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setBaseHAM(type, value, notifyClient);
			
		}
		break;
	case RPC_SETWOUNDS__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setWounds(type, value, notifyClient);
			
		}
		break;
	case RPC_ADDWOUNDS__INT_INT_BOOL_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			bool doShockWounds = inv->getBooleanParameter();
			
			int _m_res = addWounds(type, value, notifyClient, doShockWounds);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMAXHAM__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setMaxHAM(type, value, notifyClient);
			
		}
		break;
	case RPC_ADDMAXHAM__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addMaxHAM(type, value, notifyClient);
			
		}
		break;
	case RPC_SETENCUMBRANCE__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setEncumbrance(type, value, notifyClient);
			
		}
		break;
	case RPC_ADDENCUMBRANCE__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addEncumbrance(type, value, notifyClient);
			
		}
		break;
	case RPC_SETWEAPON__WEAPONOBJECT_BOOL_:
		{
			WeaponObject* weao = static_cast<WeaponObject*>(inv->getObjectParameter());
			bool notifyClient = inv->getBooleanParameter();
			
			setWeapon(weao, notifyClient);
			
		}
		break;
	case RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			int _m_res = notifyObjectInserted(object);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			int _m_res = notifyObjectRemoved(object);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETINSTRUMENTID__INT_BOOL_:
		{
			int instrumentid = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setInstrumentID(instrumentid, notifyClient);
			
		}
		break;
	case RPC_SETLISTENTOID__LONG_BOOL_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setListenToID(id, notifyClient);
			
		}
		break;
	case RPC_SETPERFORMANCECOUNTER__INT_BOOL_:
		{
			int counter = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setPerformanceCounter(counter, notifyClient);
			
		}
		break;
	case RPC_SETPERFORMANCEANIMATION__STRING_BOOL_:
		{
			 String animation; inv->getAsciiParameter(animation);
			bool notifyClient = inv->getBooleanParameter();
			
			setPerformanceAnimation(animation, notifyClient);
			
		}
		break;
	case RPC_SETSHOCKWOUNDS__INT_BOOL_:
		{
			int newShock = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setShockWounds(newShock, notifyClient);
			
		}
		break;
	case RPC_ADDSHOCKWOUNDS__INT_BOOL_BOOL_:
		{
			int shockToAdd = inv->getSignedIntParameter();
			bool notiyClient = inv->getBooleanParameter();
			bool sendSpam = inv->getBooleanParameter();
			
			addShockWounds(shockToAdd, notiyClient, sendSpam);
			
		}
		break;
	case RPC_SETTARGETID__LONG_BOOL_:
		{
			unsigned long long targetID = inv->getUnsignedLongParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setTargetID(targetID, notifyClient);
			
		}
		break;
	case RPC_SETBANKCREDITS__INT_BOOL_:
		{
			int credits = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setBankCredits(credits, notifyClient);
			
		}
		break;
	case RPC_ADDBUFF__BUFF_:
		{
			Buff* buff = static_cast<Buff*>(inv->getObjectParameter());
			
			addBuff(buff);
			
		}
		break;
	case RPC_REMOVEBUFF__INT_:
		{
			unsigned int buffcrc = inv->getUnsignedIntParameter();
			
			bool _m_res = removeBuff(buffcrc);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_REMOVEBUFF__BUFF_:
		{
			Buff* buff = static_cast<Buff*>(inv->getObjectParameter());
			
			removeBuff(buff);
			
		}
		break;
	case RPC_REMOVESTATEBUFF__LONG_:
		{
			unsigned long long state = inv->getUnsignedLongParameter();
			
			bool _m_res = removeStateBuff(state);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARBUFFS__BOOL_BOOL_:
		{
			bool updateclient = inv->getBooleanParameter();
			bool removeAll = inv->getBooleanParameter();
			
			clearBuffs(updateclient, removeAll);
			
		}
		break;
	case RPC_RENEWBUFF__INT_INT_BOOL_:
		{
			unsigned int buffCRC = inv->getUnsignedIntParameter();
			int duration = inv->getSignedIntParameter();
			bool sendToClient = inv->getBooleanParameter();
			
			renewBuff(buffCRC, duration, sendToClient);
			
		}
		break;
	case RPC_UPDATEVEHICLEPOSITION__BOOL_:
		{
			bool sendPackets = inv->getBooleanParameter();
			
			updateVehiclePosition(sendPackets);
			
		}
		break;
	case RPC_ADDWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_:
		{
			TangibleObject* object = static_cast<TangibleObject*>(inv->getObjectParameter());
			bool notifyClient = inv->getBooleanParameter();
			
			addWearableObject(object, notifyClient);
			
		}
		break;
	case RPC_REMOVEWEARABLEOBJECT__TANGIBLEOBJECT_BOOL_:
		{
			TangibleObject* object = static_cast<TangibleObject*>(inv->getObjectParameter());
			bool notifyClient = inv->getBooleanParameter();
			
			removeWearableObject(object, notifyClient);
			
		}
		break;
	case RPC_SENDBUFFSTO__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendBuffsTo(creature);
			
		}
		break;
	case RPC_GETBUFF__INT_:
		{
			unsigned int buffcrc = inv->getUnsignedIntParameter();
			
			DistributedObject* _m_res = getBuff(buffcrc);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETSKILLMODFROMBUFFS__STRING_:
		{
			 String skillMod; inv->getAsciiParameter(skillMod);
			
			long long _m_res = getSkillModFromBuffs(skillMod);
			resp->insertSignedLong(_m_res);
		}
		break;
	case RPC_ADDDOTSTATE__CREATUREOBJECT_LONG_LONG_INT_BYTE_INT_FLOAT_INT_INT_:
		{
			CreatureObject* attacker = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long dotType = inv->getUnsignedLongParameter();
			unsigned long long objectID = inv->getUnsignedLongParameter();
			unsigned int strength = inv->getUnsignedIntParameter();
			byte type = inv->getByteParameter();
			unsigned int duration = inv->getUnsignedIntParameter();
			float potency = inv->getFloatParameter();
			unsigned int defense = inv->getUnsignedIntParameter();
			int secondaryStrength = inv->getSignedIntParameter();
			
			int _m_res = addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HEALDOT__LONG_INT_BOOL_:
		{
			unsigned long long dotType = inv->getUnsignedLongParameter();
			int reduction = inv->getSignedIntParameter();
			bool sendMsg = inv->getBooleanParameter();
			
			bool _m_res = healDot(dotType, reduction, sendMsg);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARDOTS__:
		{
			
			clearDots();
			
		}
		break;
	case RPC_HASBUFF__INT_:
		{
			unsigned int buffcrc = inv->getUnsignedIntParameter();
			
			bool _m_res = hasBuff(buffcrc);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_NOTIFYSELFPOSITIONUPDATE__:
		{
			
			notifySelfPositionUpdate();
			
		}
		break;
	case RPC_NOTIFYPOSTURECHANGE__INT_:
		{
			int newPosture = inv->getSignedIntParameter();
			
			notifyPostureChange(newPosture);
			
		}
		break;
	case RPC_SETLEVEL__INT_BOOL_:
		{
			int level = inv->getSignedIntParameter();
			bool randomHam = inv->getBooleanParameter();
			
			setLevel(level, randomHam);
			
		}
		break;
	case RPC_UPDATETODATABASEALLOBJECTS__BOOL_:
		{
			bool startTask = inv->getBooleanParameter();
			
			updateToDatabaseAllObjects(startTask);
			
		}
		break;
	case RPC_ISRESUSCITABLE__:
		{
			
			bool _m_res = isResuscitable();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDBANKCREDITS__INT_BOOL_:
		{
			int credits = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addBankCredits(credits, notifyClient);
			
		}
		break;
	case RPC_ADDCASHCREDITS__INT_BOOL_:
		{
			int credits = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addCashCredits(credits, notifyClient);
			
		}
		break;
	case RPC_GETCREDITOBJECT__:
		{
			
			DistributedObject* _m_res = getCreditObject();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_SUBTRACTBANKCREDITS__INT_:
		{
			int credits = inv->getSignedIntParameter();
			
			subtractBankCredits(credits);
			
		}
		break;
	case RPC_SUBTRACTCASHCREDITS__INT_:
		{
			int credits = inv->getSignedIntParameter();
			
			subtractCashCredits(credits);
			
		}
		break;
	case RPC_VERIFYCASHCREDITS__INT_:
		{
			int credits = inv->getSignedIntParameter();
			
			bool _m_res = verifyCashCredits(credits);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_VERIFYBANKCREDITS__INT_:
		{
			int credits = inv->getSignedIntParameter();
			
			bool _m_res = verifyBankCredits(credits);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISDANCING__:
		{
			
			bool _m_res = isDancing();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPLAYINGMUSIC__:
		{
			
			bool _m_res = isPlayingMusic();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_STOPENTERTAINING__:
		{
			
			stopEntertaining();
			
		}
		break;
	case RPC_ISENTERTAINING__:
		{
			
			bool _m_res = isEntertaining();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCASHCREDITS__INT_BOOL_:
		{
			int credits = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCashCredits(credits, notifyClient);
			
		}
		break;
	case RPC_SETTERRAINNEGOTIATION__FLOAT_BOOL_:
		{
			float value = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setTerrainNegotiation(value, notifyClient);
			
		}
		break;
	case RPC_UPDATETERRAINNEGOTIATION__:
		{
			
			updateTerrainNegotiation();
			
		}
		break;
	case RPC_ADDSKILL__STRING_BOOL_:
		{
			 String skill; inv->getAsciiParameter(skill);
			bool notifyClient = inv->getBooleanParameter();
			
			addSkill(skill, notifyClient);
			
		}
		break;
	case RPC_REMOVESKILL__STRING_BOOL_:
		{
			 String skill; inv->getAsciiParameter(skill);
			bool notifyClient = inv->getBooleanParameter();
			
			removeSkill(skill, notifyClient);
			
		}
		break;
	case RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_:
		{
			 int modType = inv->getSignedIntParameter();
			 String skillMod; inv->getAsciiParameter(skillMod);
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addSkillMod(modType, skillMod, value, notifyClient);
			
		}
		break;
	case RPC_REMOVESKILLMOD__INT_STRING_INT_BOOL_:
		{
			 int modType = inv->getSignedIntParameter();
			 String skillMod; inv->getAsciiParameter(skillMod);
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			removeSkillMod(modType, skillMod, value, notifyClient);
			
		}
		break;
	case RPC_REMOVEALLSKILLMODSOFTYPE__INT_BOOL_:
		{
			 int modType = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			removeAllSkillModsOfType(modType, notifyClient);
			
		}
		break;
	case RPC_UPDATEGROUPINVITERID__LONG_BOOL_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			updateGroupInviterID(id, notifyClient);
			
		}
		break;
	case RPC_UPDATEGROUP__GROUPOBJECT_BOOL_:
		{
			GroupObject* group = static_cast<GroupObject*>(inv->getObjectParameter());
			bool notifyClient = inv->getBooleanParameter();
			
			updateGroup(group, notifyClient);
			
		}
		break;
	case RPC_ENQUEUECOMMAND__INT_INT_LONG_UNICODESTRING_INT_INT_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			unsigned int actionCount = inv->getUnsignedIntParameter();
			unsigned long long targetID = inv->getUnsignedLongParameter();
			 UnicodeString arguments; inv->getUnicodeParameter(arguments);
			int priority = inv->getSignedIntParameter();
			int compareCount = inv->getSignedIntParameter();
			
			enqueueCommand(actionCRC, actionCount, targetID, arguments, priority, compareCount);
			
		}
		break;
	case RPC_SENDCOMMAND__INT_UNICODESTRING_LONG_INT_:
		{
			unsigned int crc = inv->getUnsignedIntParameter();
			 UnicodeString args; inv->getUnicodeParameter(args);
			unsigned long long targetID = inv->getUnsignedLongParameter();
			int priority = inv->getSignedIntParameter();
			
			sendCommand(crc, args, targetID, priority);
			
		}
		break;
	case RPC_SENDCOMMAND__STRING_UNICODESTRING_LONG_INT_:
		{
			 String action; inv->getAsciiParameter(action);
			 UnicodeString args; inv->getUnicodeParameter(args);
			unsigned long long targetID = inv->getUnsignedLongParameter();
			int priority = inv->getSignedIntParameter();
			
			sendCommand(action, args, targetID, priority);
			
		}
		break;
	case RPC_SETMOOD__BYTE_BOOL_:
		{
			byte moodID = inv->getByteParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setMood(moodID, notifyClient);
			
		}
		break;
	case RPC_SETMOODSTRING__STRING_BOOL_:
		{
			 String animation; inv->getAsciiParameter(animation);
			bool notifyClient = inv->getBooleanParameter();
			
			setMoodString(animation, notifyClient);
			
		}
		break;
	case RPC_DELETEQUEUEACTION__INT_:
		{
			unsigned int actionCount = inv->getUnsignedIntParameter();
			
			deleteQueueAction(actionCount);
			
		}
		break;
	case RPC_SETSTATE__LONG_BOOL_:
		{
			unsigned long long state = inv->getUnsignedLongParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			bool _m_res = setState(state, notifyClient);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETALTERNATEAPPEARANCE__STRING_BOOL_:
		{
			 String appearanceTeamplate; inv->getAsciiParameter(appearanceTeamplate);
			bool notifyClient = inv->getBooleanParameter();
			
			setAlternateAppearance(appearanceTeamplate, notifyClient);
			
		}
		break;
	case RPC_CLEARSTATE__LONG_BOOL_:
		{
			unsigned long long state = inv->getUnsignedLongParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			bool _m_res = clearState(state, notifyClient);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCONTROLDEVICE__CONTROLDEVICE_:
		{
			ControlDevice* device = static_cast<ControlDevice*>(inv->getObjectParameter());
			
			setControlDevice(device);
			
		}
		break;
	case RPC_SETCREATURELINK__CREATUREOBJECT_BOOL_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			bool notifyClient = inv->getBooleanParameter();
			
			setCreatureLink(object, notifyClient);
			
		}
		break;
	case RPC_EXECUTEOBJECTCONTROLLERACTION__INT_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			
			executeObjectControllerAction(actionCRC);
			
		}
		break;
	case RPC_EXECUTEOBJECTCONTROLLERACTION__INT_LONG_UNICODESTRING_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			unsigned long long targetID = inv->getUnsignedLongParameter();
			 UnicodeString args; inv->getUnicodeParameter(args);
			
			executeObjectControllerAction(actionCRC, targetID, args);
			
		}
		break;
	case RPC_ISATTACKABLEBY__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAttackableBy(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISATTACKABLEBY__CREATUREOBJECT_BOOL_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			bool bypassDeadCheck = inv->getBooleanParameter();
			
			bool _m_res = isAttackableBy(object, bypassDeadCheck);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISATTACKABLEBY__TANGIBLEOBJECT_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			bool _m_res = isAttackableBy(attacker);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISATTACKABLEBY__TANGIBLEOBJECT_BOOL_:
		{
			TangibleObject* object = static_cast<TangibleObject*>(inv->getObjectParameter());
			bool bypassDeadCheck = inv->getBooleanParameter();
			
			bool _m_res = isAttackableBy(object, bypassDeadCheck);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISHEALABLEBY__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isHealableBy(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASBOUNTYMISSIONFOR__CREATUREOBJECT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = hasBountyMissionFor(target);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = sendConversationStartTo(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_:
		{
			int option = inv->getSignedIntParameter();
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			selectConversationOption(option, obj);
			
		}
		break;
	case RPC_SENDMESSAGE__BASEPACKET_:
		{
			BasePacket* msg = static_cast<BasePacket*>(inv->getObjectParameter());
			
			sendMessage(msg);
			
		}
		break;
	case RPC_SENDSTATECOMBATSPAM__STRING_STRING_BYTE_INT_BOOL_:
		{
			 String fileName; inv->getAsciiParameter(fileName);
			 String stringName; inv->getAsciiParameter(stringName);
			byte color = inv->getByteParameter();
			int damage = inv->getSignedIntParameter();
			bool broadcast = inv->getBooleanParameter();
			
			sendStateCombatSpam(fileName, stringName, color, damage, broadcast);
			
		}
		break;
	case RPC_SENDCUSTOMCOMBATSPAM__UNICODESTRING_BYTE_:
		{
			 UnicodeString customString; inv->getUnicodeParameter(customString);
			byte color = inv->getByteParameter();
			
			sendCustomCombatSpam(customString, color);
			
		}
		break;
	case RPC_SENDEXECUTECONSOLECOMMAND__STRING_:
		{
			 String command; inv->getAsciiParameter(command);
			
			sendExecuteConsoleCommand(command);
			
		}
		break;
	case RPC_ISAGGRESSIVETO__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAggressiveTo(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int condition = inv->getSignedIntParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = notifyObjectDestructionObservers(attacker, condition, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYOBJECTKILLOBSERVERS__TANGIBLEOBJECT_:
		{
			TangibleObject* killer = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			int _m_res = notifyObjectKillObservers(killer);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_DESTROYOBJECTFROMDATABASE__BOOL_:
		{
			bool destroyContainedObjects = inv->getBooleanParameter();
			
			destroyObjectFromDatabase(destroyContainedObjects);
			
		}
		break;
	case RPC_SETFACTIONRANK__INT_BOOL_:
		{
			int rank = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setFactionRank(rank, notifyClient);
			
		}
		break;
	case RPC_GETFIRSTNAME__:
		{
			
			String _m_res = getFirstName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETLASTNAME__:
		{
			
			String _m_res = getLastName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ISONLINE__:
		{
			
			bool _m_res = isOnline();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANTREATINJURIES__:
		{
			
			bool _m_res = canTreatInjuries();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANTREATSTATES__:
		{
			
			bool _m_res = canTreatStates();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANTREATWOUNDS__:
		{
			
			bool _m_res = canTreatWounds();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANTREATCONDITIONS__:
		{
			
			bool _m_res = canTreatConditions();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPLAYEROBJECT__:
		{
			
			DistributedObject* _m_res = getPlayerObject();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_ISLISTENING__:
		{
			
			bool _m_res = isListening();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISWATCHING__:
		{
			
			bool _m_res = isWatching();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCLIENT__ZONECLIENTSESSION_:
		{
			ZoneClientSession* cli = static_cast<ZoneClientSession*>(inv->getObjectParameter());
			
			setClient(cli);
			
		}
		break;
	case RPC_DISMOUNT__:
		{
			
			dismount();
			
		}
		break;
	case RPC_CALCULATEBFRATIO__:
		{
			
			float _m_res = calculateBFRatio();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_REMOVEFEIGNEDDEATH__:
		{
			
			removeFeignedDeath();
			
		}
		break;
	case RPC_CANFEIGNDEATH__:
		{
			
			bool _m_res = canFeignDeath();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_FEIGNDEATH__:
		{
			
			feignDeath();
			
		}
		break;
	case RPC_SETFEIGNEDDEATHSTATE__:
		{
			
			setFeignedDeathState();
			
		}
		break;
	case RPC_SETDIZZIEDSTATE__INT_:
		{
			int durationSeconds = inv->getSignedIntParameter();
			
			setDizziedState(durationSeconds);
			
		}
		break;
	case RPC_SETRALLIEDSTATE__INT_:
		{
			int durationSeconds = inv->getSignedIntParameter();
			
			setRalliedState(durationSeconds);
			
		}
		break;
	case RPC_SETAIMINGSTATE__INT_:
		{
			int durationSeconds = inv->getSignedIntParameter();
			
			setAimingState(durationSeconds);
			
		}
		break;
	case RPC_SETCOVERSTATE__INT_:
		{
			int durationSeconds = inv->getSignedIntParameter();
			
			setCoverState(durationSeconds);
			
		}
		break;
	case RPC_SETBERSERKEDSTATE__INT_:
		{
			unsigned int duration = inv->getUnsignedIntParameter();
			
			setBerserkedState(duration);
			
		}
		break;
	case RPC_SETSTUNNEDSTATE__INT_:
		{
			int durationSeconds = inv->getSignedIntParameter();
			
			setStunnedState(durationSeconds);
			
		}
		break;
	case RPC_SETBLINDEDSTATE__INT_:
		{
			int durationSeconds = inv->getSignedIntParameter();
			
			setBlindedState(durationSeconds);
			
		}
		break;
	case RPC_SETINTIMIDATEDSTATE__INT_:
		{
			int durationSeconds = inv->getSignedIntParameter();
			
			setIntimidatedState(durationSeconds);
			
		}
		break;
	case RPC_SETSNAREDSTATE__INT_:
		{
			int durationSeconds = inv->getSignedIntParameter();
			
			setSnaredState(durationSeconds);
			
		}
		break;
	case RPC_SETROOTEDSTATE__INT_:
		{
			int durationSeconds = inv->getSignedIntParameter();
			
			setRootedState(durationSeconds);
			
		}
		break;
	case RPC_SETNEXTATTACKDELAY__INT_INT_:
		{
			unsigned int mod = inv->getUnsignedIntParameter();
			int del = inv->getSignedIntParameter();
			
			bool _m_res = setNextAttackDelay(mod, del);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETMEDITATESTATE__:
		{
			
			setMeditateState();
			
		}
		break;
	case RPC_ACTIVATEHAMREGENERATION__INT_:
		{
			int latency = inv->getSignedIntParameter();
			
			activateHAMRegeneration(latency);
			
		}
		break;
	case RPC_ACTIVATEPASSIVEWOUNDREGENERATION__:
		{
			
			activatePassiveWoundRegeneration();
			
		}
		break;
	case RPC_ACTIVATESTATERECOVERY__:
		{
			
			activateStateRecovery();
			
		}
		break;
	case RPC_UPDATETIMEOFDEATH__:
		{
			
			updateTimeOfDeath();
			
		}
		break;
	case RPC_HASATTACKDELAY__:
		{
			
			bool _m_res = hasAttackDelay();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_REMOVEATTACKDELAY__:
		{
			
			removeAttackDelay();
			
		}
		break;
	case RPC_HASINCAPTIMER__:
		{
			
			bool _m_res = hasIncapTimer();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASSPICE__:
		{
			
			bool _m_res = hasSpice();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_UPDATELASTSUCCESSFULCOMBATACTION__:
		{
			
			updateLastSuccessfulCombatAction();
			
		}
		break;
	case RPC_UPDATEPOSTURECHANGEDELAY__LONG_:
		{
			unsigned long long delay = inv->getUnsignedLongParameter();
			
			updatePostureChangeDelay(delay);
			
		}
		break;
	case RPC_CHECKPOSTURECHANGEDELAY__:
		{
			
			bool _m_res = checkPostureChangeDelay();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_UPDATEPOSTUREDOWNRECOVERY__:
		{
			
			updatePostureDownRecovery();
			
		}
		break;
	case RPC_CHECKPOSTUREDOWNRECOVERY__:
		{
			
			bool _m_res = checkPostureDownRecovery();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_UPDATEPOSTUREUPRECOVERY__:
		{
			
			updatePostureUpRecovery();
			
		}
		break;
	case RPC_CHECKPOSTUREUPRECOVERY__:
		{
			
			bool _m_res = checkPostureUpRecovery();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_UPDATEKNOCKDOWNRECOVERY__:
		{
			
			updateKnockdownRecovery();
			
		}
		break;
	case RPC_CHECKKNOCKDOWNRECOVERY__:
		{
			
			bool _m_res = checkKnockdownRecovery();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_UPDATEGROUPMFDPOSITIONS__:
		{
			
			updateGroupMFDPositions();
			
		}
		break;
	case RPC_QUEUEDIZZYFALLEVENT__:
		{
			
			queueDizzyFallEvent();
			
		}
		break;
	case RPC_HASDIZZYEVENT__:
		{
			
			bool _m_res = hasDizzyEvent();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARDIZZYEVENT__:
		{
			
			clearDizzyEvent();
			
		}
		break;
	case RPC_GETSCREENPLAYSTATE__STRING_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			
			unsigned long long _m_res = getScreenPlayState(screenPlay);
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETSCREENPLAYSTATE__STRING_LONG_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			unsigned long long state = inv->getUnsignedLongParameter();
			
			setScreenPlayState(screenPlay, state);
			
		}
		break;
	case RPC_UPDATECOOLDOWNTIMER__STRING_LONG_:
		{
			 String coooldownTimer; inv->getAsciiParameter(coooldownTimer);
			unsigned long long miliSecondsToAdd = inv->getUnsignedLongParameter();
			
			updateCooldownTimer(coooldownTimer, miliSecondsToAdd);
			
		}
		break;
	case RPC_CHECKCOOLDOWNRECOVERY__STRING_:
		{
			 String cooldown; inv->getAsciiParameter(cooldown);
			
			bool _m_res = checkCooldownRecovery(cooldown);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDCOOLDOWN__STRING_LONG_:
		{
			 String name; inv->getAsciiParameter(name);
			unsigned long long miliseconds = inv->getUnsignedLongParameter();
			
			addCooldown(name, miliseconds);
			
		}
		break;
	case RPC_DOANIMATION__STRING_:
		{
			 String animation; inv->getAsciiParameter(animation);
			
			doAnimation(animation);
			
		}
		break;
	case RPC_DOCOMBATANIMATION__TANGIBLEOBJECT_INT_BYTE_BYTE_LONG_:
		{
			TangibleObject* defender = static_cast<TangibleObject*>(inv->getObjectParameter());
			unsigned int animationCRC = inv->getUnsignedIntParameter();
			byte hit = inv->getByteParameter();
			byte trails = inv->getByteParameter();
			unsigned long long weaponID = inv->getUnsignedLongParameter();
			
			doCombatAnimation(defender, animationCRC, hit, trails, weaponID);
			
		}
		break;
	case RPC_DOCOMBATANIMATION__INT_:
		{
			unsigned int animationCRC = inv->getUnsignedIntParameter();
			
			doCombatAnimation(animationCRC);
			
		}
		break;
	case RPC_ACTIVATEQUEUEACTION__:
		{
			
			activateQueueAction();
			
		}
		break;
	case RPC_ACTIVATEIMMEDIATEACTION__:
		{
			
			activateImmediateAction();
			
		}
		break;
	case RPC_GETCREATURENAME__:
		{
			
			UnicodeString _m_res = getCreatureName();
			resp->insertUnicode(_m_res);
		}
		break;
	case RPC_ISGROUPED__:
		{
			
			bool _m_res = isGrouped();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETBANKCREDITS__:
		{
			
			int _m_res = getBankCredits();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCASHCREDITS__:
		{
			
			int _m_res = getCashCredits();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBASEHAM__INT_:
		{
			int idx = inv->getSignedIntParameter();
			
			int _m_res = getBaseHAM(idx);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETWOUNDS__INT_:
		{
			int idx = inv->getSignedIntParameter();
			
			int _m_res = getWounds(idx);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETHAM__INT_:
		{
			int idx = inv->getSignedIntParameter();
			
			int _m_res = getHAM(idx);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMAXHAM__INT_:
		{
			int idx = inv->getSignedIntParameter();
			
			int _m_res = getMaxHAM(idx);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETENCUMBRANCE__INT_:
		{
			int idx = inv->getSignedIntParameter();
			
			int _m_res = getEncumbrance(idx);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETPOSTURE__:
		{
			
			byte _m_res = getPosture();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_GETLOCOMOTION__:
		{
			
			byte _m_res = getLocomotion();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_GETFACTIONRANK__:
		{
			
			byte _m_res = getFactionRank();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_GETLINKEDCREATURE__:
		{
			
			DistributedObject* _m_res = getLinkedCreature().get();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETCREATURELINKID__:
		{
			
			unsigned long long _m_res = getCreatureLinkID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETSHOCKWOUNDS__:
		{
			
			float _m_res = getShockWounds();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETWATCHTOID__:
		{
			
			unsigned long long _m_res = getWatchToID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETSTATEBITMASK__:
		{
			
			unsigned long long _m_res = getStateBitmask();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_HASSTATE__LONG_:
		{
			unsigned long long state = inv->getUnsignedLongParameter();
			
			bool _m_res = hasState(state);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASSTATES__:
		{
			
			bool _m_res = hasStates();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETLISTENID__:
		{
			
			unsigned long long _m_res = getListenID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETACCELERATIONMULTIPLIERBASE__:
		{
			
			float _m_res = getAccelerationMultiplierBase();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETACCELERATIONMULTIPLIERMOD__:
		{
			
			float _m_res = getAccelerationMultiplierMod();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETSPEEDMULTIPLIERBASE__:
		{
			
			float _m_res = getSpeedMultiplierBase();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETSPEEDMULTIPLIERMOD__:
		{
			
			float _m_res = getSpeedMultiplierMod();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCURRENTSPEED__:
		{
			
			float _m_res = getCurrentSpeed();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCOMMANDQUEUESIZE__:
		{
			
			int _m_res = getCommandQueueSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETLASTACTIONCOUNTER__INT_:
		{
			unsigned int ctr = inv->getUnsignedIntParameter();
			
			setLastActionCounter(ctr);
			
		}
		break;
	case RPC_INCREMENTLASTACTIONCOUNTER__:
		{
			
			unsigned int _m_res = incrementLastActionCounter();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETLASTACTIONCOUNTER__:
		{
			
			unsigned int _m_res = getLastActionCounter();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETRUNSPEED__:
		{
			
			float _m_res = getRunSpeed();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETWALKSPEED__:
		{
			
			float _m_res = getWalkSpeed();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETTURNSCALE__:
		{
			
			float _m_res = getTurnScale();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETTERRAINNEGOTIATION__:
		{
			
			float _m_res = getTerrainNegotiation();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETRUNACCELERATION__:
		{
			
			float _m_res = getRunAcceleration();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETWALKACCELERATION__:
		{
			
			float _m_res = getWalkAcceleration();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETPERFORMANCEANIMATION__:
		{
			
			String _m_res = getPerformanceAnimation();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETMOODSTRING__:
		{
			
			String _m_res = getMoodString();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETWEAPONID__:
		{
			
			unsigned long long _m_res = getWeaponID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETWEAPON__:
		{
			
			DistributedObject* _m_res = getWeapon();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETGUILDOBJECT__:
		{
			
			DistributedObject* _m_res = getGuildObject().get();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETGUILDID__:
		{
			
			int _m_res = getGuildID();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISINGUILD__:
		{
			
			bool _m_res = isInGuild();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETGUILDOBJECT__GUILDOBJECT_:
		{
			GuildObject* guildobj = static_cast<GuildObject*>(inv->getObjectParameter());
			
			setGuildObject(guildobj);
			
		}
		break;
	case RPC_GETGROUPID__:
		{
			
			unsigned long long _m_res = getGroupID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETGROUPINVITERID__:
		{
			
			unsigned long long _m_res = getGroupInviterID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETGROUP__:
		{
			
			DistributedObject* _m_res = getGroup();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETGROUPINVITECOUNTER__:
		{
			
			unsigned long long _m_res = getGroupInviteCounter();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETTARGETID__:
		{
			
			unsigned long long _m_res = getTargetID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETMOODID__:
		{
			
			byte _m_res = getMoodID();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_GETSLOPEMODPERCENT__:
		{
			
			float _m_res = getSlopeModPercent();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETPERFORMANCECOUNTER__:
		{
			
			int _m_res = getPerformanceCounter();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETINSTRUMENTID__:
		{
			
			int _m_res = getInstrumentID();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFROZEN__:
		{
			
			byte _m_res = getFrozen();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_GETHEIGHT__:
		{
			
			float _m_res = getHeight();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_ISDROIDSPECIES__:
		{
			
			bool _m_res = isDroidSpecies();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISWALKERSPECIES__:
		{
			
			bool _m_res = isWalkerSpecies();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPROBOTSPECIES__:
		{
			
			bool _m_res = isProbotSpecies();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASEFFECTIMMUNITY__BYTE_:
		{
			byte effectType = inv->getByteParameter();
			
			bool _m_res = hasEffectImmunity(effectType);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASDOTIMMUNITY__INT_:
		{
			unsigned int dotType = inv->getUnsignedIntParameter();
			
			bool _m_res = hasDotImmunity(dotType);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSPECIES__:
		{
			
			int _m_res = getSpecies();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSPECIESNAME__:
		{
			
			String _m_res = getSpeciesName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETGENDER__:
		{
			
			int _m_res = getGender();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSKILLMOD__STRING_:
		{
			 String skillmod; inv->getAsciiParameter(skillmod);
			
			int _m_res = getSkillMod(skillmod);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSKILLMODOFTYPE__STRING_INT_:
		{
			 String skillmod; inv->getAsciiParameter(skillmod);
			unsigned const int modType = inv->getUnsignedIntParameter();
			
			int _m_res = getSkillModOfType(skillmod, modType);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASSKILL__STRING_:
		{
			 String skill; inv->getAsciiParameter(skill);
			
			bool _m_res = hasSkill(skill);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETWATCHTOID__LONG_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			
			setWatchToID(id);
			
		}
		break;
	case RPC_ISCREATUREOBJECT__:
		{
			
			bool _m_res = isCreatureObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNEXTACTIONPAST__:
		{
			
			bool _m_res = isNextActionPast();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSWIMMING__:
		{
			
			bool _m_res = isSwimming();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETCLIENT__:
		{
			
			DistributedObject* _m_res = getClient();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETCONTROLDEVICE__:
		{
			
			DistributedObject* _m_res = getControlDevice().get();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETSWIMHEIGHT__:
		{
			
			float _m_res = getSwimHeight();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_ISINCAPACITATED__:
		{
			
			bool _m_res = isIncapacitated();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISDEAD__:
		{
			
			bool _m_res = isDead();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISKNOCKEDDOWN__:
		{
			
			bool _m_res = isKnockedDown();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISKNEELING__:
		{
			
			bool _m_res = isKneeling();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPRONE__:
		{
			
			bool _m_res = isProne();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSTANDING__:
		{
			
			bool _m_res = isStanding();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSITTING__:
		{
			
			bool _m_res = isSitting();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSKILLANIMATING__:
		{
			
			bool _m_res = isSkillAnimating();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISRALLIED__:
		{
			
			bool _m_res = isRallied();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISINCOMBAT__:
		{
			
			bool _m_res = isInCombat();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISDIZZIED__:
		{
			
			bool _m_res = isDizzied();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISBERSERKED__:
		{
			
			bool _m_res = isBerserked();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSTUNNED__:
		{
			
			bool _m_res = isStunned();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISBLINDED__:
		{
			
			bool _m_res = isBlinded();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISINTIMIDATED__:
		{
			
			bool _m_res = isIntimidated();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSNARED__:
		{
			
			bool _m_res = isSnared();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISIMMOBILIZED__:
		{
			
			bool _m_res = isImmobilized();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISROOTED__:
		{
			
			bool _m_res = isRooted();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISFROZEN__:
		{
			
			bool _m_res = isFrozen();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISDISEASED__:
		{
			
			bool _m_res = isDiseased();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPOISONED__:
		{
			
			bool _m_res = isPoisoned();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISBLEEDING__:
		{
			
			bool _m_res = isBleeding();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISONFIRE__:
		{
			
			bool _m_res = isOnFire();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISFEIGNINGDEATH__:
		{
			
			bool _m_res = isFeigningDeath();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISRIDINGMOUNT__:
		{
			
			bool _m_res = isRidingMount();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASRIDINGCREATURE__:
		{
			
			bool _m_res = hasRidingCreature();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPEACED__:
		{
			
			bool _m_res = isPeaced();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISMEDITATING__:
		{
			
			bool _m_res = isMeditating();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISAIMING__:
		{
			
			bool _m_res = isAiming();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISINCOVER__:
		{
			
			bool _m_res = isInCover();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISRUNNING__:
		{
			
			bool _m_res = isRunning();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNONPLAYERCREATUREOBJECT__:
		{
			
			bool _m_res = isNonPlayerCreatureObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISDROIDOBJECT__:
		{
			
			bool _m_res = isDroidObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPLAYERCREATURE__:
		{
			
			bool _m_res = isPlayerCreature();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_REGISTERTOCLOSEOBJECTSRECEIVERS__:
		{
			
			int _m_res = registerToCloseObjectsReceivers();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISINFORMANTCREATURE__:
		{
			
			bool _m_res = isInformantCreature();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETCURRENTCAMP__:
		{
			
			DistributedObject* _m_res = getCurrentCamp();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETCURRENTWEATHER__:
		{
			
			byte _m_res = getCurrentWeather();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_SETCURRENTWEATHER__BYTE_:
		{
			byte value = inv->getByteParameter();
			
			setCurrentWeather(value);
			
		}
		break;
	case RPC_GETCURRENTWIND__:
		{
			
			byte _m_res = getCurrentWind();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_SETCURRENTWIND__BYTE_:
		{
			byte value = inv->getByteParameter();
			
			setCurrentWind(value);
			
		}
		break;
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			byte selectedID = inv->getByteParameter();
			
			int _m_res = handleObjectMenuSelect(player, selectedID);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETALTERNATEAPPEARANCE__:
		{
			
			String _m_res = getAlternateAppearance();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_CALCULATECOSTADJUSTMENT__BYTE_FLOAT_:
		{
			byte stat = inv->getByteParameter();
			float baseCost = inv->getFloatParameter();
			
			float _m_res = calculateCostAdjustment(stat, baseCost);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_UPDATESPEEDANDACCELERATIONMODS__:
		{
			
			updateSpeedAndAccelerationMods();
			
		}
		break;
	case RPC_SETFACTION__INT_:
		{
			unsigned int crc = inv->getUnsignedIntParameter();
			
			setFaction(crc);
			
		}
		break;
	case RPC_DESTROYPLAYERCREATUREFROMDATABASE__BOOL_:
		{
			bool destroyContainedObjects = inv->getBooleanParameter();
			
			destroyPlayerCreatureFromDatabase(destroyContainedObjects);
			
		}
		break;
	case RPC_GETTEMPLATERADIUS__:
		{
			
			float _m_res = getTemplateRadius();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_RELOADTEMPLATE__:
		{
			
			reloadTemplate();
			
		}
		break;
	default:
		TangibleObjectAdapter::invokeMethod(methid, inv);
	}
}

void CreatureObjectAdapter::initializeMembers() {
	(static_cast<CreatureObject*>(stub))->initializeMembers();
}

void CreatureObjectAdapter::finalize() {
	(static_cast<CreatureObject*>(stub))->finalize();
}

void CreatureObjectAdapter::createChildObjects() {
	(static_cast<CreatureObject*>(stub))->createChildObjects();
}

void CreatureObjectAdapter::initializeTransientMembers() {
	(static_cast<CreatureObject*>(stub))->initializeTransientMembers();
}

void CreatureObjectAdapter::setCountdownTimer(unsigned int newCount, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setCountdownTimer(newCount, notifyClient);
}

void CreatureObjectAdapter::clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2) {
	(static_cast<CreatureObject*>(stub))->clearQueueAction(actioncntr, timer, tab1, tab2);
}

void CreatureObjectAdapter::clearQueueActions(bool combatOnly) {
	(static_cast<CreatureObject*>(stub))->clearQueueActions(combatOnly);
}

void CreatureObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<CreatureObject*>(stub))->sendBaselinesTo(player);
}

void CreatureObjectAdapter::sendToOwner(bool doClose) {
	(static_cast<CreatureObject*>(stub))->sendToOwner(doClose);
}

void CreatureObjectAdapter::sendSystemMessage(const String& message) {
	(static_cast<CreatureObject*>(stub))->sendSystemMessage(message);
}

void CreatureObjectAdapter::playMusicMessage(const String& file) {
	(static_cast<CreatureObject*>(stub))->playMusicMessage(file);
}

void CreatureObjectAdapter::sendNewbieTutorialRequest(const String& request) {
	(static_cast<CreatureObject*>(stub))->sendNewbieTutorialRequest(request);
}

void CreatureObjectAdapter::sendNewbieTutorialEnableHudElement(const String& ui, bool enable, float blinkCount) {
	(static_cast<CreatureObject*>(stub))->sendNewbieTutorialEnableHudElement(ui, enable, blinkCount);
}

void CreatureObjectAdapter::sendOpenHolocronToPageMessage() {
	(static_cast<CreatureObject*>(stub))->sendOpenHolocronToPageMessage();
}

void CreatureObjectAdapter::sendSystemMessage(UnicodeString& message) {
	(static_cast<CreatureObject*>(stub))->sendSystemMessage(message);
}

void CreatureObjectAdapter::sendSlottedObjectsTo(SceneObject* player) {
	(static_cast<CreatureObject*>(stub))->sendSlottedObjectsTo(player);
}

void CreatureObjectAdapter::setCombatState() {
	(static_cast<CreatureObject*>(stub))->setCombatState();
}

void CreatureObjectAdapter::clearCombatState(bool clearDefenders) {
	(static_cast<CreatureObject*>(stub))->clearCombatState(clearDefenders);
}

void CreatureObjectAdapter::addMountedCombatSlow() {
	(static_cast<CreatureObject*>(stub))->addMountedCombatSlow();
}

void CreatureObjectAdapter::removeMountedCombatSlow(bool showEndMessage) {
	(static_cast<CreatureObject*>(stub))->removeMountedCombatSlow(showEndMessage);
}

void CreatureObjectAdapter::setPosture(int newPosture, bool immediate, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setPosture(newPosture, immediate, notifyClient);
}

void CreatureObjectAdapter::updatePostures(bool immediate) {
	(static_cast<CreatureObject*>(stub))->updatePostures(immediate);
}

float CreatureObjectAdapter::calculateSpeed() {
	return (static_cast<CreatureObject*>(stub))->calculateSpeed();
}

void CreatureObjectAdapter::updateLocomotion() {
	(static_cast<CreatureObject*>(stub))->updateLocomotion();
}

void CreatureObjectAdapter::setHeight(float heigh, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setHeight(heigh, notifyClient);
}

void CreatureObjectAdapter::setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setAccelerationMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObjectAdapter::setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setAccelerationMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObjectAdapter::setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setSpeedMultiplierBase(newMultiplierBase, notifyClient);
}

void CreatureObjectAdapter::setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setSpeedMultiplierMod(newMultiplierMod, notifyClient);
}

void CreatureObjectAdapter::setTurnScale(float newMultiplierMod, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setTurnScale(newMultiplierMod, notifyClient);
}

void CreatureObjectAdapter::setRunSpeed(float newSpeed, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setRunSpeed(newSpeed, notifyClient);
}

void CreatureObjectAdapter::setCurrentSpeed(float newSpeed) {
	(static_cast<CreatureObject*>(stub))->setCurrentSpeed(newSpeed);
}

void CreatureObjectAdapter::setHAM(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setHAM(type, value, notifyClient);
}

int CreatureObjectAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction) {
	return (static_cast<CreatureObject*>(stub))->inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
}

int CreatureObjectAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction) {
	return (static_cast<CreatureObject*>(stub))->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
}

bool CreatureObjectAdapter::hasDamage(int attribute) {
	return (static_cast<CreatureObject*>(stub))->hasDamage(attribute);
}

int CreatureObjectAdapter::healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers) {
	return (static_cast<CreatureObject*>(stub))->healDamage(healer, damageType, damage, notifyClient, notifyObservers);
}

int CreatureObjectAdapter::healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers) {
	return (static_cast<CreatureObject*>(stub))->healWound(healer, damageType, damage, notifyClient, notifyObservers);
}

void CreatureObjectAdapter::setBaseHAM(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setBaseHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::setWounds(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setWounds(type, value, notifyClient);
}

int CreatureObjectAdapter::addWounds(int type, int value, bool notifyClient, bool doShockWounds) {
	return (static_cast<CreatureObject*>(stub))->addWounds(type, value, notifyClient, doShockWounds);
}

void CreatureObjectAdapter::setMaxHAM(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setMaxHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::addMaxHAM(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addMaxHAM(type, value, notifyClient);
}

void CreatureObjectAdapter::setEncumbrance(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setEncumbrance(type, value, notifyClient);
}

void CreatureObjectAdapter::addEncumbrance(int type, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addEncumbrance(type, value, notifyClient);
}

void CreatureObjectAdapter::setWeapon(WeaponObject* weao, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setWeapon(weao, notifyClient);
}

int CreatureObjectAdapter::notifyObjectInserted(SceneObject* object) {
	return (static_cast<CreatureObject*>(stub))->notifyObjectInserted(object);
}

int CreatureObjectAdapter::notifyObjectRemoved(SceneObject* object) {
	return (static_cast<CreatureObject*>(stub))->notifyObjectRemoved(object);
}

void CreatureObjectAdapter::setInstrumentID(int instrumentid, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setInstrumentID(instrumentid, notifyClient);
}

void CreatureObjectAdapter::setListenToID(unsigned long long id, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setListenToID(id, notifyClient);
}

void CreatureObjectAdapter::setPerformanceCounter(int counter, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setPerformanceCounter(counter, notifyClient);
}

void CreatureObjectAdapter::setPerformanceAnimation(const String& animation, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setPerformanceAnimation(animation, notifyClient);
}

void CreatureObjectAdapter::setShockWounds(int newShock, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setShockWounds(newShock, notifyClient);
}

void CreatureObjectAdapter::addShockWounds(int shockToAdd, bool notiyClient, bool sendSpam) {
	(static_cast<CreatureObject*>(stub))->addShockWounds(shockToAdd, notiyClient, sendSpam);
}

void CreatureObjectAdapter::setTargetID(unsigned long long targetID, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setTargetID(targetID, notifyClient);
}

void CreatureObjectAdapter::setBankCredits(int credits, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setBankCredits(credits, notifyClient);
}

void CreatureObjectAdapter::addBuff(Buff* buff) {
	(static_cast<CreatureObject*>(stub))->addBuff(buff);
}

bool CreatureObjectAdapter::removeBuff(unsigned int buffcrc) {
	return (static_cast<CreatureObject*>(stub))->removeBuff(buffcrc);
}

void CreatureObjectAdapter::removeBuff(Buff* buff) {
	(static_cast<CreatureObject*>(stub))->removeBuff(buff);
}

bool CreatureObjectAdapter::removeStateBuff(unsigned long long state) {
	return (static_cast<CreatureObject*>(stub))->removeStateBuff(state);
}

void CreatureObjectAdapter::clearBuffs(bool updateclient, bool removeAll) {
	(static_cast<CreatureObject*>(stub))->clearBuffs(updateclient, removeAll);
}

void CreatureObjectAdapter::renewBuff(unsigned int buffCRC, int duration, bool sendToClient) {
	(static_cast<CreatureObject*>(stub))->renewBuff(buffCRC, duration, sendToClient);
}

void CreatureObjectAdapter::updateVehiclePosition(bool sendPackets) {
	(static_cast<CreatureObject*>(stub))->updateVehiclePosition(sendPackets);
}

void CreatureObjectAdapter::addWearableObject(TangibleObject* object, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addWearableObject(object, notifyClient);
}

void CreatureObjectAdapter::removeWearableObject(TangibleObject* object, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->removeWearableObject(object, notifyClient);
}

void CreatureObjectAdapter::sendBuffsTo(CreatureObject* creature) {
	(static_cast<CreatureObject*>(stub))->sendBuffsTo(creature);
}

Buff* CreatureObjectAdapter::getBuff(unsigned int buffcrc) {
	return (static_cast<CreatureObject*>(stub))->getBuff(buffcrc);
}

long long CreatureObjectAdapter::getSkillModFromBuffs(const String& skillMod) {
	return (static_cast<CreatureObject*>(stub))->getSkillModFromBuffs(skillMod);
}

int CreatureObjectAdapter::addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength) {
	return (static_cast<CreatureObject*>(stub))->addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
}

bool CreatureObjectAdapter::healDot(unsigned long long dotType, int reduction, bool sendMsg) {
	return (static_cast<CreatureObject*>(stub))->healDot(dotType, reduction, sendMsg);
}

void CreatureObjectAdapter::clearDots() {
	(static_cast<CreatureObject*>(stub))->clearDots();
}

bool CreatureObjectAdapter::hasBuff(unsigned int buffcrc) {
	return (static_cast<CreatureObject*>(stub))->hasBuff(buffcrc);
}

void CreatureObjectAdapter::notifySelfPositionUpdate() {
	(static_cast<CreatureObject*>(stub))->notifySelfPositionUpdate();
}

void CreatureObjectAdapter::notifyPostureChange(int newPosture) {
	(static_cast<CreatureObject*>(stub))->notifyPostureChange(newPosture);
}

void CreatureObjectAdapter::setLevel(int level, bool randomHam) {
	(static_cast<CreatureObject*>(stub))->setLevel(level, randomHam);
}

void CreatureObjectAdapter::updateToDatabaseAllObjects(bool startTask) {
	(static_cast<CreatureObject*>(stub))->updateToDatabaseAllObjects(startTask);
}

bool CreatureObjectAdapter::isResuscitable() {
	return (static_cast<CreatureObject*>(stub))->isResuscitable();
}

void CreatureObjectAdapter::addBankCredits(int credits, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addBankCredits(credits, notifyClient);
}

void CreatureObjectAdapter::addCashCredits(int credits, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addCashCredits(credits, notifyClient);
}

CreditObject* CreatureObjectAdapter::getCreditObject() {
	return (static_cast<CreatureObject*>(stub))->getCreditObject();
}

void CreatureObjectAdapter::subtractBankCredits(int credits) {
	(static_cast<CreatureObject*>(stub))->subtractBankCredits(credits);
}

void CreatureObjectAdapter::subtractCashCredits(int credits) {
	(static_cast<CreatureObject*>(stub))->subtractCashCredits(credits);
}

bool CreatureObjectAdapter::verifyCashCredits(int credits) {
	return (static_cast<CreatureObject*>(stub))->verifyCashCredits(credits);
}

bool CreatureObjectAdapter::verifyBankCredits(int credits) {
	return (static_cast<CreatureObject*>(stub))->verifyBankCredits(credits);
}

bool CreatureObjectAdapter::isDancing() {
	return (static_cast<CreatureObject*>(stub))->isDancing();
}

bool CreatureObjectAdapter::isPlayingMusic() {
	return (static_cast<CreatureObject*>(stub))->isPlayingMusic();
}

void CreatureObjectAdapter::stopEntertaining() {
	(static_cast<CreatureObject*>(stub))->stopEntertaining();
}

bool CreatureObjectAdapter::isEntertaining() {
	return (static_cast<CreatureObject*>(stub))->isEntertaining();
}

void CreatureObjectAdapter::setCashCredits(int credits, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setCashCredits(credits, notifyClient);
}

void CreatureObjectAdapter::setTerrainNegotiation(float value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setTerrainNegotiation(value, notifyClient);
}

void CreatureObjectAdapter::updateTerrainNegotiation() {
	(static_cast<CreatureObject*>(stub))->updateTerrainNegotiation();
}

void CreatureObjectAdapter::addSkill(const String& skill, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addSkill(skill, notifyClient);
}

void CreatureObjectAdapter::removeSkill(const String& skill, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->removeSkill(skill, notifyClient);
}

void CreatureObjectAdapter::addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->addSkillMod(modType, skillMod, value, notifyClient);
}

void CreatureObjectAdapter::removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->removeSkillMod(modType, skillMod, value, notifyClient);
}

void CreatureObjectAdapter::removeAllSkillModsOfType(const int modType, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->removeAllSkillModsOfType(modType, notifyClient);
}

void CreatureObjectAdapter::updateGroupInviterID(unsigned long long id, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->updateGroupInviterID(id, notifyClient);
}

void CreatureObjectAdapter::updateGroup(GroupObject* group, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->updateGroup(group, notifyClient);
}

void CreatureObjectAdapter::enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority, int compareCount) {
	(static_cast<CreatureObject*>(stub))->enqueueCommand(actionCRC, actionCount, targetID, arguments, priority, compareCount);
}

void CreatureObjectAdapter::sendCommand(unsigned int crc, const UnicodeString& args, unsigned long long targetID, int priority) {
	(static_cast<CreatureObject*>(stub))->sendCommand(crc, args, targetID, priority);
}

void CreatureObjectAdapter::sendCommand(const String& action, const UnicodeString& args, unsigned long long targetID, int priority) {
	(static_cast<CreatureObject*>(stub))->sendCommand(action, args, targetID, priority);
}

void CreatureObjectAdapter::setMood(byte moodID, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setMood(moodID, notifyClient);
}

void CreatureObjectAdapter::setMoodString(const String& animation, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setMoodString(animation, notifyClient);
}

void CreatureObjectAdapter::deleteQueueAction(unsigned int actionCount) {
	(static_cast<CreatureObject*>(stub))->deleteQueueAction(actionCount);
}

bool CreatureObjectAdapter::setState(unsigned long long state, bool notifyClient) {
	return (static_cast<CreatureObject*>(stub))->setState(state, notifyClient);
}

void CreatureObjectAdapter::setAlternateAppearance(const String& appearanceTeamplate, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setAlternateAppearance(appearanceTeamplate, notifyClient);
}

bool CreatureObjectAdapter::clearState(unsigned long long state, bool notifyClient) {
	return (static_cast<CreatureObject*>(stub))->clearState(state, notifyClient);
}

void CreatureObjectAdapter::setControlDevice(ControlDevice* device) {
	(static_cast<CreatureObject*>(stub))->setControlDevice(device);
}

void CreatureObjectAdapter::setCreatureLink(CreatureObject* object, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setCreatureLink(object, notifyClient);
}

void CreatureObjectAdapter::executeObjectControllerAction(unsigned int actionCRC) {
	(static_cast<CreatureObject*>(stub))->executeObjectControllerAction(actionCRC);
}

void CreatureObjectAdapter::executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args) {
	(static_cast<CreatureObject*>(stub))->executeObjectControllerAction(actionCRC, targetID, args);
}

bool CreatureObjectAdapter::isAttackableBy(CreatureObject* object) {
	return (static_cast<CreatureObject*>(stub))->isAttackableBy(object);
}

bool CreatureObjectAdapter::isAttackableBy(CreatureObject* object, bool bypassDeadCheck) {
	return (static_cast<CreatureObject*>(stub))->isAttackableBy(object, bypassDeadCheck);
}

bool CreatureObjectAdapter::isAttackableBy(TangibleObject* attacker) {
	return (static_cast<CreatureObject*>(stub))->isAttackableBy(attacker);
}

bool CreatureObjectAdapter::isAttackableBy(TangibleObject* object, bool bypassDeadCheck) {
	return (static_cast<CreatureObject*>(stub))->isAttackableBy(object, bypassDeadCheck);
}

bool CreatureObjectAdapter::isHealableBy(CreatureObject* object) {
	return (static_cast<CreatureObject*>(stub))->isHealableBy(object);
}

bool CreatureObjectAdapter::hasBountyMissionFor(CreatureObject* target) {
	return (static_cast<CreatureObject*>(stub))->hasBountyMissionFor(target);
}

bool CreatureObjectAdapter::sendConversationStartTo(SceneObject* player) {
	return (static_cast<CreatureObject*>(stub))->sendConversationStartTo(player);
}

void CreatureObjectAdapter::selectConversationOption(int option, SceneObject* obj) {
	(static_cast<CreatureObject*>(stub))->selectConversationOption(option, obj);
}

void CreatureObjectAdapter::sendMessage(BasePacket* msg) {
	(static_cast<CreatureObject*>(stub))->sendMessage(msg);
}

void CreatureObjectAdapter::sendStateCombatSpam(const String& fileName, const String& stringName, byte color, int damage, bool broadcast) {
	(static_cast<CreatureObject*>(stub))->sendStateCombatSpam(fileName, stringName, color, damage, broadcast);
}

void CreatureObjectAdapter::sendCustomCombatSpam(const UnicodeString& customString, byte color) {
	(static_cast<CreatureObject*>(stub))->sendCustomCombatSpam(customString, color);
}

void CreatureObjectAdapter::sendExecuteConsoleCommand(const String& command) {
	(static_cast<CreatureObject*>(stub))->sendExecuteConsoleCommand(command);
}

bool CreatureObjectAdapter::isAggressiveTo(CreatureObject* object) {
	return (static_cast<CreatureObject*>(stub))->isAggressiveTo(object);
}

int CreatureObjectAdapter::notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction) {
	return (static_cast<CreatureObject*>(stub))->notifyObjectDestructionObservers(attacker, condition, isCombatAction);
}

int CreatureObjectAdapter::notifyObjectKillObservers(TangibleObject* killer) {
	return (static_cast<CreatureObject*>(stub))->notifyObjectKillObservers(killer);
}

void CreatureObjectAdapter::notifyLoadFromDatabase() {
	(static_cast<CreatureObject*>(stub))->notifyLoadFromDatabase();
}

void CreatureObjectAdapter::destroyObjectFromDatabase(bool destroyContainedObjects) {
	(static_cast<CreatureObject*>(stub))->destroyObjectFromDatabase(destroyContainedObjects);
}

void CreatureObjectAdapter::setFactionRank(int rank, bool notifyClient) {
	(static_cast<CreatureObject*>(stub))->setFactionRank(rank, notifyClient);
}

String CreatureObjectAdapter::getFirstName() {
	return (static_cast<CreatureObject*>(stub))->getFirstName();
}

String CreatureObjectAdapter::getLastName() {
	return (static_cast<CreatureObject*>(stub))->getLastName();
}

bool CreatureObjectAdapter::isOnline() {
	return (static_cast<CreatureObject*>(stub))->isOnline();
}

bool CreatureObjectAdapter::canTreatInjuries() {
	return (static_cast<CreatureObject*>(stub))->canTreatInjuries();
}

bool CreatureObjectAdapter::canTreatStates() {
	return (static_cast<CreatureObject*>(stub))->canTreatStates();
}

bool CreatureObjectAdapter::canTreatWounds() {
	return (static_cast<CreatureObject*>(stub))->canTreatWounds();
}

bool CreatureObjectAdapter::canTreatConditions() {
	return (static_cast<CreatureObject*>(stub))->canTreatConditions();
}

Reference<PlayerObject* > CreatureObjectAdapter::getPlayerObject() {
	return (static_cast<CreatureObject*>(stub))->getPlayerObject();
}

bool CreatureObjectAdapter::isListening() const {
	return (static_cast<CreatureObject*>(stub))->isListening();
}

bool CreatureObjectAdapter::isWatching() const {
	return (static_cast<CreatureObject*>(stub))->isWatching();
}

void CreatureObjectAdapter::setClient(ZoneClientSession* cli) {
	(static_cast<CreatureObject*>(stub))->setClient(cli);
}

void CreatureObjectAdapter::dismount() {
	(static_cast<CreatureObject*>(stub))->dismount();
}

float CreatureObjectAdapter::calculateBFRatio() {
	return (static_cast<CreatureObject*>(stub))->calculateBFRatio();
}

void CreatureObjectAdapter::removeFeignedDeath() {
	(static_cast<CreatureObject*>(stub))->removeFeignedDeath();
}

bool CreatureObjectAdapter::canFeignDeath() {
	return (static_cast<CreatureObject*>(stub))->canFeignDeath();
}

void CreatureObjectAdapter::feignDeath() {
	(static_cast<CreatureObject*>(stub))->feignDeath();
}

void CreatureObjectAdapter::setFeignedDeathState() {
	(static_cast<CreatureObject*>(stub))->setFeignedDeathState();
}

void CreatureObjectAdapter::setDizziedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setDizziedState(durationSeconds);
}

void CreatureObjectAdapter::setRalliedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setRalliedState(durationSeconds);
}

void CreatureObjectAdapter::setAimingState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setAimingState(durationSeconds);
}

void CreatureObjectAdapter::setCoverState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setCoverState(durationSeconds);
}

void CreatureObjectAdapter::setBerserkedState(unsigned int duration) {
	(static_cast<CreatureObject*>(stub))->setBerserkedState(duration);
}

void CreatureObjectAdapter::setStunnedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setStunnedState(durationSeconds);
}

void CreatureObjectAdapter::setBlindedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setBlindedState(durationSeconds);
}

void CreatureObjectAdapter::setIntimidatedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setIntimidatedState(durationSeconds);
}

void CreatureObjectAdapter::setSnaredState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setSnaredState(durationSeconds);
}

void CreatureObjectAdapter::setRootedState(int durationSeconds) {
	(static_cast<CreatureObject*>(stub))->setRootedState(durationSeconds);
}

bool CreatureObjectAdapter::setNextAttackDelay(unsigned int mod, int del) {
	return (static_cast<CreatureObject*>(stub))->setNextAttackDelay(mod, del);
}

void CreatureObjectAdapter::setMeditateState() {
	(static_cast<CreatureObject*>(stub))->setMeditateState();
}

void CreatureObjectAdapter::activateHAMRegeneration(int latency) {
	(static_cast<CreatureObject*>(stub))->activateHAMRegeneration(latency);
}

void CreatureObjectAdapter::activatePassiveWoundRegeneration() {
	(static_cast<CreatureObject*>(stub))->activatePassiveWoundRegeneration();
}

void CreatureObjectAdapter::activateStateRecovery() {
	(static_cast<CreatureObject*>(stub))->activateStateRecovery();
}

void CreatureObjectAdapter::updateTimeOfDeath() {
	(static_cast<CreatureObject*>(stub))->updateTimeOfDeath();
}

bool CreatureObjectAdapter::hasAttackDelay() {
	return (static_cast<CreatureObject*>(stub))->hasAttackDelay();
}

void CreatureObjectAdapter::removeAttackDelay() {
	(static_cast<CreatureObject*>(stub))->removeAttackDelay();
}

bool CreatureObjectAdapter::hasIncapTimer() {
	return (static_cast<CreatureObject*>(stub))->hasIncapTimer();
}

bool CreatureObjectAdapter::hasSpice() {
	return (static_cast<CreatureObject*>(stub))->hasSpice();
}

void CreatureObjectAdapter::updateLastSuccessfulCombatAction() {
	(static_cast<CreatureObject*>(stub))->updateLastSuccessfulCombatAction();
}

void CreatureObjectAdapter::updatePostureChangeDelay(unsigned long long delay) {
	(static_cast<CreatureObject*>(stub))->updatePostureChangeDelay(delay);
}

bool CreatureObjectAdapter::checkPostureChangeDelay() {
	return (static_cast<CreatureObject*>(stub))->checkPostureChangeDelay();
}

void CreatureObjectAdapter::updatePostureDownRecovery() {
	(static_cast<CreatureObject*>(stub))->updatePostureDownRecovery();
}

bool CreatureObjectAdapter::checkPostureDownRecovery() {
	return (static_cast<CreatureObject*>(stub))->checkPostureDownRecovery();
}

void CreatureObjectAdapter::updatePostureUpRecovery() {
	(static_cast<CreatureObject*>(stub))->updatePostureUpRecovery();
}

bool CreatureObjectAdapter::checkPostureUpRecovery() {
	return (static_cast<CreatureObject*>(stub))->checkPostureUpRecovery();
}

void CreatureObjectAdapter::updateKnockdownRecovery() {
	(static_cast<CreatureObject*>(stub))->updateKnockdownRecovery();
}

bool CreatureObjectAdapter::checkKnockdownRecovery() {
	return (static_cast<CreatureObject*>(stub))->checkKnockdownRecovery();
}

void CreatureObjectAdapter::updateGroupMFDPositions() {
	(static_cast<CreatureObject*>(stub))->updateGroupMFDPositions();
}

void CreatureObjectAdapter::queueDizzyFallEvent() {
	(static_cast<CreatureObject*>(stub))->queueDizzyFallEvent();
}

bool CreatureObjectAdapter::hasDizzyEvent() {
	return (static_cast<CreatureObject*>(stub))->hasDizzyEvent();
}

void CreatureObjectAdapter::clearDizzyEvent() {
	(static_cast<CreatureObject*>(stub))->clearDizzyEvent();
}

unsigned long long CreatureObjectAdapter::getScreenPlayState(const String& screenPlay) {
	return (static_cast<CreatureObject*>(stub))->getScreenPlayState(screenPlay);
}

void CreatureObjectAdapter::setScreenPlayState(const String& screenPlay, unsigned long long state) {
	(static_cast<CreatureObject*>(stub))->setScreenPlayState(screenPlay, state);
}

void CreatureObjectAdapter::updateCooldownTimer(const String& coooldownTimer, unsigned long long miliSecondsToAdd) {
	(static_cast<CreatureObject*>(stub))->updateCooldownTimer(coooldownTimer, miliSecondsToAdd);
}

bool CreatureObjectAdapter::checkCooldownRecovery(const String& cooldown) {
	return (static_cast<CreatureObject*>(stub))->checkCooldownRecovery(cooldown);
}

void CreatureObjectAdapter::addCooldown(const String& name, unsigned long long miliseconds) {
	(static_cast<CreatureObject*>(stub))->addCooldown(name, miliseconds);
}

void CreatureObjectAdapter::doAnimation(const String& animation) {
	(static_cast<CreatureObject*>(stub))->doAnimation(animation);
}

void CreatureObjectAdapter::doCombatAnimation(TangibleObject* defender, unsigned int animationCRC, byte hit, byte trails, unsigned long long weaponID) {
	(static_cast<CreatureObject*>(stub))->doCombatAnimation(defender, animationCRC, hit, trails, weaponID);
}

void CreatureObjectAdapter::doCombatAnimation(unsigned int animationCRC) {
	(static_cast<CreatureObject*>(stub))->doCombatAnimation(animationCRC);
}

void CreatureObjectAdapter::activateQueueAction() {
	(static_cast<CreatureObject*>(stub))->activateQueueAction();
}

void CreatureObjectAdapter::activateImmediateAction() {
	(static_cast<CreatureObject*>(stub))->activateImmediateAction();
}

UnicodeString CreatureObjectAdapter::getCreatureName() {
	return (static_cast<CreatureObject*>(stub))->getCreatureName();
}

bool CreatureObjectAdapter::isGrouped() const {
	return (static_cast<CreatureObject*>(stub))->isGrouped();
}

int CreatureObjectAdapter::getBankCredits() const {
	return (static_cast<CreatureObject*>(stub))->getBankCredits();
}

int CreatureObjectAdapter::getCashCredits() const {
	return (static_cast<CreatureObject*>(stub))->getCashCredits();
}

int CreatureObjectAdapter::getBaseHAM(int idx) {
	return (static_cast<CreatureObject*>(stub))->getBaseHAM(idx);
}

int CreatureObjectAdapter::getWounds(int idx) {
	return (static_cast<CreatureObject*>(stub))->getWounds(idx);
}

int CreatureObjectAdapter::getHAM(int idx) {
	return (static_cast<CreatureObject*>(stub))->getHAM(idx);
}

int CreatureObjectAdapter::getMaxHAM(int idx) {
	return (static_cast<CreatureObject*>(stub))->getMaxHAM(idx);
}

int CreatureObjectAdapter::getEncumbrance(int idx) {
	return (static_cast<CreatureObject*>(stub))->getEncumbrance(idx);
}

byte CreatureObjectAdapter::getPosture() const {
	return (static_cast<CreatureObject*>(stub))->getPosture();
}

byte CreatureObjectAdapter::getLocomotion() const {
	return (static_cast<CreatureObject*>(stub))->getLocomotion();
}

byte CreatureObjectAdapter::getFactionRank() const {
	return (static_cast<CreatureObject*>(stub))->getFactionRank();
}

ManagedWeakReference<CreatureObject* > CreatureObjectAdapter::getLinkedCreature() const {
	return (static_cast<CreatureObject*>(stub))->getLinkedCreature();
}

unsigned long long CreatureObjectAdapter::getCreatureLinkID() const {
	return (static_cast<CreatureObject*>(stub))->getCreatureLinkID();
}

float CreatureObjectAdapter::getShockWounds() const {
	return (static_cast<CreatureObject*>(stub))->getShockWounds();
}

unsigned long long CreatureObjectAdapter::getWatchToID() const {
	return (static_cast<CreatureObject*>(stub))->getWatchToID();
}

unsigned long long CreatureObjectAdapter::getStateBitmask() const {
	return (static_cast<CreatureObject*>(stub))->getStateBitmask();
}

bool CreatureObjectAdapter::hasState(unsigned long long state) const {
	return (static_cast<CreatureObject*>(stub))->hasState(state);
}

bool CreatureObjectAdapter::hasStates() const {
	return (static_cast<CreatureObject*>(stub))->hasStates();
}

unsigned long long CreatureObjectAdapter::getListenID() const {
	return (static_cast<CreatureObject*>(stub))->getListenID();
}

float CreatureObjectAdapter::getAccelerationMultiplierBase() const {
	return (static_cast<CreatureObject*>(stub))->getAccelerationMultiplierBase();
}

float CreatureObjectAdapter::getAccelerationMultiplierMod() const {
	return (static_cast<CreatureObject*>(stub))->getAccelerationMultiplierMod();
}

float CreatureObjectAdapter::getSpeedMultiplierBase() const {
	return (static_cast<CreatureObject*>(stub))->getSpeedMultiplierBase();
}

float CreatureObjectAdapter::getSpeedMultiplierMod() const {
	return (static_cast<CreatureObject*>(stub))->getSpeedMultiplierMod();
}

float CreatureObjectAdapter::getCurrentSpeed() const {
	return (static_cast<CreatureObject*>(stub))->getCurrentSpeed();
}

int CreatureObjectAdapter::getCommandQueueSize() const {
	return (static_cast<CreatureObject*>(stub))->getCommandQueueSize();
}

void CreatureObjectAdapter::setLastActionCounter(unsigned int ctr) {
	(static_cast<CreatureObject*>(stub))->setLastActionCounter(ctr);
}

unsigned int CreatureObjectAdapter::incrementLastActionCounter() {
	return (static_cast<CreatureObject*>(stub))->incrementLastActionCounter();
}

unsigned int CreatureObjectAdapter::getLastActionCounter() {
	return (static_cast<CreatureObject*>(stub))->getLastActionCounter();
}

float CreatureObjectAdapter::getRunSpeed() const {
	return (static_cast<CreatureObject*>(stub))->getRunSpeed();
}

float CreatureObjectAdapter::getWalkSpeed() const {
	return (static_cast<CreatureObject*>(stub))->getWalkSpeed();
}

float CreatureObjectAdapter::getTurnScale() const {
	return (static_cast<CreatureObject*>(stub))->getTurnScale();
}

float CreatureObjectAdapter::getTerrainNegotiation() {
	return (static_cast<CreatureObject*>(stub))->getTerrainNegotiation();
}

float CreatureObjectAdapter::getRunAcceleration() const {
	return (static_cast<CreatureObject*>(stub))->getRunAcceleration();
}

float CreatureObjectAdapter::getWalkAcceleration() const {
	return (static_cast<CreatureObject*>(stub))->getWalkAcceleration();
}

String CreatureObjectAdapter::getPerformanceAnimation() const {
	return (static_cast<CreatureObject*>(stub))->getPerformanceAnimation();
}

String CreatureObjectAdapter::getMoodString() const {
	return (static_cast<CreatureObject*>(stub))->getMoodString();
}

unsigned long long CreatureObjectAdapter::getWeaponID() const {
	return (static_cast<CreatureObject*>(stub))->getWeaponID();
}

Reference<WeaponObject* > CreatureObjectAdapter::getWeapon() {
	return (static_cast<CreatureObject*>(stub))->getWeapon();
}

ManagedWeakReference<GuildObject* > CreatureObjectAdapter::getGuildObject() const {
	return (static_cast<CreatureObject*>(stub))->getGuildObject();
}

int CreatureObjectAdapter::getGuildID() const {
	return (static_cast<CreatureObject*>(stub))->getGuildID();
}

bool CreatureObjectAdapter::isInGuild() const {
	return (static_cast<CreatureObject*>(stub))->isInGuild();
}

void CreatureObjectAdapter::setGuildObject(GuildObject* guildobj) {
	(static_cast<CreatureObject*>(stub))->setGuildObject(guildobj);
}

unsigned long long CreatureObjectAdapter::getGroupID() const {
	return (static_cast<CreatureObject*>(stub))->getGroupID();
}

unsigned long long CreatureObjectAdapter::getGroupInviterID() const {
	return (static_cast<CreatureObject*>(stub))->getGroupInviterID();
}

Reference<GroupObject* > CreatureObjectAdapter::getGroup() const {
	return (static_cast<CreatureObject*>(stub))->getGroup();
}

unsigned long long CreatureObjectAdapter::getGroupInviteCounter() const {
	return (static_cast<CreatureObject*>(stub))->getGroupInviteCounter();
}

unsigned long long CreatureObjectAdapter::getTargetID() const {
	return (static_cast<CreatureObject*>(stub))->getTargetID();
}

byte CreatureObjectAdapter::getMoodID() const {
	return (static_cast<CreatureObject*>(stub))->getMoodID();
}

float CreatureObjectAdapter::getSlopeModPercent() const {
	return (static_cast<CreatureObject*>(stub))->getSlopeModPercent();
}

int CreatureObjectAdapter::getPerformanceCounter() const {
	return (static_cast<CreatureObject*>(stub))->getPerformanceCounter();
}

int CreatureObjectAdapter::getInstrumentID() const {
	return (static_cast<CreatureObject*>(stub))->getInstrumentID();
}

byte CreatureObjectAdapter::getFrozen() const {
	return (static_cast<CreatureObject*>(stub))->getFrozen();
}

float CreatureObjectAdapter::getHeight() const {
	return (static_cast<CreatureObject*>(stub))->getHeight();
}

bool CreatureObjectAdapter::isDroidSpecies() {
	return (static_cast<CreatureObject*>(stub))->isDroidSpecies();
}

bool CreatureObjectAdapter::isWalkerSpecies() {
	return (static_cast<CreatureObject*>(stub))->isWalkerSpecies();
}

bool CreatureObjectAdapter::isProbotSpecies() {
	return (static_cast<CreatureObject*>(stub))->isProbotSpecies();
}

bool CreatureObjectAdapter::hasEffectImmunity(byte effectType) {
	return (static_cast<CreatureObject*>(stub))->hasEffectImmunity(effectType);
}

bool CreatureObjectAdapter::hasDotImmunity(unsigned int dotType) {
	return (static_cast<CreatureObject*>(stub))->hasDotImmunity(dotType);
}

int CreatureObjectAdapter::getSpecies() {
	return (static_cast<CreatureObject*>(stub))->getSpecies();
}

String CreatureObjectAdapter::getSpeciesName() {
	return (static_cast<CreatureObject*>(stub))->getSpeciesName();
}

int CreatureObjectAdapter::getGender() {
	return (static_cast<CreatureObject*>(stub))->getGender();
}

int CreatureObjectAdapter::getSkillMod(const String& skillmod) {
	return (static_cast<CreatureObject*>(stub))->getSkillMod(skillmod);
}

int CreatureObjectAdapter::getSkillModOfType(const String& skillmod, unsigned const int modType) {
	return (static_cast<CreatureObject*>(stub))->getSkillModOfType(skillmod, modType);
}

bool CreatureObjectAdapter::hasSkill(const String& skill) {
	return (static_cast<CreatureObject*>(stub))->hasSkill(skill);
}

void CreatureObjectAdapter::setWatchToID(unsigned long long id) {
	(static_cast<CreatureObject*>(stub))->setWatchToID(id);
}

bool CreatureObjectAdapter::isCreatureObject() {
	return (static_cast<CreatureObject*>(stub))->isCreatureObject();
}

bool CreatureObjectAdapter::isNextActionPast() {
	return (static_cast<CreatureObject*>(stub))->isNextActionPast();
}

bool CreatureObjectAdapter::isSwimming() const {
	return (static_cast<CreatureObject*>(stub))->isSwimming();
}

Reference<ZoneClientSession* > CreatureObjectAdapter::getClient() {
	return (static_cast<CreatureObject*>(stub))->getClient();
}

ManagedWeakReference<ControlDevice* > CreatureObjectAdapter::getControlDevice() const {
	return (static_cast<CreatureObject*>(stub))->getControlDevice();
}

float CreatureObjectAdapter::getSwimHeight() const {
	return (static_cast<CreatureObject*>(stub))->getSwimHeight();
}

bool CreatureObjectAdapter::isIncapacitated() const {
	return (static_cast<CreatureObject*>(stub))->isIncapacitated();
}

bool CreatureObjectAdapter::isDead() const {
	return (static_cast<CreatureObject*>(stub))->isDead();
}

bool CreatureObjectAdapter::isKnockedDown() const {
	return (static_cast<CreatureObject*>(stub))->isKnockedDown();
}

bool CreatureObjectAdapter::isKneeling() const {
	return (static_cast<CreatureObject*>(stub))->isKneeling();
}

bool CreatureObjectAdapter::isProne() const {
	return (static_cast<CreatureObject*>(stub))->isProne();
}

bool CreatureObjectAdapter::isStanding() const {
	return (static_cast<CreatureObject*>(stub))->isStanding();
}

bool CreatureObjectAdapter::isSitting() const {
	return (static_cast<CreatureObject*>(stub))->isSitting();
}

bool CreatureObjectAdapter::isSkillAnimating() const {
	return (static_cast<CreatureObject*>(stub))->isSkillAnimating();
}

bool CreatureObjectAdapter::isRallied() const {
	return (static_cast<CreatureObject*>(stub))->isRallied();
}

bool CreatureObjectAdapter::isInCombat() const {
	return (static_cast<CreatureObject*>(stub))->isInCombat();
}

bool CreatureObjectAdapter::isDizzied() const {
	return (static_cast<CreatureObject*>(stub))->isDizzied();
}

bool CreatureObjectAdapter::isBerserked() const {
	return (static_cast<CreatureObject*>(stub))->isBerserked();
}

bool CreatureObjectAdapter::isStunned() const {
	return (static_cast<CreatureObject*>(stub))->isStunned();
}

bool CreatureObjectAdapter::isBlinded() const {
	return (static_cast<CreatureObject*>(stub))->isBlinded();
}

bool CreatureObjectAdapter::isIntimidated() const {
	return (static_cast<CreatureObject*>(stub))->isIntimidated();
}

bool CreatureObjectAdapter::isSnared() const {
	return (static_cast<CreatureObject*>(stub))->isSnared();
}

bool CreatureObjectAdapter::isImmobilized() const {
	return (static_cast<CreatureObject*>(stub))->isImmobilized();
}

bool CreatureObjectAdapter::isRooted() const {
	return (static_cast<CreatureObject*>(stub))->isRooted();
}

bool CreatureObjectAdapter::isFrozen() const {
	return (static_cast<CreatureObject*>(stub))->isFrozen();
}

bool CreatureObjectAdapter::isDiseased() const {
	return (static_cast<CreatureObject*>(stub))->isDiseased();
}

bool CreatureObjectAdapter::isPoisoned() const {
	return (static_cast<CreatureObject*>(stub))->isPoisoned();
}

bool CreatureObjectAdapter::isBleeding() const {
	return (static_cast<CreatureObject*>(stub))->isBleeding();
}

bool CreatureObjectAdapter::isOnFire() const {
	return (static_cast<CreatureObject*>(stub))->isOnFire();
}

bool CreatureObjectAdapter::isFeigningDeath() const {
	return (static_cast<CreatureObject*>(stub))->isFeigningDeath();
}

bool CreatureObjectAdapter::isRidingMount() const {
	return (static_cast<CreatureObject*>(stub))->isRidingMount();
}

bool CreatureObjectAdapter::hasRidingCreature() const {
	return (static_cast<CreatureObject*>(stub))->hasRidingCreature();
}

bool CreatureObjectAdapter::isPeaced() const {
	return (static_cast<CreatureObject*>(stub))->isPeaced();
}

bool CreatureObjectAdapter::isMeditating() const {
	return (static_cast<CreatureObject*>(stub))->isMeditating();
}

bool CreatureObjectAdapter::isAiming() const {
	return (static_cast<CreatureObject*>(stub))->isAiming();
}

bool CreatureObjectAdapter::isInCover() const {
	return (static_cast<CreatureObject*>(stub))->isInCover();
}

bool CreatureObjectAdapter::isRunning() const {
	return (static_cast<CreatureObject*>(stub))->isRunning();
}

bool CreatureObjectAdapter::isNonPlayerCreatureObject() {
	return (static_cast<CreatureObject*>(stub))->isNonPlayerCreatureObject();
}

bool CreatureObjectAdapter::isDroidObject() {
	return (static_cast<CreatureObject*>(stub))->isDroidObject();
}

bool CreatureObjectAdapter::isPlayerCreature() {
	return (static_cast<CreatureObject*>(stub))->isPlayerCreature();
}

int CreatureObjectAdapter::registerToCloseObjectsReceivers() {
	return (static_cast<CreatureObject*>(stub))->registerToCloseObjectsReceivers();
}

bool CreatureObjectAdapter::isInformantCreature() {
	return (static_cast<CreatureObject*>(stub))->isInformantCreature();
}

CampSiteActiveArea* CreatureObjectAdapter::getCurrentCamp() {
	return (static_cast<CreatureObject*>(stub))->getCurrentCamp();
}

byte CreatureObjectAdapter::getCurrentWeather() const {
	return (static_cast<CreatureObject*>(stub))->getCurrentWeather();
}

void CreatureObjectAdapter::setCurrentWeather(byte value) {
	(static_cast<CreatureObject*>(stub))->setCurrentWeather(value);
}

byte CreatureObjectAdapter::getCurrentWind() const {
	return (static_cast<CreatureObject*>(stub))->getCurrentWind();
}

void CreatureObjectAdapter::setCurrentWind(byte value) {
	(static_cast<CreatureObject*>(stub))->setCurrentWind(value);
}

int CreatureObjectAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<CreatureObject*>(stub))->handleObjectMenuSelect(player, selectedID);
}

String CreatureObjectAdapter::getAlternateAppearance() {
	return (static_cast<CreatureObject*>(stub))->getAlternateAppearance();
}

float CreatureObjectAdapter::calculateCostAdjustment(byte stat, float baseCost) {
	return (static_cast<CreatureObject*>(stub))->calculateCostAdjustment(stat, baseCost);
}

void CreatureObjectAdapter::updateSpeedAndAccelerationMods() {
	(static_cast<CreatureObject*>(stub))->updateSpeedAndAccelerationMods();
}

void CreatureObjectAdapter::setFaction(unsigned int crc) {
	(static_cast<CreatureObject*>(stub))->setFaction(crc);
}

void CreatureObjectAdapter::destroyPlayerCreatureFromDatabase(bool destroyContainedObjects) {
	(static_cast<CreatureObject*>(stub))->destroyPlayerCreatureFromDatabase(destroyContainedObjects);
}

float CreatureObjectAdapter::getTemplateRadius() {
	return (static_cast<CreatureObject*>(stub))->getTemplateRadius();
}

void CreatureObjectAdapter::reloadTemplate() {
	(static_cast<CreatureObject*>(stub))->reloadTemplate();
}

/*
 *	CreatureObjectHelper
 */

CreatureObjectHelper* CreatureObjectHelper::staticInitializer = CreatureObjectHelper::instance();

CreatureObjectHelper::CreatureObjectHelper() {
	className = "CreatureObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void CreatureObjectHelper::finalizeHelper() {
	CreatureObjectHelper::finalize();
}

DistributedObject* CreatureObjectHelper::instantiateObject() {
	return new CreatureObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* CreatureObjectHelper::instantiateServant() {
	return new CreatureObjectImplementation();
}

DistributedObjectAdapter* CreatureObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new CreatureObjectAdapter(static_cast<CreatureObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

