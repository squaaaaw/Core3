/*
 *	autogen/server/zone/objects/creature/ai/AiAgent.cpp generated by engine3 IDL compiler 0.60
 */

#include "AiAgent.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/creature/ai/events/AiThinkEvent.h"

#include "server/zone/objects/creature/ai/events/AiMoveEvent.h"

#include "server/zone/objects/creature/ai/events/AiWaitEvent.h"

#include "server/zone/objects/creature/ai/events/AiAwarenessEvent.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/objects/creature/ai/CreatureTemplate.h"

#include "server/zone/objects/creature/events/DespawnCreatureOnPlayerDissappear.h"

#include "server/zone/objects/creature/ai/bt/Behavior.h"

#include "server/zone/objects/creature/ai/bt/CompositeBehavior.h"

#include "server/zone/objects/creature/ai/events/AiTrackingTask.h"

/*
 *	AiAgentStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 24868240,RPC_NOTIFYLOADFROMDATABASE__,RPC_FINALIZE__,RPC_ACTIVATERECOVERY__,RPC_ACTIVATEMOVEMENTEVENT__,RPC_ACTIVATEWAITEVENT__,RPC_ACTIVATEAWARENESSEVENT__LONG_,RPC_ACTIVATEINTERRUPT__SCENEOBJECT_LONG_,RPC_ACTIVATELOAD__STRING_,RPC_DORECOVERY__INT_,RPC_DOMOVEMENT__,RPC_SETLEVEL__INT_BOOL_,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_CALCULATEATTACKMINDAMAGE__INT_,RPC_CALCULATEATTACKMAXDAMAGE__INT_,RPC_CALCULATEATTACKSPEED__INT_,RPC_GETTARGETFROMMAP__,RPC_GETTARGETFROMDEFENDERS__,RPC_GETTARGETFROMTARGETSDEFENDERS__,RPC_VALIDATETARGET__,RPC_VALIDATETARGET__SCENEOBJECT_,RPC_ISCAMOUFLAGED__CREATUREOBJECT_,RPC_FINDNEXTPOSITION__FLOAT_BOOL_,RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_CHECKNEWANGLE__,RPC_FILLATTRIBUTELIST__ATTRIBUTELISTMESSAGE_CREATUREOBJECT_,RPC_SETNEXTPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_,RPC_SETNEXTSTEPPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_,RPC_NOTIFYPOSITIONUPDATE__QUADTREEENTRY_,RPC_CLEARPATROLPOINTS__,RPC_CLEARSAVEDPATROLPOINTS__,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_,RPC_ADDDOTSTATE__CREATUREOBJECT_LONG_LONG_INT_BYTE_INT_FLOAT_INT_INT_,RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_,RPC_SENDDEFAULTCONVERSATIONTO__SCENEOBJECT_,RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_,RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_,RPC_NOTIFYCONVERSEOBSERVERS__CREATUREOBJECT_,RPC_NOTIFYATTACK__OBSERVABLE_,RPC_NOTIFYCALLFORHELP__OBSERVABLE_MANAGEDOBJECT_,RPC_DESTROYOBJECTFROMWORLD__BOOL_,RPC_DESTROYOBJECTFROMDATABASE__BOOL_,RPC_ACTIVATEPOSTURERECOVERY__,RPC_ACTIVATEHAMREGENERATION__INT_,RPC_QUEUEDIZZYFALLEVENT__,RPC_CLEARCOMBATSTATE__BOOL_,RPC_SETDEFENDER__SCENEOBJECT_,RPC_ADDDEFENDER__SCENEOBJECT_,RPC_REMOVEDEFENDER__SCENEOBJECT_,RPC_SETDESPAWNONNOPLAYERINRANGE__BOOL_,RPC_NOTIFYDESPAWN__ZONE_,RPC_SCHEDULEDESPAWN__,RPC_SCHEDULEDESPAWN__INT_,RPC_RESPAWN__ZONE_INT_,RPC_SETHOMELOCATION__FLOAT_FLOAT_FLOAT_CELLOBJECT_,RPC_SETRESPAWNTIMER__FLOAT_,RPC_SETRANDOMRESPAWN__BOOL_,RPC_RESETRESPAWNCOUNTER__,RPC_ISATTACKABLEBY__CREATUREOBJECT_,RPC_ISATTACKABLEBY__TANGIBLEOBJECT_,RPC_ISAGGRESSIVETO__CREATUREOBJECT_,RPC_SETOBLIVIOUS__,RPC_SETWATCHOBJECT__SCENEOBJECT_,RPC_SETSTALKOBJECT__SCENEOBJECT_,RPC_SETFOLLOWOBJECT__SCENEOBJECT_,RPC_SETTARGETOBJECT__SCENEOBJECT_,RPC_RUNAWAY__CREATUREOBJECT_FLOAT_,RPC_LEASH__,RPC_GENERATEPATROL__INT_FLOAT_,RPC_GETFOLLOWOBJECT__,RPC_STOREFOLLOWOBJECT__,RPC_RESTOREFOLLOWOBJECT__,RPC_GETFOLLOWSTATE__,RPC_SETFOLLOWSTATE__INT_,RPC_GETMAXDISTANCE__,RPC_SETDESTINATION__,RPC_COMPLETEMOVE__,RPC_SETWAIT__INT_,RPC_GETWAIT__,RPC_ISWAITING__,RPC_STOPWAITING__,RPC_SELECTWEAPON__,RPC_SELECTDEFAULTWEAPON__,RPC_VALIDATESTATEATTACK__CREATUREOBJECT_INT_,RPC_SELECTSPECIALATTACK__,RPC_SELECTSPECIALATTACK__INT_,RPC_SELECTDEFAULTATTACK__,RPC_VALIDATESTATEATTACK__,RPC_ENQUEUEATTACK__INT_,RPC_ISRETREATING__,RPC_ISFLEEING__,RPC_CLEARDESPAWNEVENT__,RPC_GETKINETIC__,RPC_GETENERGY__,RPC_GETELECTRICITY__,RPC_GETSTUN__,RPC_GETBLAST__,RPC_GETHEAT__,RPC_GETCOLD__,RPC_GETACID__,RPC_GETLIGHTSABER__,RPC_ISSPECIALPROTECTION__INT_,RPC_ISSTALKER__,RPC_ISKILLER__,RPC_GETFEROCITY__,RPC_GETAGGRORADIUS__,RPC_GETARMOR__,RPC_GETDESPAWNONNOPLAYERINRANGE__,RPC_GETNUMBEROFPLAYERSINRANGE__,RPC_GETFACTIONSTRING__,RPC_GETSOCIALGROUP__,RPC_GETCHANCEHIT__,RPC_GETDAMAGEMIN__,RPC_GETDAMAGEMAX__,RPC_GETSPECIALDAMAGEMULT__,RPC_GETBASEXP__,RPC_GETDIET__,RPC_GETTEMPLATELEVEL__,RPC_GETTAME__,RPC_GETREACTIONSTF__,RPC_GETRESPAWNTIMER__,RPC_GETRANDOMRESPAWN__,RPC_GETRESPAWNCOUNTER__,RPC_ISAIAGENT__,RPC_HASLOOT__,RPC_SETSHOWNEXTPOSITION__BOOL_,RPC_ISEVENTMOB__,RPC_ISPET__,RPC_GETCURRENTBEHAVIOR__,RPC_SETHOMEOBJECT__SCENEOBJECT_,RPC_SETCOMBATSTATE__,RPC_GETCREATUREBITMASK__,RPC_SETCREATUREBITMASK__INT_,RPC_SETCREATUREBIT__INT_,RPC_CLEARCREATUREBIT__INT_,RPC_INCREMENTLUACALL__STRING_,RPC_ADDTOLUATIME__STRING_LONG_,RPC_OUTPUTLUATIMES__CREATUREOBJECT_,RPC_RESCHEDULETRACKINGTASK__,RPC_HASRANGEDWEAPON__,RPC_GETUSERANGED__,RPC_HASSPECIALATTACK__INT_,RPC_SETPETDEED__PETDEED_,RPC_HASPETDEED__,RPC_GETPETDEED__,RPC_SENDREACTIONCHAT__INT_INT_BOOL_,RPC_HASREACTIONCHATMESSAGES__,RPC_GETPERSONALITYSTF__,RPC_GETREACTIONRANK__,RPC_SETREACTIONRANK__INT_,RPC_GETHAMMAXIMUM__,RPC_GETHAMBASE__,RPC_SETMAXHAM__INT_INT_BOOL_,RPC_RELOADTEMPLATE__,RPC_GETCONVOTEMPLATECRC__,RPC_SETCONVOTEMPLATE__STRING_,RPC_SETLAIRTEMPLATECRC__INT_,RPC_GETLAIRTEMPLATECRC__};

AiAgent::AiAgent() : CreatureObject(DummyConstructorParameter::instance()) {
	AiAgentImplementation* _implementation = new AiAgentImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("AiAgent");
}

AiAgent::AiAgent(DummyConstructorParameter* param) : CreatureObject(param) {
	_setClassName("AiAgent");
}

AiAgent::~AiAgent() {
}



void AiAgent::initializeTransientMembers() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void AiAgent::notifyLoadFromDatabase() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

void AiAgent::activateRecovery() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATERECOVERY__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateRecovery();
	}
}

void AiAgent::activateMovementEvent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEMOVEMENTEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateMovementEvent();
	}
}

void AiAgent::activateWaitEvent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEWAITEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateWaitEvent();
	}
}

void AiAgent::activateAwarenessEvent(unsigned long long delay) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEAWARENESSEVENT__LONG_);
		method.addUnsignedLongParameter(delay);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateAwarenessEvent(delay);
	}
}

void AiAgent::activateInterrupt(SceneObject* source, long long msg) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEINTERRUPT__SCENEOBJECT_LONG_);
		method.addObjectParameter(source);
		method.addSignedLongParameter(msg);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateInterrupt(source, msg);
	}
}

void AiAgent::activateLoad(const String& temp) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATELOAD__STRING_);
		method.addAsciiParameter(temp);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateLoad(temp);
	}
}

void AiAgent::doRecovery(int latency) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DORECOVERY__INT_);
		method.addSignedIntParameter(latency);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->doRecovery(latency);
	}
}

void AiAgent::doMovement() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOMOVEMENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->doMovement();
	}
}

void AiAgent::setLevel(int lvl, bool randomHam) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLEVEL__INT_BOOL_);
		method.addSignedIntParameter(lvl);
		method.addBooleanParameter(randomHam);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLevel(lvl, randomHam);
	}
}

void AiAgent::sendBaselinesTo(SceneObject* player) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

int AiAgent::calculateAttackMinDamage(int level) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEATTACKMINDAMAGE__INT_);
		method.addSignedIntParameter(level);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->calculateAttackMinDamage(level);
	}
}

int AiAgent::calculateAttackMaxDamage(int level) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEATTACKMAXDAMAGE__INT_);
		method.addSignedIntParameter(level);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->calculateAttackMaxDamage(level);
	}
}

float AiAgent::calculateAttackSpeed(int level) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEATTACKSPEED__INT_);
		method.addSignedIntParameter(level);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->calculateAttackSpeed(level);
	}
}

SceneObject* AiAgent::getTargetFromMap() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETFROMMAP__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getTargetFromMap();
	}
}

SceneObject* AiAgent::getTargetFromDefenders() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETFROMDEFENDERS__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getTargetFromDefenders();
	}
}

SceneObject* AiAgent::getTargetFromTargetsDefenders() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETFROMTARGETSDEFENDERS__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getTargetFromTargetsDefenders();
	}
}

bool AiAgent::validateTarget() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VALIDATETARGET__);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->validateTarget();
	}
}

bool AiAgent::validateTarget(SceneObject* target) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VALIDATETARGET__SCENEOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->validateTarget(target);
	}
}

bool AiAgent::isCamouflaged(CreatureObject* target) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMOUFLAGED__CREATUREOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCamouflaged(target);
	}
}

bool AiAgent::findNextPosition(float maxDistance, bool walk) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FINDNEXTPOSITION__FLOAT_BOOL_);
		method.addFloatParameter(maxDistance);
		method.addBooleanParameter(walk);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->findNextPosition(maxDistance, walk);
	}
}

float AiAgent::getWorldZ(const Vector3& position) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getWorldZ(position);
	}
}

void AiAgent::doAwarenessCheck() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->doAwarenessCheck();
	}
}

bool AiAgent::runAwarenessLogicCheck(SceneObject* pObject) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->runAwarenessLogicCheck(pObject);
	}
}

void AiAgent::runStartAwarenessInterrupt(SceneObject* pObject) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->runStartAwarenessInterrupt(pObject);
	}
}

int AiAgent::checkForReactionChat(SceneObject* pObject) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->checkForReactionChat(pObject);
	}
}

int AiAgent::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		return _implementation->handleObjectMenuSelect(player, selectedID);
	}
}

void AiAgent::checkNewAngle() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKNEWANGLE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->checkNewAngle();
	}
}

void AiAgent::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FILLATTRIBUTELIST__ATTRIBUTELISTMESSAGE_CREATUREOBJECT_);
		method.addObjectParameter(msg);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

void AiAgent::setNextPosition(float x, float z, float y, CellObject* cell) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNEXTPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addObjectParameter(cell);

		method.executeWithVoidReturn();
	} else {
		_implementation->setNextPosition(x, z, y, cell);
	}
}

void AiAgent::setNextStepPosition(float x, float z, float y, CellObject* cell) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNEXTSTEPPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addObjectParameter(cell);

		method.executeWithVoidReturn();
	} else {
		_implementation->setNextStepPosition(x, z, y, cell);
	}
}

void AiAgent::notifyPositionUpdate(QuadTreeEntry* entry) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYPOSITIONUPDATE__QUADTREEENTRY_);
		method.addObjectParameter(entry);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyPositionUpdate(entry);
	}
}

void AiAgent::updateCurrentPosition(PatrolPoint* point) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updateCurrentPosition(point);
	}
}

void AiAgent::broadcastNextPositionUpdate(PatrolPoint* point) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->broadcastNextPositionUpdate(point);
	}
}

void AiAgent::clearPatrolPoints() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARPATROLPOINTS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearPatrolPoints();
	}
}

void AiAgent::clearSavedPatrolPoints() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSAVEDPATROLPOINTS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearSavedPatrolPoints();
	}
}

void AiAgent::setPatrolPoints(PatrolPointsVector& pVector) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setPatrolPoints(pVector);
	}
}

PatrolPoint AiAgent::getNextPosition() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getNextPosition();
	}
}

int AiAgent::getPatrolPointSize() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPatrolPointSize();
	}
}

void AiAgent::notifyInsert(QuadTreeEntry* entry) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->notifyInsert(entry);
	}
}

void AiAgent::notifyDissapear(QuadTreeEntry* entry) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->notifyDissapear(entry);
	}
}

void AiAgent::loadTemplateData(SharedObjectTemplate* templateData) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void AiAgent::loadTemplateData(CreatureTemplate* templateData) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void AiAgent::setupAttackMaps() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setupAttackMaps();
	}
}

int AiAgent::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
	}
}

int AiAgent::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addAsciiParameter(xp);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
	}
}

int AiAgent::addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTSTATE__CREATUREOBJECT_LONG_LONG_INT_BYTE_INT_FLOAT_INT_INT_);
		method.addObjectParameter(attacker);
		method.addUnsignedLongParameter(dotType);
		method.addUnsignedLongParameter(objectID);
		method.addUnsignedIntParameter(strength);
		method.addByteParameter(type);
		method.addUnsignedIntParameter(duration);
		method.addFloatParameter(potency);
		method.addUnsignedIntParameter(defense);
		method.addSignedIntParameter(secondaryStrength);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
	}
}

bool AiAgent::sendConversationStartTo(SceneObject* player) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->sendConversationStartTo(player);
	}
}

void AiAgent::sendDefaultConversationTo(SceneObject* player) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDDEFAULTCONVERSATIONTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendDefaultConversationTo(player);
	}
}

void AiAgent::selectConversationOption(int option, SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_);
		method.addSignedIntParameter(option);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->selectConversationOption(option, obj);
	}
}

int AiAgent::notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(condition);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->notifyObjectDestructionObservers(attacker, condition, isCombatAction);
	}
}

int AiAgent::notifyConverseObservers(CreatureObject* converser) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYCONVERSEOBSERVERS__CREATUREOBJECT_);
		method.addObjectParameter(converser);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((converser == NULL) || converser->isLockedByCurrentThread());
		return _implementation->notifyConverseObservers(converser);
	}
}

int AiAgent::notifyAttack(Observable* observable) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYATTACK__OBSERVABLE_);
		method.addObjectParameter(observable);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyAttack(observable);
	}
}

int AiAgent::notifyCallForHelp(Observable* observable, ManagedObject* arg1) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYCALLFORHELP__OBSERVABLE_MANAGEDOBJECT_);
		method.addObjectParameter(observable);
		method.addObjectParameter(arg1);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyCallForHelp(observable, arg1);
	}
}

void AiAgent::destroyObjectFromWorld(bool sendSelfDestroy) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMWORLD__BOOL_);
		method.addBooleanParameter(sendSelfDestroy);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->destroyObjectFromWorld(sendSelfDestroy);
	}
}

void AiAgent::destroyObjectFromDatabase(bool destroyContainedObjects) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMDATABASE__BOOL_);
		method.addBooleanParameter(destroyContainedObjects);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->destroyObjectFromDatabase(destroyContainedObjects);
	}
}

void AiAgent::activatePostureRecovery() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEPOSTURERECOVERY__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activatePostureRecovery();
	}
}

void AiAgent::activateHAMRegeneration(int latency) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEHAMREGENERATION__INT_);
		method.addSignedIntParameter(latency);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateHAMRegeneration(latency);
	}
}

void AiAgent::queueDizzyFallEvent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_QUEUEDIZZYFALLEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->queueDizzyFallEvent();
	}
}

void AiAgent::clearCombatState(bool clearDefenders) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCOMBATSTATE__BOOL_);
		method.addBooleanParameter(clearDefenders);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearCombatState(clearDefenders);
	}
}

void AiAgent::setDefender(SceneObject* defender) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDEFENDER__SCENEOBJECT_);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDefender(defender);
	}
}

void AiAgent::addDefender(SceneObject* defender) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDEFENDER__SCENEOBJECT_);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addDefender(defender);
	}
}

void AiAgent::removeDefender(SceneObject* defender) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEDEFENDER__SCENEOBJECT_);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeDefender(defender);
	}
}

void AiAgent::setDespawnOnNoPlayerInRange(bool val) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDESPAWNONNOPLAYERINRANGE__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDespawnOnNoPlayerInRange(val);
	}
}

void AiAgent::notifyDespawn(Zone* zone) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYDESPAWN__ZONE_);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->notifyDespawn(zone);
	}
}

void AiAgent::scheduleDespawn() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEDESPAWN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->scheduleDespawn();
	}
}

void AiAgent::scheduleDespawn(int timeToDespawn) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEDESPAWN__INT_);
		method.addSignedIntParameter(timeToDespawn);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->scheduleDespawn(timeToDespawn);
	}
}

void AiAgent::respawn(Zone* zone, int level) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESPAWN__ZONE_INT_);
		method.addObjectParameter(zone);
		method.addSignedIntParameter(level);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->respawn(zone, level);
	}
}

void AiAgent::addPatrolPoint(PatrolPoint& point) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addPatrolPoint(point);
	}
}

void AiAgent::setHomeLocation(float x, float z, float y, CellObject* cell) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHOMELOCATION__FLOAT_FLOAT_FLOAT_CELLOBJECT_);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addObjectParameter(cell);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setHomeLocation(x, z, y, cell);
	}
}

void AiAgent::setRespawnTimer(float resp) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRESPAWNTIMER__FLOAT_);
		method.addFloatParameter(resp);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRespawnTimer(resp);
	}
}

void AiAgent::setRandomRespawn(bool resp) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRANDOMRESPAWN__BOOL_);
		method.addBooleanParameter(resp);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRandomRespawn(resp);
	}
}

void AiAgent::resetRespawnCounter() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETRESPAWNCOUNTER__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->resetRespawnCounter();
	}
}

bool AiAgent::isAttackableBy(CreatureObject* object) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(object);
	}
}

bool AiAgent::isAttackableBy(TangibleObject* object) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__TANGIBLEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(object);
	}
}

bool AiAgent::isAggressiveTo(CreatureObject* object) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAGGRESSIVETO__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAggressiveTo(object);
	}
}

void AiAgent::setOblivious() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOBLIVIOUS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOblivious();
	}
}

void AiAgent::setWatchObject(SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWATCHOBJECT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setWatchObject(obj);
	}
}

void AiAgent::setStalkObject(SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTALKOBJECT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setStalkObject(obj);
	}
}

void AiAgent::setFollowObject(SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFOLLOWOBJECT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFollowObject(obj);
	}
}

void AiAgent::setTargetObject(SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTARGETOBJECT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setTargetObject(obj);
	}
}

void AiAgent::runAway(CreatureObject* target, float range) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RUNAWAY__CREATUREOBJECT_FLOAT_);
		method.addObjectParameter(target);
		method.addFloatParameter(range);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->runAway(target, range);
	}
}

void AiAgent::leash() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LEASH__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->leash();
	}
}

bool AiAgent::generatePatrol(int num, float dist) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GENERATEPATROL__INT_FLOAT_);
		method.addSignedIntParameter(num);
		method.addFloatParameter(dist);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->generatePatrol(num, dist);
	}
}

ManagedWeakReference<SceneObject* > AiAgent::getFollowObject() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFOLLOWOBJECT__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getFollowObject();
	}
}

void AiAgent::storeFollowObject() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOREFOLLOWOBJECT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->storeFollowObject();
	}
}

void AiAgent::restoreFollowObject() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESTOREFOLLOWOBJECT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->restoreFollowObject();
	}
}

unsigned int AiAgent::getFollowState() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFOLLOWSTATE__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getFollowState();
	}
}

void AiAgent::setFollowState(int state) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFOLLOWSTATE__INT_);
		method.addSignedIntParameter(state);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFollowState(state);
	}
}

float AiAgent::getMaxDistance() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXDISTANCE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMaxDistance();
	}
}

int AiAgent::setDestination() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDESTINATION__);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->setDestination();
	}
}

bool AiAgent::completeMove() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPLETEMOVE__);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->completeMove();
	}
}

void AiAgent::setWait(int wait) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWAIT__INT_);
		method.addSignedIntParameter(wait);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setWait(wait);
	}
}

int AiAgent::getWait() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWAIT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getWait();
	}
}

bool AiAgent::isWaiting() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWAITING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isWaiting();
	}
}

void AiAgent::stopWaiting() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPWAITING__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->stopWaiting();
	}
}

void AiAgent::selectWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTWEAPON__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->selectWeapon();
	}
}

void AiAgent::selectDefaultWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTDEFAULTWEAPON__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->selectDefaultWeapon();
	}
}

bool AiAgent::validateStateAttack(CreatureObject* target, unsigned int actionCRC) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VALIDATESTATEATTACK__CREATUREOBJECT_INT_);
		method.addObjectParameter(target);
		method.addUnsignedIntParameter(actionCRC);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->validateStateAttack(target, actionCRC);
	}
}

void AiAgent::selectSpecialAttack() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTSPECIALATTACK__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->selectSpecialAttack();
	}
}

void AiAgent::selectSpecialAttack(int attackNum) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTSPECIALATTACK__INT_);
		method.addSignedIntParameter(attackNum);

		method.executeWithVoidReturn();
	} else {
		_implementation->selectSpecialAttack(attackNum);
	}
}

void AiAgent::selectDefaultAttack() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTDEFAULTATTACK__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->selectDefaultAttack();
	}
}

bool AiAgent::validateStateAttack() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VALIDATESTATEATTACK__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->validateStateAttack();
	}
}

void AiAgent::enqueueAttack(int priority) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENQUEUEATTACK__INT_);
		method.addSignedIntParameter(priority);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->enqueueAttack(priority);
	}
}

bool AiAgent::isRetreating() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRETREATING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRetreating();
	}
}

bool AiAgent::isFleeing() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFLEEING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFleeing();
	}
}

void AiAgent::clearDespawnEvent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARDESPAWNEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearDespawnEvent();
	}
}

float AiAgent::getKinetic() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETKINETIC__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getKinetic();
	}
}

float AiAgent::getEnergy() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENERGY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getEnergy();
	}
}

float AiAgent::getElectricity() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETELECTRICITY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getElectricity();
	}
}

float AiAgent::getStun() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTUN__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getStun();
	}
}

float AiAgent::getBlast() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBLAST__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getBlast();
	}
}

float AiAgent::getHeat() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEAT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHeat();
	}
}

float AiAgent::getCold() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOLD__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getCold();
	}
}

float AiAgent::getAcid() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACID__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAcid();
	}
}

float AiAgent::getLightSaber() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLIGHTSABER__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getLightSaber();
	}
}

bool AiAgent::isSpecialProtection(int resistType) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSPECIALPROTECTION__INT_);
		method.addSignedIntParameter(resistType);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSpecialProtection(resistType);
	}
}

bool AiAgent::isStalker() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTALKER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isStalker();
	}
}

bool AiAgent::isKiller() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISKILLER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isKiller();
	}
}

unsigned int AiAgent::getFerocity() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFEROCITY__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getFerocity();
	}
}

int AiAgent::getAggroRadius() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAGGRORADIUS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAggroRadius();
	}
}

unsigned int AiAgent::getArmor() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETARMOR__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getArmor();
	}
}

bool AiAgent::getDespawnOnNoPlayerInRange() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDESPAWNONNOPLAYERINRANGE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getDespawnOnNoPlayerInRange();
	}
}

int AiAgent::getNumberOfPlayersInRange() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNUMBEROFPLAYERSINRANGE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getNumberOfPlayersInRange();
	}
}

String AiAgent::getFactionString() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONSTRING__);

		String _return_getFactionString;
		method.executeWithAsciiReturn(_return_getFactionString);
		return _return_getFactionString;
	} else {
		return _implementation->getFactionString();
	}
}

String AiAgent::getSocialGroup() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSOCIALGROUP__);

		String _return_getSocialGroup;
		method.executeWithAsciiReturn(_return_getSocialGroup);
		return _return_getSocialGroup;
	} else {
		return _implementation->getSocialGroup();
	}
}

float AiAgent::getChanceHit() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHANCEHIT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getChanceHit();
	}
}

int AiAgent::getDamageMin() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGEMIN__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDamageMin();
	}
}

int AiAgent::getDamageMax() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGEMAX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDamageMax();
	}
}

float AiAgent::getSpecialDamageMult() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIALDAMAGEMULT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getSpecialDamageMult();
	}
}

int AiAgent::getBaseXp() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASEXP__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseXp();
	}
}

unsigned int AiAgent::getDiet() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDIET__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getDiet();
	}
}

unsigned int AiAgent::getTemplateLevel() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTEMPLATELEVEL__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getTemplateLevel();
	}
}

float AiAgent::getTame() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTAME__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getTame();
	}
}

CreatureAttackMap* AiAgent::getAttackMap() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAttackMap();
	}
}

LootGroupCollection* AiAgent::getLootGroups() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLootGroups();
	}
}

String AiAgent::getReactionStf() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREACTIONSTF__);

		String _return_getReactionStf;
		method.executeWithAsciiReturn(_return_getReactionStf);
		return _return_getReactionStf;
	} else {
		return _implementation->getReactionStf();
	}
}

float AiAgent::getRespawnTimer() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRESPAWNTIMER__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getRespawnTimer();
	}
}

bool AiAgent::getRandomRespawn() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRANDOMRESPAWN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getRandomRespawn();
	}
}

int AiAgent::getRespawnCounter() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRESPAWNCOUNTER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getRespawnCounter();
	}
}

PatrolPoint* AiAgent::getHomeLocation() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getHomeLocation();
	}
}

bool AiAgent::isAiAgent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAIAGENT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAiAgent();
	}
}

AiAgent* AiAgent::__asAiAgent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->asAiAgent();
	}
}

CreatureTemplate* AiAgent::getCreatureTemplate() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCreatureTemplate();
	}
}

bool AiAgent::hasLoot() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASLOOT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasLoot();
	}
}

void AiAgent::setShowNextPosition(bool val) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSHOWNEXTPOSITION__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setShowNextPosition(val);
	}
}

bool AiAgent::isEventMob() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISEVENTMOB__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isEventMob();
	}
}

bool AiAgent::isPet() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPET__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPet();
	}
}

void AiAgent::setupBehaviorTree() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setupBehaviorTree();
	}
}

void AiAgent::setupBehaviorTree(AiTemplate* aiTemplate) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setupBehaviorTree(aiTemplate);
	}
}

void AiAgent::setupBehaviorTree(AiTemplate* getTarget, AiTemplate* selectAttack, AiTemplate* combatMove, AiTemplate* idle) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setupBehaviorTree(getTarget, selectAttack, combatMove, idle);
	}
}

void AiAgent::setCurrentBehavior(unsigned int b) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCurrentBehavior(b);
	}
}

unsigned int AiAgent::getCurrentBehavior() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTBEHAVIOR__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getCurrentBehavior();
	}
}

int AiAgent::getBehaviorStatus() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getBehaviorStatus();
	}
}

void AiAgent::setBehaviorStatus(int status) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setBehaviorStatus(status);
	}
}

void AiAgent::resetBehaviorList() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->resetBehaviorList();
	}
}

void AiAgent::clearBehaviorList() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearBehaviorList();
	}
}

int AiAgent::interrupt(SceneObject* source, long long msg) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->interrupt(source, msg);
	}
}

void AiAgent::broadcastInterrupt(long long msg) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->broadcastInterrupt(msg);
	}
}

void AiAgent::setHomeObject(SceneObject* home) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHOMEOBJECT__SCENEOBJECT_);
		method.addObjectParameter(home);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setHomeObject(home);
	}
}

ManagedWeakReference<SceneObject* > AiAgent::getHomeObject() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getHomeObject();
	}
}

void AiAgent::setCombatState() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMBATSTATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCombatState();
	}
}

int AiAgent::getCreatureBitmask() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATUREBITMASK__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCreatureBitmask();
	}
}

void AiAgent::setCreatureBitmask(int mask) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCREATUREBITMASK__INT_);
		method.addSignedIntParameter(mask);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCreatureBitmask(mask);
	}
}

void AiAgent::setCreatureBit(unsigned int option) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCREATUREBIT__INT_);
		method.addUnsignedIntParameter(option);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCreatureBit(option);
	}
}

void AiAgent::clearCreatureBit(unsigned int option) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCREATUREBIT__INT_);
		method.addUnsignedIntParameter(option);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearCreatureBit(option);
	}
}

Time* AiAgent::getAlertedTime() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAlertedTime();
	}
}

void AiAgent::incrementLuaCall(const String& key) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREMENTLUACALL__STRING_);
		method.addAsciiParameter(key);

		method.executeWithVoidReturn();
	} else {
		_implementation->incrementLuaCall(key);
	}
}

void AiAgent::addToLuaTime(const String& key, unsigned long long val) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOLUATIME__STRING_LONG_);
		method.addAsciiParameter(key);
		method.addUnsignedLongParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToLuaTime(key, val);
	}
}

void AiAgent::outputLuaTimes(CreatureObject* caller) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_OUTPUTLUATIMES__CREATUREOBJECT_);
		method.addObjectParameter(caller);

		method.executeWithVoidReturn();
	} else {
		_implementation->outputLuaTimes(caller);
	}
}

void AiAgent::rescheduleTrackingTask() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESCHEDULETRACKINGTASK__);

		method.executeWithVoidReturn();
	} else {
		_implementation->rescheduleTrackingTask();
	}
}

bool AiAgent::hasRangedWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASRANGEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasRangedWeapon();
	}
}

bool AiAgent::getUseRanged() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETUSERANGED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getUseRanged();
	}
}

bool AiAgent::hasSpecialAttack(int num) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSPECIALATTACK__INT_);
		method.addSignedIntParameter(num);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSpecialAttack(num);
	}
}

void AiAgent::setPetDeed(PetDeed* deed) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPETDEED__PETDEED_);
		method.addObjectParameter(deed);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPetDeed(deed);
	}
}

bool AiAgent::hasPetDeed() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASPETDEED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasPetDeed();
	}
}

PetDeed* AiAgent::getPetDeed() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPETDEED__);

		return static_cast<PetDeed*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getPetDeed();
	}
}

void AiAgent::sendReactionChat(int type, int state, bool force) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDREACTIONCHAT__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(state);
		method.addBooleanParameter(force);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->sendReactionChat(type, state, force);
	}
}

bool AiAgent::hasReactionChatMessages() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASREACTIONCHATMESSAGES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasReactionChatMessages();
	}
}

float AiAgent::getEffectiveResist() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getEffectiveResist();
	}
}

String AiAgent::getPersonalityStf() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERSONALITYSTF__);

		String _return_getPersonalityStf;
		method.executeWithAsciiReturn(_return_getPersonalityStf);
		return _return_getPersonalityStf;
	} else {
		return _implementation->getPersonalityStf();
	}
}

int AiAgent::getReactionRank() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREACTIONRANK__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getReactionRank();
	}
}

void AiAgent::setReactionRank(int rank) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETREACTIONRANK__INT_);
		method.addSignedIntParameter(rank);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setReactionRank(rank);
	}
}

int AiAgent::getHamMaximum() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHAMMAXIMUM__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHamMaximum();
	}
}

int AiAgent::getHamBase() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHAMBASE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHamBase();
	}
}

void AiAgent::setMaxHAM(int type, int value, bool notifyClient) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMaxHAM(type, value, notifyClient);
	}
}

void AiAgent::reloadTemplate() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RELOADTEMPLATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->reloadTemplate();
	}
}

unsigned int AiAgent::getConvoTemplateCRC() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONVOTEMPLATECRC__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getConvoTemplateCRC();
	}
}

void AiAgent::setConvoTemplate(const String& templateString) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONVOTEMPLATE__STRING_);
		method.addAsciiParameter(templateString);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setConvoTemplate(templateString);
	}
}

void AiAgent::setLairTemplateCRC(unsigned int crc) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLAIRTEMPLATECRC__INT_);
		method.addUnsignedIntParameter(crc);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLairTemplateCRC(crc);
	}
}

unsigned int AiAgent::getLairTemplateCRC() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLAIRTEMPLATECRC__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getLairTemplateCRC();
	}
}

DistributedObjectServant* AiAgent::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* AiAgent::_getImplementationForRead() const {
	return _impl;
}

void AiAgent::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	AiAgentImplementation
 */

AiAgentImplementation::AiAgentImplementation(DummyConstructorParameter* param) : CreatureObjectImplementation(param) {
	_initializeImplementation();
}


AiAgentImplementation::~AiAgentImplementation() {
	AiAgentImplementation::finalize();
}


void AiAgentImplementation::_initializeImplementation() {
	_setClassHelper(AiAgentHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void AiAgentImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<AiAgent*>(stub);
	CreatureObjectImplementation::_setStub(stub);
}

DistributedObjectStub* AiAgentImplementation::_getStub() {
	return _this.get();
}

AiAgentImplementation::operator const AiAgent*() {
	return _this.get();
}

void AiAgentImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void AiAgentImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void AiAgentImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void AiAgentImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void AiAgentImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void AiAgentImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void AiAgentImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void AiAgentImplementation::_serializationHelperMethod() {
	CreatureObjectImplementation::_serializationHelperMethod();

	_setClassName("AiAgent");

}

void AiAgentImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(AiAgentImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool AiAgentImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (CreatureObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xbf666870: //AiAgent.skillCommands
		TypeInfo<Vector<String> >::parseFromBinaryStream(&skillCommands, stream);
		return true;

	case 0x5f95ada4: //AiAgent.patrolPoints
		TypeInfo<PatrolPointsVector >::parseFromBinaryStream(&patrolPoints, stream);
		return true;

	case 0x2775f3b8: //AiAgent.savedPatrolPoints
		TypeInfo<PatrolPointsVector >::parseFromBinaryStream(&savedPatrolPoints, stream);
		return true;

	case 0xfb85e64b: //AiAgent.homeLocation
		TypeInfo<PatrolPoint >::parseFromBinaryStream(&homeLocation, stream);
		return true;

	case 0xe343255e: //AiAgent.nextStepPosition
		TypeInfo<PatrolPoint >::parseFromBinaryStream(&nextStepPosition, stream);
		return true;

	case 0xe1f0107d: //AiAgent.readyWeapon
		TypeInfo<ManagedReference<WeaponObject* > >::parseFromBinaryStream(&readyWeapon, stream);
		return true;

	case 0x3e887dd1: //AiAgent.attackMap
		TypeInfo<Reference<CreatureAttackMap* > >::parseFromBinaryStream(&attackMap, stream);
		return true;

	case 0x3278eda: //AiAgent.defaultAttackMap
		TypeInfo<Reference<CreatureAttackMap* > >::parseFromBinaryStream(&defaultAttackMap, stream);
		return true;

	case 0x3ce94741: //AiAgent.npcTemplate
		TypeInfo<CreatureTemplateReference >::parseFromBinaryStream(&npcTemplate, stream);
		return true;

	case 0x170c1aa2: //AiAgent.convoTemplateCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&convoTemplateCRC, stream);
		return true;

	case 0x6ccc7b64: //AiAgent.homeObject
		TypeInfo<ManagedWeakReference<SceneObject* > >::parseFromBinaryStream(&homeObject, stream);
		return true;

	case 0x903a02dc: //AiAgent.showNextMovementPosition
		TypeInfo<bool >::parseFromBinaryStream(&showNextMovementPosition, stream);
		return true;

	case 0x35937577: //AiAgent.movementMarkers
		TypeInfo<Vector<ManagedReference<SceneObject* > > >::parseFromBinaryStream(&movementMarkers, stream);
		return true;

	case 0x9ad20484: //AiAgent.despawnOnNoPlayerInRange
		TypeInfo<bool >::parseFromBinaryStream(&despawnOnNoPlayerInRange, stream);
		return true;

	case 0x63fb116c: //AiAgent.followObject
		TypeInfo<ManagedWeakReference<SceneObject* > >::parseFromBinaryStream(&followObject, stream);
		return true;

	case 0xab948a97: //AiAgent.followStore
		TypeInfo<ManagedWeakReference<SceneObject* > >::parseFromBinaryStream(&followStore, stream);
		return true;

	case 0x4454ba1b: //AiAgent.followState
		TypeInfo<unsigned int >::parseFromBinaryStream(&followState, stream);
		return true;

	case 0xb446f60c: //AiAgent.nextMovementInterval
		TypeInfo<int >::parseFromBinaryStream(&nextMovementInterval, stream);
		return true;

	case 0xc629a7b0: //AiAgent.reactionRank
		TypeInfo<int >::parseFromBinaryStream(&reactionRank, stream);
		return true;

	case 0x1bd8778f: //AiAgent.respawnTimer
		TypeInfo<float >::parseFromBinaryStream(&respawnTimer, stream);
		return true;

	case 0x43da33b7: //AiAgent.respawnCounter
		TypeInfo<int >::parseFromBinaryStream(&respawnCounter, stream);
		return true;

	case 0x6c050a2e: //AiAgent.randomRespawn
		TypeInfo<bool >::parseFromBinaryStream(&randomRespawn, stream);
		return true;

	case 0x8b8554f8: //AiAgent.loadedOutfit
		TypeInfo<bool >::parseFromBinaryStream(&loadedOutfit, stream);
		return true;

	case 0x8f637eb: //AiAgent.petDeed
		TypeInfo<ManagedReference<PetDeed* > >::parseFromBinaryStream(&petDeed, stream);
		return true;

	case 0xa236004f: //AiAgent.currentBehaviorID
		TypeInfo<unsigned int >::parseFromBinaryStream(&currentBehaviorID, stream);
		return true;

	case 0x778a3d38: //AiAgent.behaviors
		TypeInfo<VectorMap<unsigned int, Behavior*> >::parseFromBinaryStream(&behaviors, stream);
		return true;

	case 0x2b21755e: //AiAgent.lairTemplateCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&lairTemplateCRC, stream);
		return true;

	case 0x1f128f38: //AiAgent.creatureBitmask
		TypeInfo<unsigned int >::parseFromBinaryStream(&creatureBitmask, stream);
		return true;

	case 0x6dc86ebe: //AiAgent.waitTime
		TypeInfo<int >::parseFromBinaryStream(&waitTime, stream);
		return true;

	case 0xc64b6de1: //AiAgent.waiting
		TypeInfo<bool >::parseFromBinaryStream(&waiting, stream);
		return true;

	case 0x5eec736c: //AiAgent.fleeRange
		TypeInfo<float >::parseFromBinaryStream(&fleeRange, stream);
		return true;

	case 0xe272963f: //AiAgent.nextActionCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&nextActionCRC, stream);
		return true;

	case 0x35f6d4: //AiAgent.nextActionArgs
		TypeInfo<String >::parseFromBinaryStream(&nextActionArgs, stream);
		return true;

	}

	return false;
}

void AiAgentImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = AiAgentImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int AiAgentImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = CreatureObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xbf666870; //AiAgent.skillCommands
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&skillCommands, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x5f95ada4; //AiAgent.patrolPoints
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<PatrolPointsVector >::toBinaryStream(&patrolPoints, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2775f3b8; //AiAgent.savedPatrolPoints
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<PatrolPointsVector >::toBinaryStream(&savedPatrolPoints, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xfb85e64b; //AiAgent.homeLocation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<PatrolPoint >::toBinaryStream(&homeLocation, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe343255e; //AiAgent.nextStepPosition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<PatrolPoint >::toBinaryStream(&nextStepPosition, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe1f0107d; //AiAgent.readyWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObject* > >::toBinaryStream(&readyWeapon, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3e887dd1; //AiAgent.attackMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Reference<CreatureAttackMap* > >::toBinaryStream(&attackMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3278eda; //AiAgent.defaultAttackMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Reference<CreatureAttackMap* > >::toBinaryStream(&defaultAttackMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x3ce94741; //AiAgent.npcTemplate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<CreatureTemplateReference >::toBinaryStream(&npcTemplate, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x170c1aa2; //AiAgent.convoTemplateCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&convoTemplateCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x6ccc7b64; //AiAgent.homeObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObject* > >::toBinaryStream(&homeObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x903a02dc; //AiAgent.showNextMovementPosition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&showNextMovementPosition, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x35937577; //AiAgent.movementMarkers
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<ManagedReference<SceneObject* > > >::toBinaryStream(&movementMarkers, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x9ad20484; //AiAgent.despawnOnNoPlayerInRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&despawnOnNoPlayerInRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x63fb116c; //AiAgent.followObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObject* > >::toBinaryStream(&followObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xab948a97; //AiAgent.followStore
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObject* > >::toBinaryStream(&followStore, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x4454ba1b; //AiAgent.followState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&followState, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xb446f60c; //AiAgent.nextMovementInterval
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&nextMovementInterval, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc629a7b0; //AiAgent.reactionRank
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&reactionRank, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1bd8778f; //AiAgent.respawnTimer
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&respawnTimer, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x43da33b7; //AiAgent.respawnCounter
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&respawnCounter, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x6c050a2e; //AiAgent.randomRespawn
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&randomRespawn, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x8b8554f8; //AiAgent.loadedOutfit
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&loadedOutfit, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x8f637eb; //AiAgent.petDeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<PetDeed* > >::toBinaryStream(&petDeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xa236004f; //AiAgent.currentBehaviorID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&currentBehaviorID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x778a3d38; //AiAgent.behaviors
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, Behavior*> >::toBinaryStream(&behaviors, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x2b21755e; //AiAgent.lairTemplateCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&lairTemplateCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x1f128f38; //AiAgent.creatureBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&creatureBitmask, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x6dc86ebe; //AiAgent.waitTime
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&waitTime, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xc64b6de1; //AiAgent.waiting
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&waiting, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x5eec736c; //AiAgent.fleeRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&fleeRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0xe272963f; //AiAgent.nextActionCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&nextActionCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_nameHashCode = 0x35f6d4; //AiAgent.nextActionArgs
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&nextActionArgs, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 33;
}

AiAgentImplementation::AiAgentImplementation() {
	_initializeImplementation();
	// server/zone/objects/creature/ai/AiAgent.idl():  		followState = OBLIVIOUS;
	followState = OBLIVIOUS;
	// server/zone/objects/creature/ai/AiAgent.idl():  		respawnTimer = 0;
	respawnTimer = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		respawnCounter = 0;
	respawnCounter = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		randomRespawn = false;
	randomRespawn = false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		nextMovementInterval = UPDATEMOVEMENTINTERVAL;
	nextMovementInterval = UPDATEMOVEMENTINTERVAL;
	// server/zone/objects/creature/ai/AiAgent.idl():  		reactionRank = 0;
	reactionRank = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		convoTemplateCRC = 0;
	convoTemplateCRC = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		showNextMovementPosition = true;
	showNextMovementPosition = true;
	// server/zone/objects/creature/ai/AiAgent.idl():  		despawnOnNoPlayerInRange = false;
	despawnOnNoPlayerInRange = false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		loadedOutfit = false;
	loadedOutfit = false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		Logger.setLoggingName("AiAgent");
	Logger::setLoggingName("AiAgent");
	// server/zone/objects/creature/ai/AiAgent.idl():  		Logger.setLogging(false);
	Logger::setLogging(false);
	// server/zone/objects/creature/ai/AiAgent.idl():  		Logger.setGlobalLogging(true);
	Logger::setGlobalLogging(true);
	// server/zone/objects/creature/ai/AiAgent.idl():  		behaviors.setNoDuplicateInsertPlan();
	(&behaviors)->setNoDuplicateInsertPlan();
	// server/zone/objects/creature/ai/AiAgent.idl():  		waitTime = 0;
	waitTime = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		waiting = false;
	waiting = false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		fleeRange = 192;
	fleeRange = 192;
	// server/zone/objects/creature/ai/AiAgent.idl():  		lairTemplateCRC = 0;
	lairTemplateCRC = 0;
}

void AiAgentImplementation::finalize() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		clearBehaviorList();
	clearBehaviorList();
}

bool AiAgentImplementation::isCamouflaged(CreatureObject* target) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return isAggressiveTo(target) && (isScentMasked(target) || isConcealed(target));
	return isAggressiveTo(target) && (isScentMasked(target) || isConcealed(target));
}

void AiAgentImplementation::clearPatrolPoints() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			patrolPoints.
	if (getFollowState() == PATROLLING){
	// server/zone/objects/creature/ai/AiAgent.idl():  				}
	for (	// server/zone/objects/creature/ai/AiAgent.idl():  				for (int i = 0;
	int i = 0;
	i < (&patrolPoints)->size();
i ++) {
	// server/zone/objects/creature/ai/AiAgent.idl():  					savedPatrolPoints.add(patrolPoints.get(i));
	(&savedPatrolPoints)->add((&patrolPoints)->get(i));
}
}
	// server/zone/objects/creature/ai/AiAgent.idl():  			patrolPoints.removeAll();
	(&patrolPoints)->removeAll();
}
}

void AiAgentImplementation::clearSavedPatrolPoints() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			savedPatrolPoints.removeAll();
	(&savedPatrolPoints)->removeAll();
}
}

PatrolPoint AiAgentImplementation::getNextPosition() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			return patrolPoints.get(0);
	return (&patrolPoints)->get(0);
}
}

int AiAgentImplementation::getPatrolPointSize() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			return patrolPoints.size();
	return (&patrolPoints)->size();
}
}

int AiAgentImplementation::addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		activateRecovery();
	activateRecovery();
	// server/zone/objects/creature/ai/AiAgent.idl():  		return super.addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
	return CreatureObjectImplementation::addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
}

void AiAgentImplementation::destroyObjectFromWorld(bool sendSelfDestroy) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		super.destroyObjectFromWorld(sendSelfDestroy);
	CreatureObjectImplementation::destroyObjectFromWorld(sendSelfDestroy);
	// server/zone/objects/creature/ai/AiAgent.idl():  		numberOfPlayersInRange.set(0);
	(&numberOfPlayersInRange)->set(0);
	// server/zone/objects/creature/ai/AiAgent.idl():  	}
	if (moveEvent != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			moveEvent.clearCreatureObject();
	moveEvent->clearCreatureObject();
	// server/zone/objects/creature/ai/AiAgent.idl():  			moveEvent = null;
	moveEvent = NULL;
}
}

void AiAgentImplementation::destroyObjectFromDatabase(bool destroyContainedObjects) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		super.
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			petDeed.destroyObjectFromDatabase(true);
	petDeed->destroyObjectFromDatabase(true);
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		super.destroyObjectFromDatabase(destroyContainedObjects);
	CreatureObjectImplementation::destroyObjectFromDatabase(destroyContainedObjects);
}

void AiAgentImplementation::scheduleDespawn() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		scheduleDespawn(300);
	scheduleDespawn(300);
}

void AiAgentImplementation::addPatrolPoint(PatrolPoint& point) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			patrolPoints.add(point);
	(&patrolPoints)->add(point);
}
}

void AiAgentImplementation::setHomeLocation(float x, float z, float y, CellObject* cell) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		homeLocation.setPosition(x, z, y);
	(&homeLocation)->setPosition(x, z, y);
	// server/zone/objects/creature/ai/AiAgent.idl():  		homeLocation.setCell(cell);
	(&homeLocation)->setCell(cell);
	// server/zone/objects/creature/ai/AiAgent.idl():  		homeLocation.setReached(true);
	(&homeLocation)->setReached(true);
}

void AiAgentImplementation::setRespawnTimer(float resp) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		respawnTimer = resp;
	respawnTimer = resp;
}

void AiAgentImplementation::setRandomRespawn(bool resp) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		randomRespawn = resp;
	randomRespawn = resp;
}

void AiAgentImplementation::resetRespawnCounter() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		respawnCounter = 0;
	respawnCounter = 0;
}

void AiAgentImplementation::setOblivious() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			setFollowState(OBLIVIOUS);
	setFollowState(OBLIVIOUS);
	// server/zone/objects/creature/ai/AiAgent.idl():  			setTargetObject(null);
	setTargetObject(NULL);
	// server/zone/objects/creature/ai/AiAgent.idl():  			clearState(CreatureState.PEACE);
	clearState(CreatureState::PEACE);
}
}

void AiAgentImplementation::setWatchObject(SceneObject* obj) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			setFollowState(
	if (_this.get()->isRetreating())	// server/zone/objects/creature/ai/AiAgent.idl():  				return;
	return;
	// server/zone/objects/creature/ai/AiAgent.idl():  			setFollowState(WATCHING);
	setFollowState(WATCHING);
	// server/zone/objects/creature/ai/AiAgent.idl():  			setTargetObject(obj);
	setTargetObject(obj);
}
}

void AiAgentImplementation::setStalkObject(SceneObject* obj) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			setFollowState(
	if (_this.get()->isRetreating())	// server/zone/objects/creature/ai/AiAgent.idl():  				return;
	return;
	// server/zone/objects/creature/ai/AiAgent.idl():  			setFollowState(STALKING);
	setFollowState(STALKING);
	// server/zone/objects/creature/ai/AiAgent.idl():  			setTargetObject(obj);
	setTargetObject(obj);
}
}

void AiAgentImplementation::setFollowObject(SceneObject* obj) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			setFollowState(
	if (_this.get()->isRetreating())	// server/zone/objects/creature/ai/AiAgent.idl():  				return;
	return;
	// server/zone/objects/creature/ai/AiAgent.idl():  			setFollowState(FOLLOWING);
	setFollowState(FOLLOWING);
	// server/zone/objects/creature/ai/AiAgent.idl():  			setTargetObject(obj);
	setTargetObject(obj);
}
}

void AiAgentImplementation::setTargetObject(SceneObject* obj) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
	if (followObject != obj){
	// server/zone/objects/creature/ai/AiAgent.idl():  				clearPatrolPoints();
	clearPatrolPoints();
	// server/zone/objects/creature/ai/AiAgent.idl():  				followObject = obj;
	followObject = obj;
}
}
}

ManagedWeakReference<SceneObject* > AiAgentImplementation::getFollowObject() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return followObject;
	return followObject;
}

void AiAgentImplementation::storeFollowObject() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			followStore = followObject;
	followStore = followObject;
}
}

unsigned int AiAgentImplementation::getFollowState() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return followState;
	return followState;
}

void AiAgentImplementation::setFollowState(int state) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			int oldState = followState;
	int oldState = followState;
	// server/zone/objects/creature/ai/AiAgent.idl():  			clearPatrolPoints();
	clearPatrolPoints();
	// server/zone/objects/creature/ai/AiAgent.idl():  			followState = state;
	followState = state;
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
	if (oldState == LEASHING || state == LEASHING)	// server/zone/objects/creature/ai/AiAgent.idl():  				broadcastPvpStatusBitmask();
	broadcastPvpStatusBitmask();
}
}

void AiAgentImplementation::setWait(int wait) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		waitTime = wait;
	waitTime = wait;
	// server/zone/objects/creature/ai/AiAgent.idl():  	}
	if (waitTime != 0)	// server/zone/objects/creature/ai/AiAgent.idl():  			waiting = true;
	waiting = true;
}

int AiAgentImplementation::getWait() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return waitTime;
	return waitTime;
}

bool AiAgentImplementation::isWaiting() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return waiting;
	return waiting;
}

void AiAgentImplementation::stopWaiting() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		waiting = false;
	waiting = false;
}

bool AiAgentImplementation::isRetreating() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return !homeLocation.isReached();
	return !(&homeLocation)->isReached();
}

bool AiAgentImplementation::isFleeing() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getFollowState() == FLEEING;
	return getFollowState() == FLEEING;
}

float AiAgentImplementation::getKinetic() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getKinetic());
	return getReducedResist(petDeed->getKinetic());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getKinetic());
	return getReducedResist((&npcTemplate)->get()->getKinetic());
}

float AiAgentImplementation::getEnergy() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getEnergy());
	return getReducedResist(petDeed->getEnergy());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getEnergy());
	return getReducedResist((&npcTemplate)->get()->getEnergy());
}

float AiAgentImplementation::getElectricity() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getElectric());
	return getReducedResist(petDeed->getElectric());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getElectricity());
	return getReducedResist((&npcTemplate)->get()->getElectricity());
}

float AiAgentImplementation::getStun() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getStun());
	return getReducedResist(petDeed->getStun());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getStun());
	return getReducedResist((&npcTemplate)->get()->getStun());
}

float AiAgentImplementation::getBlast() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getBlast());
	return getReducedResist(petDeed->getBlast());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getBlast());
	return getReducedResist((&npcTemplate)->get()->getBlast());
}

float AiAgentImplementation::getHeat() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getHeat());
	return getReducedResist(petDeed->getHeat());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getHeat());
	return getReducedResist((&npcTemplate)->get()->getHeat());
}

float AiAgentImplementation::getCold() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getCold());
	return getReducedResist(petDeed->getCold());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getCold());
	return getReducedResist((&npcTemplate)->get()->getCold());
}

float AiAgentImplementation::getAcid() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getAcid());
	return getReducedResist(petDeed->getAcid());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getAcid());
	return getReducedResist((&npcTemplate)->get()->getAcid());
}

float AiAgentImplementation::getLightSaber() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getSaber());
	return getReducedResist(petDeed->getSaber());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getLightSaber());
	return getReducedResist((&npcTemplate)->get()->getLightSaber());
}

float AiAgentImplementation::getReducedResist(float value) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		float 
	if (CreatureObjectImplementation::shockWounds <= 500 || value == -1){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return value;
	return value;
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		float newValue = value - (value * (super.shockWounds - 500) * 0.001);
	float newValue = value - (value * (CreatureObjectImplementation::shockWounds - 500) * 0.001);
	// server/zone/objects/creature/ai/AiAgent.idl():  		return newValue;
	return newValue;
}

bool AiAgentImplementation::isSpecialProtection(int resistType) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return petDeed.isSpecialResist(resistType);
	return petDeed->isSpecialResist(resistType);
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return false;
	return false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().isSpecialProtection(resistType);
	return (&npcTemplate)->get()->isSpecialProtection(resistType);
}

bool AiAgentImplementation::isStalker() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return false;
	return false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().isStalker();
	return (&npcTemplate)->get()->isStalker();
}

bool AiAgentImplementation::isKiller() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return false;
	return false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().isKiller();
	return (&npcTemplate)->get()->isKiller();
}

unsigned int AiAgentImplementation::getFerocity() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getFerocity();
	return (&npcTemplate)->get()->getFerocity();
}

int AiAgentImplementation::getAggroRadius() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getAggroRadius();
	return (&npcTemplate)->get()->getAggroRadius();
}

unsigned int AiAgentImplementation::getArmor() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return petDeed.getArmor();
	return petDeed->getArmor();
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getArmor();
	return (&npcTemplate)->get()->getArmor();
}

bool AiAgentImplementation::getDespawnOnNoPlayerInRange() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return despawnOnNoPlayerInRange;
	return despawnOnNoPlayerInRange;
}

int AiAgentImplementation::getNumberOfPlayersInRange() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return numberOfPlayersInRange.get();
	return (&numberOfPlayersInRange)->get();
}

String AiAgentImplementation::getFactionString() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getFaction();
	return (&npcTemplate)->get()->getFaction();
}

String AiAgentImplementation::getSocialGroup() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getSocialGroup();
	return (&npcTemplate)->get()->getSocialGroup();
}

float AiAgentImplementation::getChanceHit() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return petDeed.getHitChance();
	return petDeed->getHitChance();
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getChanceHit();
	return (&npcTemplate)->get()->getChanceHit();
}

int AiAgentImplementation::getDamageMin() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getWeapon().getMinDamage();
	return getWeapon()->getMinDamage();
}

int AiAgentImplementation::getDamageMax() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getWeapon().getMaxDamage();
	return getWeapon()->getMaxDamage();
}

float AiAgentImplementation::getSpecialDamageMult() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 1.f;
	return 1.f;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getSpecialDamageMult();
	return (&npcTemplate)->get()->getSpecialDamageMult();
}

int AiAgentImplementation::getBaseXp() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return 100;
	return 100;
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL || isEventMob())	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getBaseXp();
	return (&npcTemplate)->get()->getBaseXp();
}

unsigned int AiAgentImplementation::getDiet() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getDiet();
	return (&npcTemplate)->get()->getDiet();
}

unsigned int AiAgentImplementation::getTemplateLevel() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return petDeed.getLevel();
	return petDeed->getLevel();
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 1;
	return 1;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getLevel();
	return (&npcTemplate)->get()->getLevel();
}

float AiAgentImplementation::getTame() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed != NULL){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return 1;
	return 1;
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getTame();
	return (&npcTemplate)->get()->getTame();
}

CreatureAttackMap* AiAgentImplementation::getAttackMap() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
	if (getWeapon() == readyWeapon){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return attackMap;
	return attackMap;
}

	else {
	// server/zone/objects/creature/ai/AiAgent.idl():  			return defaultAttackMap;
	return defaultAttackMap;
}
}

LootGroupCollection* AiAgentImplementation::getLootGroups() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL || isEventMob())	// server/zone/objects/creature/ai/AiAgent.idl():  			return null;
	return NULL;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getLootGroups();
	return (&npcTemplate)->get()->getLootGroups();
}

String AiAgentImplementation::getReactionStf() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getReactionStf();
	return (&npcTemplate)->get()->getReactionStf();
}

float AiAgentImplementation::getRespawnTimer() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return respawnTimer;
	return respawnTimer;
}

bool AiAgentImplementation::getRandomRespawn() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return randomRespawn;
	return randomRespawn;
}

int AiAgentImplementation::getRespawnCounter() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return respawnCounter;
	return respawnCounter;
}

PatrolPoint* AiAgentImplementation::getHomeLocation() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return homeLocation;
	return (&homeLocation);
}

bool AiAgentImplementation::isAiAgent() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return true;
	return true;
}

CreatureTemplate* AiAgentImplementation::getCreatureTemplate() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get();
	return (&npcTemplate)->get();
}

void AiAgentImplementation::setShowNextPosition(bool val) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		showNextMovementPosition = val;
	showNextMovementPosition = val;
}

bool AiAgentImplementation::isPet() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return (getControlDevice() != null);
	return (getControlDevice() != NULL);
}

unsigned int AiAgentImplementation::getCurrentBehavior() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return currentBehaviorID;
	return currentBehaviorID;
}

void AiAgentImplementation::setHomeObject(SceneObject* home) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		homeObject = home;
	homeObject = home;
}

ManagedWeakReference<SceneObject* > AiAgentImplementation::getHomeObject() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return homeObject;
	return homeObject;
}

int AiAgentImplementation::getCreatureBitmask() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return creatureBitmask;
	return creatureBitmask;
}

void AiAgentImplementation::setCreatureBitmask(int mask) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		creatureBitmask = mask;
	creatureBitmask = mask;
}

Time* AiAgentImplementation::getAlertedTime() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return alertedTime;
	return (&alertedTime);
}

void AiAgentImplementation::incrementLuaCall(const String& key) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		trackingTask.incrementCall(key);
	trackingTask->incrementCall(key);
}

void AiAgentImplementation::addToLuaTime(const String& key, unsigned long long val) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		trackingTask.addTime(key, val);
	trackingTask->addTime(key, val);
}

void AiAgentImplementation::outputLuaTimes(CreatureObject* caller) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		trackingTask.outputTimes(caller);
	trackingTask->outputTimes(caller);
}

void AiAgentImplementation::rescheduleTrackingTask() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (trackingTask == NULL){
	Reference<AiTrackingTask*> _ref0;
	// server/zone/objects/creature/ai/AiAgent.idl():  			trackingTask = new AiTrackingTask(this);
	trackingTask = _ref0 = new AiTrackingTask(_this.get());
	// server/zone/objects/creature/ai/AiAgent.idl():  			trackingTask.schedule(300000);
	trackingTask->schedule(300000);
}
	// server/zone/objects/creature/ai/AiAgent.idl():  	}
	if (!trackingTask->isScheduled()){
	// server/zone/objects/creature/ai/AiAgent.idl():  			trackingTask.schedule(300000);
	trackingTask->schedule(300000);
}
}

void AiAgentImplementation::setPetDeed(PetDeed* deed) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		petDeed = deed;
	petDeed = deed;
}

bool AiAgentImplementation::hasPetDeed() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return petDeed != null;
	return petDeed != NULL;
}

PetDeed* AiAgentImplementation::getPetDeed() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return petDeed;
	return petDeed;
}

bool AiAgentImplementation::hasReactionChatMessages() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReactionStf() != "";
	return getReactionStf() != "";
}

int AiAgentImplementation::getReactionRank() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return reactionRank;
	return reactionRank;
}

void AiAgentImplementation::setReactionRank(int rank) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		reactionRank = rank;
	reactionRank = rank;
}

int AiAgentImplementation::getHamMaximum() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getBaseHAMmax();
	return (&npcTemplate)->get()->getBaseHAMmax();
}

int AiAgentImplementation::getHamBase() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getBaseHAM();
	return (&npcTemplate)->get()->getBaseHAM();
}

unsigned int AiAgentImplementation::getConvoTemplateCRC() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return convoTemplateCRC;
	return convoTemplateCRC;
}

void AiAgentImplementation::setLairTemplateCRC(unsigned int crc) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		lairTemplateCRC = crc;
	lairTemplateCRC = crc;
}

unsigned int AiAgentImplementation::getLairTemplateCRC() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return lairTemplateCRC;
	return lairTemplateCRC;
}

/*
 *	AiAgentAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


AiAgentAdapter::AiAgentAdapter(AiAgent* obj) : CreatureObjectAdapter(obj) {
}

void AiAgentAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_FINALIZE__:
		{
			
			finalize();
			
		}
		break;
	case RPC_ACTIVATERECOVERY__:
		{
			
			activateRecovery();
			
		}
		break;
	case RPC_ACTIVATEMOVEMENTEVENT__:
		{
			
			activateMovementEvent();
			
		}
		break;
	case RPC_ACTIVATEWAITEVENT__:
		{
			
			activateWaitEvent();
			
		}
		break;
	case RPC_ACTIVATEAWARENESSEVENT__LONG_:
		{
			unsigned long long delay = inv->getUnsignedLongParameter();
			
			activateAwarenessEvent(delay);
			
		}
		break;
	case RPC_ACTIVATEINTERRUPT__SCENEOBJECT_LONG_:
		{
			SceneObject* source = static_cast<SceneObject*>(inv->getObjectParameter());
			long long msg = inv->getSignedLongParameter();
			
			activateInterrupt(source, msg);
			
		}
		break;
	case RPC_ACTIVATELOAD__STRING_:
		{
			 String temp; inv->getAsciiParameter(temp);
			
			activateLoad(temp);
			
		}
		break;
	case RPC_DORECOVERY__INT_:
		{
			int latency = inv->getSignedIntParameter();
			
			doRecovery(latency);
			
		}
		break;
	case RPC_DOMOVEMENT__:
		{
			
			doMovement();
			
		}
		break;
	case RPC_SETLEVEL__INT_BOOL_:
		{
			int lvl = inv->getSignedIntParameter();
			bool randomHam = inv->getBooleanParameter();
			
			setLevel(lvl, randomHam);
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_CALCULATEATTACKMINDAMAGE__INT_:
		{
			int level = inv->getSignedIntParameter();
			
			int _m_res = calculateAttackMinDamage(level);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CALCULATEATTACKMAXDAMAGE__INT_:
		{
			int level = inv->getSignedIntParameter();
			
			int _m_res = calculateAttackMaxDamage(level);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CALCULATEATTACKSPEED__INT_:
		{
			int level = inv->getSignedIntParameter();
			
			float _m_res = calculateAttackSpeed(level);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETTARGETFROMMAP__:
		{
			
			DistributedObject* _m_res = getTargetFromMap();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETTARGETFROMDEFENDERS__:
		{
			
			DistributedObject* _m_res = getTargetFromDefenders();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETTARGETFROMTARGETSDEFENDERS__:
		{
			
			DistributedObject* _m_res = getTargetFromTargetsDefenders();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_VALIDATETARGET__:
		{
			
			bool _m_res = validateTarget();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_VALIDATETARGET__SCENEOBJECT_:
		{
			SceneObject* target = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = validateTarget(target);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCAMOUFLAGED__CREATUREOBJECT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isCamouflaged(target);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_FINDNEXTPOSITION__FLOAT_BOOL_:
		{
			float maxDistance = inv->getFloatParameter();
			bool walk = inv->getBooleanParameter();
			
			bool _m_res = findNextPosition(maxDistance, walk);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			byte selectedID = inv->getByteParameter();
			
			int _m_res = handleObjectMenuSelect(player, selectedID);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CHECKNEWANGLE__:
		{
			
			checkNewAngle();
			
		}
		break;
	case RPC_FILLATTRIBUTELIST__ATTRIBUTELISTMESSAGE_CREATUREOBJECT_:
		{
			AttributeListMessage* msg = static_cast<AttributeListMessage*>(inv->getObjectParameter());
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			fillAttributeList(msg, object);
			
		}
		break;
	case RPC_SETNEXTPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_:
		{
			float x = inv->getFloatParameter();
			float z = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			CellObject* cell = static_cast<CellObject*>(inv->getObjectParameter());
			
			setNextPosition(x, z, y, cell);
			
		}
		break;
	case RPC_SETNEXTSTEPPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_:
		{
			float x = inv->getFloatParameter();
			float z = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			CellObject* cell = static_cast<CellObject*>(inv->getObjectParameter());
			
			setNextStepPosition(x, z, y, cell);
			
		}
		break;
	case RPC_NOTIFYPOSITIONUPDATE__QUADTREEENTRY_:
		{
			QuadTreeEntry* entry = static_cast<QuadTreeEntry*>(inv->getObjectParameter());
			
			notifyPositionUpdate(entry);
			
		}
		break;
	case RPC_CLEARPATROLPOINTS__:
		{
			
			clearPatrolPoints();
			
		}
		break;
	case RPC_CLEARSAVEDPATROLPOINTS__:
		{
			
			clearSavedPatrolPoints();
			
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			float damage = inv->getFloatParameter();
			bool destroy = inv->getBooleanParameter();
			bool notifyClient = inv->getBooleanParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			float damage = inv->getFloatParameter();
			bool destroy = inv->getBooleanParameter();
			 String xp; inv->getAsciiParameter(xp);
			bool notifyClient = inv->getBooleanParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ADDDOTSTATE__CREATUREOBJECT_LONG_LONG_INT_BYTE_INT_FLOAT_INT_INT_:
		{
			CreatureObject* attacker = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long dotType = inv->getUnsignedLongParameter();
			unsigned long long objectID = inv->getUnsignedLongParameter();
			unsigned int strength = inv->getUnsignedIntParameter();
			byte type = inv->getByteParameter();
			unsigned int duration = inv->getUnsignedIntParameter();
			float potency = inv->getFloatParameter();
			unsigned int defense = inv->getUnsignedIntParameter();
			int secondaryStrength = inv->getSignedIntParameter();
			
			int _m_res = addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = sendConversationStartTo(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SENDDEFAULTCONVERSATIONTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendDefaultConversationTo(player);
			
		}
		break;
	case RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_:
		{
			int option = inv->getSignedIntParameter();
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			selectConversationOption(option, obj);
			
		}
		break;
	case RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int condition = inv->getSignedIntParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = notifyObjectDestructionObservers(attacker, condition, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYCONVERSEOBSERVERS__CREATUREOBJECT_:
		{
			CreatureObject* converser = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			int _m_res = notifyConverseObservers(converser);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYATTACK__OBSERVABLE_:
		{
			Observable* observable = static_cast<Observable*>(inv->getObjectParameter());
			
			int _m_res = notifyAttack(observable);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYCALLFORHELP__OBSERVABLE_MANAGEDOBJECT_:
		{
			Observable* observable = static_cast<Observable*>(inv->getObjectParameter());
			ManagedObject* arg1 = static_cast<ManagedObject*>(inv->getObjectParameter());
			
			int _m_res = notifyCallForHelp(observable, arg1);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_DESTROYOBJECTFROMWORLD__BOOL_:
		{
			bool sendSelfDestroy = inv->getBooleanParameter();
			
			destroyObjectFromWorld(sendSelfDestroy);
			
		}
		break;
	case RPC_DESTROYOBJECTFROMDATABASE__BOOL_:
		{
			bool destroyContainedObjects = inv->getBooleanParameter();
			
			destroyObjectFromDatabase(destroyContainedObjects);
			
		}
		break;
	case RPC_ACTIVATEPOSTURERECOVERY__:
		{
			
			activatePostureRecovery();
			
		}
		break;
	case RPC_ACTIVATEHAMREGENERATION__INT_:
		{
			int latency = inv->getSignedIntParameter();
			
			activateHAMRegeneration(latency);
			
		}
		break;
	case RPC_QUEUEDIZZYFALLEVENT__:
		{
			
			queueDizzyFallEvent();
			
		}
		break;
	case RPC_CLEARCOMBATSTATE__BOOL_:
		{
			bool clearDefenders = inv->getBooleanParameter();
			
			clearCombatState(clearDefenders);
			
		}
		break;
	case RPC_SETDEFENDER__SCENEOBJECT_:
		{
			SceneObject* defender = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setDefender(defender);
			
		}
		break;
	case RPC_ADDDEFENDER__SCENEOBJECT_:
		{
			SceneObject* defender = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addDefender(defender);
			
		}
		break;
	case RPC_REMOVEDEFENDER__SCENEOBJECT_:
		{
			SceneObject* defender = static_cast<SceneObject*>(inv->getObjectParameter());
			
			removeDefender(defender);
			
		}
		break;
	case RPC_SETDESPAWNONNOPLAYERINRANGE__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setDespawnOnNoPlayerInRange(val);
			
		}
		break;
	case RPC_NOTIFYDESPAWN__ZONE_:
		{
			Zone* zone = static_cast<Zone*>(inv->getObjectParameter());
			
			notifyDespawn(zone);
			
		}
		break;
	case RPC_SCHEDULEDESPAWN__:
		{
			
			scheduleDespawn();
			
		}
		break;
	case RPC_SCHEDULEDESPAWN__INT_:
		{
			int timeToDespawn = inv->getSignedIntParameter();
			
			scheduleDespawn(timeToDespawn);
			
		}
		break;
	case RPC_RESPAWN__ZONE_INT_:
		{
			Zone* zone = static_cast<Zone*>(inv->getObjectParameter());
			int level = inv->getSignedIntParameter();
			
			respawn(zone, level);
			
		}
		break;
	case RPC_SETHOMELOCATION__FLOAT_FLOAT_FLOAT_CELLOBJECT_:
		{
			float x = inv->getFloatParameter();
			float z = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			CellObject* cell = static_cast<CellObject*>(inv->getObjectParameter());
			
			setHomeLocation(x, z, y, cell);
			
		}
		break;
	case RPC_SETRESPAWNTIMER__FLOAT_:
		{
			float resp = inv->getFloatParameter();
			
			setRespawnTimer(resp);
			
		}
		break;
	case RPC_SETRANDOMRESPAWN__BOOL_:
		{
			bool resp = inv->getBooleanParameter();
			
			setRandomRespawn(resp);
			
		}
		break;
	case RPC_RESETRESPAWNCOUNTER__:
		{
			
			resetRespawnCounter();
			
		}
		break;
	case RPC_ISATTACKABLEBY__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAttackableBy(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISATTACKABLEBY__TANGIBLEOBJECT_:
		{
			TangibleObject* object = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			bool _m_res = isAttackableBy(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISAGGRESSIVETO__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAggressiveTo(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETOBLIVIOUS__:
		{
			
			setOblivious();
			
		}
		break;
	case RPC_SETWATCHOBJECT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setWatchObject(obj);
			
		}
		break;
	case RPC_SETSTALKOBJECT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setStalkObject(obj);
			
		}
		break;
	case RPC_SETFOLLOWOBJECT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setFollowObject(obj);
			
		}
		break;
	case RPC_SETTARGETOBJECT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setTargetObject(obj);
			
		}
		break;
	case RPC_RUNAWAY__CREATUREOBJECT_FLOAT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			float range = inv->getFloatParameter();
			
			runAway(target, range);
			
		}
		break;
	case RPC_LEASH__:
		{
			
			leash();
			
		}
		break;
	case RPC_GENERATEPATROL__INT_FLOAT_:
		{
			int num = inv->getSignedIntParameter();
			float dist = inv->getFloatParameter();
			
			bool _m_res = generatePatrol(num, dist);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETFOLLOWOBJECT__:
		{
			
			DistributedObject* _m_res = getFollowObject().get();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_STOREFOLLOWOBJECT__:
		{
			
			storeFollowObject();
			
		}
		break;
	case RPC_RESTOREFOLLOWOBJECT__:
		{
			
			restoreFollowObject();
			
		}
		break;
	case RPC_GETFOLLOWSTATE__:
		{
			
			unsigned int _m_res = getFollowState();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETFOLLOWSTATE__INT_:
		{
			int state = inv->getSignedIntParameter();
			
			setFollowState(state);
			
		}
		break;
	case RPC_GETMAXDISTANCE__:
		{
			
			float _m_res = getMaxDistance();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETDESTINATION__:
		{
			
			int _m_res = setDestination();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_COMPLETEMOVE__:
		{
			
			bool _m_res = completeMove();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETWAIT__INT_:
		{
			int wait = inv->getSignedIntParameter();
			
			setWait(wait);
			
		}
		break;
	case RPC_GETWAIT__:
		{
			
			int _m_res = getWait();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISWAITING__:
		{
			
			bool _m_res = isWaiting();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_STOPWAITING__:
		{
			
			stopWaiting();
			
		}
		break;
	case RPC_SELECTWEAPON__:
		{
			
			selectWeapon();
			
		}
		break;
	case RPC_SELECTDEFAULTWEAPON__:
		{
			
			selectDefaultWeapon();
			
		}
		break;
	case RPC_VALIDATESTATEATTACK__CREATUREOBJECT_INT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			
			bool _m_res = validateStateAttack(target, actionCRC);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SELECTSPECIALATTACK__:
		{
			
			selectSpecialAttack();
			
		}
		break;
	case RPC_SELECTSPECIALATTACK__INT_:
		{
			int attackNum = inv->getSignedIntParameter();
			
			selectSpecialAttack(attackNum);
			
		}
		break;
	case RPC_SELECTDEFAULTATTACK__:
		{
			
			selectDefaultAttack();
			
		}
		break;
	case RPC_VALIDATESTATEATTACK__:
		{
			
			bool _m_res = validateStateAttack();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ENQUEUEATTACK__INT_:
		{
			int priority = inv->getSignedIntParameter();
			
			enqueueAttack(priority);
			
		}
		break;
	case RPC_ISRETREATING__:
		{
			
			bool _m_res = isRetreating();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISFLEEING__:
		{
			
			bool _m_res = isFleeing();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARDESPAWNEVENT__:
		{
			
			clearDespawnEvent();
			
		}
		break;
	case RPC_GETKINETIC__:
		{
			
			float _m_res = getKinetic();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETENERGY__:
		{
			
			float _m_res = getEnergy();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETELECTRICITY__:
		{
			
			float _m_res = getElectricity();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETSTUN__:
		{
			
			float _m_res = getStun();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBLAST__:
		{
			
			float _m_res = getBlast();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHEAT__:
		{
			
			float _m_res = getHeat();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCOLD__:
		{
			
			float _m_res = getCold();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETACID__:
		{
			
			float _m_res = getAcid();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETLIGHTSABER__:
		{
			
			float _m_res = getLightSaber();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_ISSPECIALPROTECTION__INT_:
		{
			int resistType = inv->getSignedIntParameter();
			
			bool _m_res = isSpecialProtection(resistType);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSTALKER__:
		{
			
			bool _m_res = isStalker();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISKILLER__:
		{
			
			bool _m_res = isKiller();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETFEROCITY__:
		{
			
			unsigned int _m_res = getFerocity();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETAGGRORADIUS__:
		{
			
			int _m_res = getAggroRadius();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETARMOR__:
		{
			
			unsigned int _m_res = getArmor();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETDESPAWNONNOPLAYERINRANGE__:
		{
			
			bool _m_res = getDespawnOnNoPlayerInRange();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETNUMBEROFPLAYERSINRANGE__:
		{
			
			int _m_res = getNumberOfPlayersInRange();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFACTIONSTRING__:
		{
			
			String _m_res = getFactionString();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETSOCIALGROUP__:
		{
			
			String _m_res = getSocialGroup();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETCHANCEHIT__:
		{
			
			float _m_res = getChanceHit();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETDAMAGEMIN__:
		{
			
			int _m_res = getDamageMin();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDAMAGEMAX__:
		{
			
			int _m_res = getDamageMax();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSPECIALDAMAGEMULT__:
		{
			
			float _m_res = getSpecialDamageMult();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBASEXP__:
		{
			
			int _m_res = getBaseXp();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDIET__:
		{
			
			unsigned int _m_res = getDiet();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETTEMPLATELEVEL__:
		{
			
			unsigned int _m_res = getTemplateLevel();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETTAME__:
		{
			
			float _m_res = getTame();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETREACTIONSTF__:
		{
			
			String _m_res = getReactionStf();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETRESPAWNTIMER__:
		{
			
			float _m_res = getRespawnTimer();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETRANDOMRESPAWN__:
		{
			
			bool _m_res = getRandomRespawn();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETRESPAWNCOUNTER__:
		{
			
			int _m_res = getRespawnCounter();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISAIAGENT__:
		{
			
			bool _m_res = isAiAgent();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASLOOT__:
		{
			
			bool _m_res = hasLoot();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETSHOWNEXTPOSITION__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setShowNextPosition(val);
			
		}
		break;
	case RPC_ISEVENTMOB__:
		{
			
			bool _m_res = isEventMob();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPET__:
		{
			
			bool _m_res = isPet();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETCURRENTBEHAVIOR__:
		{
			
			unsigned int _m_res = getCurrentBehavior();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETHOMEOBJECT__SCENEOBJECT_:
		{
			SceneObject* home = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setHomeObject(home);
			
		}
		break;
	case RPC_SETCOMBATSTATE__:
		{
			
			setCombatState();
			
		}
		break;
	case RPC_GETCREATUREBITMASK__:
		{
			
			int _m_res = getCreatureBitmask();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETCREATUREBITMASK__INT_:
		{
			int mask = inv->getSignedIntParameter();
			
			setCreatureBitmask(mask);
			
		}
		break;
	case RPC_SETCREATUREBIT__INT_:
		{
			unsigned int option = inv->getUnsignedIntParameter();
			
			setCreatureBit(option);
			
		}
		break;
	case RPC_CLEARCREATUREBIT__INT_:
		{
			unsigned int option = inv->getUnsignedIntParameter();
			
			clearCreatureBit(option);
			
		}
		break;
	case RPC_INCREMENTLUACALL__STRING_:
		{
			 String key; inv->getAsciiParameter(key);
			
			incrementLuaCall(key);
			
		}
		break;
	case RPC_ADDTOLUATIME__STRING_LONG_:
		{
			 String key; inv->getAsciiParameter(key);
			unsigned long long val = inv->getUnsignedLongParameter();
			
			addToLuaTime(key, val);
			
		}
		break;
	case RPC_OUTPUTLUATIMES__CREATUREOBJECT_:
		{
			CreatureObject* caller = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			outputLuaTimes(caller);
			
		}
		break;
	case RPC_RESCHEDULETRACKINGTASK__:
		{
			
			rescheduleTrackingTask();
			
		}
		break;
	case RPC_HASRANGEDWEAPON__:
		{
			
			bool _m_res = hasRangedWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETUSERANGED__:
		{
			
			bool _m_res = getUseRanged();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASSPECIALATTACK__INT_:
		{
			int num = inv->getSignedIntParameter();
			
			bool _m_res = hasSpecialAttack(num);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETPETDEED__PETDEED_:
		{
			PetDeed* deed = static_cast<PetDeed*>(inv->getObjectParameter());
			
			setPetDeed(deed);
			
		}
		break;
	case RPC_HASPETDEED__:
		{
			
			bool _m_res = hasPetDeed();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPETDEED__:
		{
			
			DistributedObject* _m_res = getPetDeed();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_SENDREACTIONCHAT__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int state = inv->getSignedIntParameter();
			bool force = inv->getBooleanParameter();
			
			sendReactionChat(type, state, force);
			
		}
		break;
	case RPC_HASREACTIONCHATMESSAGES__:
		{
			
			bool _m_res = hasReactionChatMessages();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPERSONALITYSTF__:
		{
			
			String _m_res = getPersonalityStf();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETREACTIONRANK__:
		{
			
			int _m_res = getReactionRank();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETREACTIONRANK__INT_:
		{
			int rank = inv->getSignedIntParameter();
			
			setReactionRank(rank);
			
		}
		break;
	case RPC_GETHAMMAXIMUM__:
		{
			
			int _m_res = getHamMaximum();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETHAMBASE__:
		{
			
			int _m_res = getHamBase();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMAXHAM__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setMaxHAM(type, value, notifyClient);
			
		}
		break;
	case RPC_RELOADTEMPLATE__:
		{
			
			reloadTemplate();
			
		}
		break;
	case RPC_GETCONVOTEMPLATECRC__:
		{
			
			unsigned int _m_res = getConvoTemplateCRC();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETCONVOTEMPLATE__STRING_:
		{
			 String templateString; inv->getAsciiParameter(templateString);
			
			setConvoTemplate(templateString);
			
		}
		break;
	case RPC_SETLAIRTEMPLATECRC__INT_:
		{
			unsigned int crc = inv->getUnsignedIntParameter();
			
			setLairTemplateCRC(crc);
			
		}
		break;
	case RPC_GETLAIRTEMPLATECRC__:
		{
			
			unsigned int _m_res = getLairTemplateCRC();
			resp->insertInt(_m_res);
		}
		break;
	default:
		CreatureObjectAdapter::invokeMethod(methid, inv);
	}
}

void AiAgentAdapter::initializeTransientMembers() {
	(static_cast<AiAgent*>(stub))->initializeTransientMembers();
}

void AiAgentAdapter::notifyLoadFromDatabase() {
	(static_cast<AiAgent*>(stub))->notifyLoadFromDatabase();
}

void AiAgentAdapter::finalize() {
	(static_cast<AiAgent*>(stub))->finalize();
}

void AiAgentAdapter::activateRecovery() {
	(static_cast<AiAgent*>(stub))->activateRecovery();
}

void AiAgentAdapter::activateMovementEvent() {
	(static_cast<AiAgent*>(stub))->activateMovementEvent();
}

void AiAgentAdapter::activateWaitEvent() {
	(static_cast<AiAgent*>(stub))->activateWaitEvent();
}

void AiAgentAdapter::activateAwarenessEvent(unsigned long long delay) {
	(static_cast<AiAgent*>(stub))->activateAwarenessEvent(delay);
}

void AiAgentAdapter::activateInterrupt(SceneObject* source, long long msg) {
	(static_cast<AiAgent*>(stub))->activateInterrupt(source, msg);
}

void AiAgentAdapter::activateLoad(const String& temp) {
	(static_cast<AiAgent*>(stub))->activateLoad(temp);
}

void AiAgentAdapter::doRecovery(int latency) {
	(static_cast<AiAgent*>(stub))->doRecovery(latency);
}

void AiAgentAdapter::doMovement() {
	(static_cast<AiAgent*>(stub))->doMovement();
}

void AiAgentAdapter::setLevel(int lvl, bool randomHam) {
	(static_cast<AiAgent*>(stub))->setLevel(lvl, randomHam);
}

void AiAgentAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<AiAgent*>(stub))->sendBaselinesTo(player);
}

int AiAgentAdapter::calculateAttackMinDamage(int level) {
	return (static_cast<AiAgent*>(stub))->calculateAttackMinDamage(level);
}

int AiAgentAdapter::calculateAttackMaxDamage(int level) {
	return (static_cast<AiAgent*>(stub))->calculateAttackMaxDamage(level);
}

float AiAgentAdapter::calculateAttackSpeed(int level) {
	return (static_cast<AiAgent*>(stub))->calculateAttackSpeed(level);
}

SceneObject* AiAgentAdapter::getTargetFromMap() {
	return (static_cast<AiAgent*>(stub))->getTargetFromMap();
}

SceneObject* AiAgentAdapter::getTargetFromDefenders() {
	return (static_cast<AiAgent*>(stub))->getTargetFromDefenders();
}

SceneObject* AiAgentAdapter::getTargetFromTargetsDefenders() {
	return (static_cast<AiAgent*>(stub))->getTargetFromTargetsDefenders();
}

bool AiAgentAdapter::validateTarget() {
	return (static_cast<AiAgent*>(stub))->validateTarget();
}

bool AiAgentAdapter::validateTarget(SceneObject* target) {
	return (static_cast<AiAgent*>(stub))->validateTarget(target);
}

bool AiAgentAdapter::isCamouflaged(CreatureObject* target) {
	return (static_cast<AiAgent*>(stub))->isCamouflaged(target);
}

bool AiAgentAdapter::findNextPosition(float maxDistance, bool walk) {
	return (static_cast<AiAgent*>(stub))->findNextPosition(maxDistance, walk);
}

int AiAgentAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<AiAgent*>(stub))->handleObjectMenuSelect(player, selectedID);
}

void AiAgentAdapter::checkNewAngle() {
	(static_cast<AiAgent*>(stub))->checkNewAngle();
}

void AiAgentAdapter::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	(static_cast<AiAgent*>(stub))->fillAttributeList(msg, object);
}

void AiAgentAdapter::setNextPosition(float x, float z, float y, CellObject* cell) {
	(static_cast<AiAgent*>(stub))->setNextPosition(x, z, y, cell);
}

void AiAgentAdapter::setNextStepPosition(float x, float z, float y, CellObject* cell) {
	(static_cast<AiAgent*>(stub))->setNextStepPosition(x, z, y, cell);
}

void AiAgentAdapter::notifyPositionUpdate(QuadTreeEntry* entry) {
	(static_cast<AiAgent*>(stub))->notifyPositionUpdate(entry);
}

void AiAgentAdapter::clearPatrolPoints() {
	(static_cast<AiAgent*>(stub))->clearPatrolPoints();
}

void AiAgentAdapter::clearSavedPatrolPoints() {
	(static_cast<AiAgent*>(stub))->clearSavedPatrolPoints();
}

int AiAgentAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction) {
	return (static_cast<AiAgent*>(stub))->inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
}

int AiAgentAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction) {
	return (static_cast<AiAgent*>(stub))->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
}

int AiAgentAdapter::addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength) {
	return (static_cast<AiAgent*>(stub))->addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
}

bool AiAgentAdapter::sendConversationStartTo(SceneObject* player) {
	return (static_cast<AiAgent*>(stub))->sendConversationStartTo(player);
}

void AiAgentAdapter::sendDefaultConversationTo(SceneObject* player) {
	(static_cast<AiAgent*>(stub))->sendDefaultConversationTo(player);
}

void AiAgentAdapter::selectConversationOption(int option, SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->selectConversationOption(option, obj);
}

int AiAgentAdapter::notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction) {
	return (static_cast<AiAgent*>(stub))->notifyObjectDestructionObservers(attacker, condition, isCombatAction);
}

int AiAgentAdapter::notifyConverseObservers(CreatureObject* converser) {
	return (static_cast<AiAgent*>(stub))->notifyConverseObservers(converser);
}

int AiAgentAdapter::notifyAttack(Observable* observable) {
	return (static_cast<AiAgent*>(stub))->notifyAttack(observable);
}

int AiAgentAdapter::notifyCallForHelp(Observable* observable, ManagedObject* arg1) {
	return (static_cast<AiAgent*>(stub))->notifyCallForHelp(observable, arg1);
}

void AiAgentAdapter::destroyObjectFromWorld(bool sendSelfDestroy) {
	(static_cast<AiAgent*>(stub))->destroyObjectFromWorld(sendSelfDestroy);
}

void AiAgentAdapter::destroyObjectFromDatabase(bool destroyContainedObjects) {
	(static_cast<AiAgent*>(stub))->destroyObjectFromDatabase(destroyContainedObjects);
}

void AiAgentAdapter::activatePostureRecovery() {
	(static_cast<AiAgent*>(stub))->activatePostureRecovery();
}

void AiAgentAdapter::activateHAMRegeneration(int latency) {
	(static_cast<AiAgent*>(stub))->activateHAMRegeneration(latency);
}

void AiAgentAdapter::queueDizzyFallEvent() {
	(static_cast<AiAgent*>(stub))->queueDizzyFallEvent();
}

void AiAgentAdapter::clearCombatState(bool clearDefenders) {
	(static_cast<AiAgent*>(stub))->clearCombatState(clearDefenders);
}

void AiAgentAdapter::setDefender(SceneObject* defender) {
	(static_cast<AiAgent*>(stub))->setDefender(defender);
}

void AiAgentAdapter::addDefender(SceneObject* defender) {
	(static_cast<AiAgent*>(stub))->addDefender(defender);
}

void AiAgentAdapter::removeDefender(SceneObject* defender) {
	(static_cast<AiAgent*>(stub))->removeDefender(defender);
}

void AiAgentAdapter::setDespawnOnNoPlayerInRange(bool val) {
	(static_cast<AiAgent*>(stub))->setDespawnOnNoPlayerInRange(val);
}

void AiAgentAdapter::notifyDespawn(Zone* zone) {
	(static_cast<AiAgent*>(stub))->notifyDespawn(zone);
}

void AiAgentAdapter::scheduleDespawn() {
	(static_cast<AiAgent*>(stub))->scheduleDespawn();
}

void AiAgentAdapter::scheduleDespawn(int timeToDespawn) {
	(static_cast<AiAgent*>(stub))->scheduleDespawn(timeToDespawn);
}

void AiAgentAdapter::respawn(Zone* zone, int level) {
	(static_cast<AiAgent*>(stub))->respawn(zone, level);
}

void AiAgentAdapter::setHomeLocation(float x, float z, float y, CellObject* cell) {
	(static_cast<AiAgent*>(stub))->setHomeLocation(x, z, y, cell);
}

void AiAgentAdapter::setRespawnTimer(float resp) {
	(static_cast<AiAgent*>(stub))->setRespawnTimer(resp);
}

void AiAgentAdapter::setRandomRespawn(bool resp) {
	(static_cast<AiAgent*>(stub))->setRandomRespawn(resp);
}

void AiAgentAdapter::resetRespawnCounter() {
	(static_cast<AiAgent*>(stub))->resetRespawnCounter();
}

bool AiAgentAdapter::isAttackableBy(CreatureObject* object) {
	return (static_cast<AiAgent*>(stub))->isAttackableBy(object);
}

bool AiAgentAdapter::isAttackableBy(TangibleObject* object) {
	return (static_cast<AiAgent*>(stub))->isAttackableBy(object);
}

bool AiAgentAdapter::isAggressiveTo(CreatureObject* object) {
	return (static_cast<AiAgent*>(stub))->isAggressiveTo(object);
}

void AiAgentAdapter::setOblivious() {
	(static_cast<AiAgent*>(stub))->setOblivious();
}

void AiAgentAdapter::setWatchObject(SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->setWatchObject(obj);
}

void AiAgentAdapter::setStalkObject(SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->setStalkObject(obj);
}

void AiAgentAdapter::setFollowObject(SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->setFollowObject(obj);
}

void AiAgentAdapter::setTargetObject(SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->setTargetObject(obj);
}

void AiAgentAdapter::runAway(CreatureObject* target, float range) {
	(static_cast<AiAgent*>(stub))->runAway(target, range);
}

void AiAgentAdapter::leash() {
	(static_cast<AiAgent*>(stub))->leash();
}

bool AiAgentAdapter::generatePatrol(int num, float dist) {
	return (static_cast<AiAgent*>(stub))->generatePatrol(num, dist);
}

ManagedWeakReference<SceneObject* > AiAgentAdapter::getFollowObject() {
	return (static_cast<AiAgent*>(stub))->getFollowObject();
}

void AiAgentAdapter::storeFollowObject() {
	(static_cast<AiAgent*>(stub))->storeFollowObject();
}

void AiAgentAdapter::restoreFollowObject() {
	(static_cast<AiAgent*>(stub))->restoreFollowObject();
}

unsigned int AiAgentAdapter::getFollowState() const {
	return (static_cast<AiAgent*>(stub))->getFollowState();
}

void AiAgentAdapter::setFollowState(int state) {
	(static_cast<AiAgent*>(stub))->setFollowState(state);
}

float AiAgentAdapter::getMaxDistance() {
	return (static_cast<AiAgent*>(stub))->getMaxDistance();
}

int AiAgentAdapter::setDestination() {
	return (static_cast<AiAgent*>(stub))->setDestination();
}

bool AiAgentAdapter::completeMove() {
	return (static_cast<AiAgent*>(stub))->completeMove();
}

void AiAgentAdapter::setWait(int wait) {
	(static_cast<AiAgent*>(stub))->setWait(wait);
}

int AiAgentAdapter::getWait() const {
	return (static_cast<AiAgent*>(stub))->getWait();
}

bool AiAgentAdapter::isWaiting() const {
	return (static_cast<AiAgent*>(stub))->isWaiting();
}

void AiAgentAdapter::stopWaiting() {
	(static_cast<AiAgent*>(stub))->stopWaiting();
}

void AiAgentAdapter::selectWeapon() {
	(static_cast<AiAgent*>(stub))->selectWeapon();
}

void AiAgentAdapter::selectDefaultWeapon() {
	(static_cast<AiAgent*>(stub))->selectDefaultWeapon();
}

bool AiAgentAdapter::validateStateAttack(CreatureObject* target, unsigned int actionCRC) {
	return (static_cast<AiAgent*>(stub))->validateStateAttack(target, actionCRC);
}

void AiAgentAdapter::selectSpecialAttack() {
	(static_cast<AiAgent*>(stub))->selectSpecialAttack();
}

void AiAgentAdapter::selectSpecialAttack(int attackNum) {
	(static_cast<AiAgent*>(stub))->selectSpecialAttack(attackNum);
}

void AiAgentAdapter::selectDefaultAttack() {
	(static_cast<AiAgent*>(stub))->selectDefaultAttack();
}

bool AiAgentAdapter::validateStateAttack() {
	return (static_cast<AiAgent*>(stub))->validateStateAttack();
}

void AiAgentAdapter::enqueueAttack(int priority) {
	(static_cast<AiAgent*>(stub))->enqueueAttack(priority);
}

bool AiAgentAdapter::isRetreating() {
	return (static_cast<AiAgent*>(stub))->isRetreating();
}

bool AiAgentAdapter::isFleeing() {
	return (static_cast<AiAgent*>(stub))->isFleeing();
}

void AiAgentAdapter::clearDespawnEvent() {
	(static_cast<AiAgent*>(stub))->clearDespawnEvent();
}

float AiAgentAdapter::getKinetic() {
	return (static_cast<AiAgent*>(stub))->getKinetic();
}

float AiAgentAdapter::getEnergy() {
	return (static_cast<AiAgent*>(stub))->getEnergy();
}

float AiAgentAdapter::getElectricity() {
	return (static_cast<AiAgent*>(stub))->getElectricity();
}

float AiAgentAdapter::getStun() {
	return (static_cast<AiAgent*>(stub))->getStun();
}

float AiAgentAdapter::getBlast() {
	return (static_cast<AiAgent*>(stub))->getBlast();
}

float AiAgentAdapter::getHeat() {
	return (static_cast<AiAgent*>(stub))->getHeat();
}

float AiAgentAdapter::getCold() {
	return (static_cast<AiAgent*>(stub))->getCold();
}

float AiAgentAdapter::getAcid() {
	return (static_cast<AiAgent*>(stub))->getAcid();
}

float AiAgentAdapter::getLightSaber() {
	return (static_cast<AiAgent*>(stub))->getLightSaber();
}

bool AiAgentAdapter::isSpecialProtection(int resistType) {
	return (static_cast<AiAgent*>(stub))->isSpecialProtection(resistType);
}

bool AiAgentAdapter::isStalker() {
	return (static_cast<AiAgent*>(stub))->isStalker();
}

bool AiAgentAdapter::isKiller() {
	return (static_cast<AiAgent*>(stub))->isKiller();
}

unsigned int AiAgentAdapter::getFerocity() {
	return (static_cast<AiAgent*>(stub))->getFerocity();
}

int AiAgentAdapter::getAggroRadius() {
	return (static_cast<AiAgent*>(stub))->getAggroRadius();
}

unsigned int AiAgentAdapter::getArmor() {
	return (static_cast<AiAgent*>(stub))->getArmor();
}

bool AiAgentAdapter::getDespawnOnNoPlayerInRange() const {
	return (static_cast<AiAgent*>(stub))->getDespawnOnNoPlayerInRange();
}

int AiAgentAdapter::getNumberOfPlayersInRange() {
	return (static_cast<AiAgent*>(stub))->getNumberOfPlayersInRange();
}

String AiAgentAdapter::getFactionString() {
	return (static_cast<AiAgent*>(stub))->getFactionString();
}

String AiAgentAdapter::getSocialGroup() {
	return (static_cast<AiAgent*>(stub))->getSocialGroup();
}

float AiAgentAdapter::getChanceHit() {
	return (static_cast<AiAgent*>(stub))->getChanceHit();
}

int AiAgentAdapter::getDamageMin() {
	return (static_cast<AiAgent*>(stub))->getDamageMin();
}

int AiAgentAdapter::getDamageMax() {
	return (static_cast<AiAgent*>(stub))->getDamageMax();
}

float AiAgentAdapter::getSpecialDamageMult() {
	return (static_cast<AiAgent*>(stub))->getSpecialDamageMult();
}

int AiAgentAdapter::getBaseXp() {
	return (static_cast<AiAgent*>(stub))->getBaseXp();
}

unsigned int AiAgentAdapter::getDiet() {
	return (static_cast<AiAgent*>(stub))->getDiet();
}

unsigned int AiAgentAdapter::getTemplateLevel() {
	return (static_cast<AiAgent*>(stub))->getTemplateLevel();
}

float AiAgentAdapter::getTame() {
	return (static_cast<AiAgent*>(stub))->getTame();
}

String AiAgentAdapter::getReactionStf() {
	return (static_cast<AiAgent*>(stub))->getReactionStf();
}

float AiAgentAdapter::getRespawnTimer() const {
	return (static_cast<AiAgent*>(stub))->getRespawnTimer();
}

bool AiAgentAdapter::getRandomRespawn() const {
	return (static_cast<AiAgent*>(stub))->getRandomRespawn();
}

int AiAgentAdapter::getRespawnCounter() const {
	return (static_cast<AiAgent*>(stub))->getRespawnCounter();
}

bool AiAgentAdapter::isAiAgent() {
	return (static_cast<AiAgent*>(stub))->isAiAgent();
}

bool AiAgentAdapter::hasLoot() {
	return (static_cast<AiAgent*>(stub))->hasLoot();
}

void AiAgentAdapter::setShowNextPosition(bool val) {
	(static_cast<AiAgent*>(stub))->setShowNextPosition(val);
}

bool AiAgentAdapter::isEventMob() {
	return (static_cast<AiAgent*>(stub))->isEventMob();
}

bool AiAgentAdapter::isPet() {
	return (static_cast<AiAgent*>(stub))->isPet();
}

unsigned int AiAgentAdapter::getCurrentBehavior() const {
	return (static_cast<AiAgent*>(stub))->getCurrentBehavior();
}

void AiAgentAdapter::setHomeObject(SceneObject* home) {
	(static_cast<AiAgent*>(stub))->setHomeObject(home);
}

void AiAgentAdapter::setCombatState() {
	(static_cast<AiAgent*>(stub))->setCombatState();
}

int AiAgentAdapter::getCreatureBitmask() {
	return (static_cast<AiAgent*>(stub))->getCreatureBitmask();
}

void AiAgentAdapter::setCreatureBitmask(int mask) {
	(static_cast<AiAgent*>(stub))->setCreatureBitmask(mask);
}

void AiAgentAdapter::setCreatureBit(unsigned int option) {
	(static_cast<AiAgent*>(stub))->setCreatureBit(option);
}

void AiAgentAdapter::clearCreatureBit(unsigned int option) {
	(static_cast<AiAgent*>(stub))->clearCreatureBit(option);
}

void AiAgentAdapter::incrementLuaCall(const String& key) {
	(static_cast<AiAgent*>(stub))->incrementLuaCall(key);
}

void AiAgentAdapter::addToLuaTime(const String& key, unsigned long long val) {
	(static_cast<AiAgent*>(stub))->addToLuaTime(key, val);
}

void AiAgentAdapter::outputLuaTimes(CreatureObject* caller) {
	(static_cast<AiAgent*>(stub))->outputLuaTimes(caller);
}

void AiAgentAdapter::rescheduleTrackingTask() {
	(static_cast<AiAgent*>(stub))->rescheduleTrackingTask();
}

bool AiAgentAdapter::hasRangedWeapon() {
	return (static_cast<AiAgent*>(stub))->hasRangedWeapon();
}

bool AiAgentAdapter::getUseRanged() {
	return (static_cast<AiAgent*>(stub))->getUseRanged();
}

bool AiAgentAdapter::hasSpecialAttack(int num) {
	return (static_cast<AiAgent*>(stub))->hasSpecialAttack(num);
}

void AiAgentAdapter::setPetDeed(PetDeed* deed) {
	(static_cast<AiAgent*>(stub))->setPetDeed(deed);
}

bool AiAgentAdapter::hasPetDeed() {
	return (static_cast<AiAgent*>(stub))->hasPetDeed();
}

PetDeed* AiAgentAdapter::getPetDeed() {
	return (static_cast<AiAgent*>(stub))->getPetDeed();
}

void AiAgentAdapter::sendReactionChat(int type, int state, bool force) {
	(static_cast<AiAgent*>(stub))->sendReactionChat(type, state, force);
}

bool AiAgentAdapter::hasReactionChatMessages() {
	return (static_cast<AiAgent*>(stub))->hasReactionChatMessages();
}

String AiAgentAdapter::getPersonalityStf() {
	return (static_cast<AiAgent*>(stub))->getPersonalityStf();
}

int AiAgentAdapter::getReactionRank() const {
	return (static_cast<AiAgent*>(stub))->getReactionRank();
}

void AiAgentAdapter::setReactionRank(int rank) {
	(static_cast<AiAgent*>(stub))->setReactionRank(rank);
}

int AiAgentAdapter::getHamMaximum() {
	return (static_cast<AiAgent*>(stub))->getHamMaximum();
}

int AiAgentAdapter::getHamBase() {
	return (static_cast<AiAgent*>(stub))->getHamBase();
}

void AiAgentAdapter::setMaxHAM(int type, int value, bool notifyClient) {
	(static_cast<AiAgent*>(stub))->setMaxHAM(type, value, notifyClient);
}

void AiAgentAdapter::reloadTemplate() {
	(static_cast<AiAgent*>(stub))->reloadTemplate();
}

unsigned int AiAgentAdapter::getConvoTemplateCRC() const {
	return (static_cast<AiAgent*>(stub))->getConvoTemplateCRC();
}

void AiAgentAdapter::setConvoTemplate(const String& templateString) {
	(static_cast<AiAgent*>(stub))->setConvoTemplate(templateString);
}

void AiAgentAdapter::setLairTemplateCRC(unsigned int crc) {
	(static_cast<AiAgent*>(stub))->setLairTemplateCRC(crc);
}

unsigned int AiAgentAdapter::getLairTemplateCRC() const {
	return (static_cast<AiAgent*>(stub))->getLairTemplateCRC();
}

/*
 *	AiAgentHelper
 */

AiAgentHelper* AiAgentHelper::staticInitializer = AiAgentHelper::instance();

AiAgentHelper::AiAgentHelper() {
	className = "AiAgent";

	Core::getObjectBroker()->registerClass(className, this);
}

void AiAgentHelper::finalizeHelper() {
	AiAgentHelper::finalize();
}

DistributedObject* AiAgentHelper::instantiateObject() {
	return new AiAgent(DummyConstructorParameter::instance());
}

DistributedObjectServant* AiAgentHelper::instantiateServant() {
	return new AiAgentImplementation();
}

DistributedObjectAdapter* AiAgentHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new AiAgentAdapter(static_cast<AiAgent*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

